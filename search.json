[
  {
    "objectID": "posts/post-with-code/2023-04-03-binding-site-comparison-benchmark-I/2023-04-03-binding-site-comparison-benchmark-i.html",
    "href": "posts/post-with-code/2023-04-03-binding-site-comparison-benchmark-I/2023-04-03-binding-site-comparison-benchmark-i.html",
    "title": "Binding Site Comparison Benchmarks - I - Binding sites on the same protein",
    "section": "",
    "text": "In this article I’ll go through the overall thought process of setting up a benchmark set for the same binding site on the same protein. For the sake of simplicity I’ll do it for a single target to evaluate the performance of a binding site comparison algorithm. I’ll try to provide code whenever possible against public resources or snippets if a bit of scripting is needed. I will for sure run into dead ends (I won’t describe all of these 😬) and as a result I’ll have to make some decisions & put other things aside. In order to keep track of things I put aside I’ll use a side-note throughout the post to track all of these & make a summary of how to address or amend them later.\n\n\nThings to keep in mind\n\nlisting goes here"
  },
  {
    "objectID": "posts/post-with-code/2023-04-03-binding-site-comparison-benchmark-I/2023-04-03-binding-site-comparison-benchmark-i.html#why-hsp90-as-a-first-example",
    "href": "posts/post-with-code/2023-04-03-binding-site-comparison-benchmark-I/2023-04-03-binding-site-comparison-benchmark-i.html#why-hsp90-as-a-first-example",
    "title": "Binding Site Comparison Benchmarks - I - Binding sites on the same protein",
    "section": "Why HSP90 as a first example",
    "text": "Why HSP90 as a first example\n\nHSP90 has a lot of structures available in the public domain\nIt’s not part of any gigantic protein family (kinases, GPCR’s etc), which keeps the initial comparison space to cover a bit smaller and easier to manage\nThe fold of the protein is still conserved among several other proteins, so there’s matter for detecting expected similarities\nIt binds ATP, such as a lot of proteins in nature - which is interesting for the if I bind the same molecule I must be similar conundrum\nThe binding site can undergo important conformational changes, which is good to evaluate sensity on conformation\nWater plays a very important role upon binding of small molecules into the ATP binding site"
  },
  {
    "objectID": "posts/post-with-code/2023-04-03-binding-site-comparison-benchmark-I/2023-04-03-binding-site-comparison-benchmark-i.html#domain-architecture",
    "href": "posts/post-with-code/2023-04-03-binding-site-comparison-benchmark-I/2023-04-03-binding-site-comparison-benchmark-i.html#domain-architecture",
    "title": "Binding Site Comparison Benchmarks - I - Binding sites on the same protein",
    "section": "Domain architecture",
    "text": "Domain architecture\nHSP90 alpha human is composed of two domains: - the N-terminal Histidine kinase, DNA gyrase B and HSP90-like ATPase domain (ranging from amino acid 40 to 193) - the C-terminal HSP90 protein domain (196-714)\nThe ATP binding site of interest is on the N-terminal part and this is the part that you have the most crystal structures in the RCSB today. A full length Alphafold model is also available in the public domain, but I won’t discuss any of that here for now. NB: there appears to be another ATP binding site on the C-terminal part, that is only accessible when activated - so interesting to maybe look out for that one as well (Soti et al. (2003)). But again, not the main purpose of this post."
  },
  {
    "objectID": "posts/post-with-code/2023-04-03-binding-site-comparison-benchmark-I/2023-04-03-binding-site-comparison-benchmark-i.html#the-topology-of-the-atp-binding-site-n-ter",
    "href": "posts/post-with-code/2023-04-03-binding-site-comparison-benchmark-I/2023-04-03-binding-site-comparison-benchmark-i.html#the-topology-of-the-atp-binding-site-n-ter",
    "title": "Binding Site Comparison Benchmarks - I - Binding sites on the same protein",
    "section": "The topology of the ATP binding site (N-ter)",
    "text": "The topology of the ATP binding site (N-ter)\n\n\nCode\n// Create drawing area\ndivNGL = html`&lt;div style=\"width:800px;height:600px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\nFigure 1: Overview of N-terminal domain of human HSP90, canonical isoform\n\n\n\n\n\nCode\nNGL = require(\"ngl@next\");\n// Create trajectory object\nstage = new NGL.Stage(divNGL, { backgroundColor: \"black\",cameraType: \"orthographic\"});\npdbString = await FileAttachment(\"3t0z.pdb\").blob();\nstructure = await stage.loadFile(pdbString, {ext: \"pdb\", asTrajectory: false})\nstructure.addRepresentation(\"cartoon\",{ \"sele\": \"protein\", \"color\": \"residueindex\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nstructure.addRepresentation(\"ball+stick\",{ \"sele\": \"hetero and _C\", \"color\": \"yellow\"});\n\n\n\n\n\n\n\n\n\nCode\nstructure.addRepresentation(\"ball+stick\",{ \"sele\": \"hetero\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\nCode\nstructure.addRepresentation(\"licorice\",{ \"sele\": \"47-55 or 91 or 93 or 96-97 or 98 or 102 or 106 or 107 or 112 or 132-139 or 150 or 162 or or 186\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\nCode\nstructure.addRepresentation(\"contact\",{ \"sele\": \"47-55 or 91 or 93 or 96-97 or 98 or 102 or 106 or 107 or 112 or 132-139 or 150 or 162 or or 186 or ligand or water\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\nCode\nstructure.autoView();\n\n\n\n\n\n\n\n\n\nThe binding site is composed of a section containing the adenin moiety which is characterized by a beta sheet at the bottom of the site, and two helices lining the site. The sidechains exposed to the binding site lumen are globally hydrophobic, a part from the very important aspartate 93, which is interacting directly with the adenine moiety. The adenine moiety is surrounded by water molecules and several of these waters are important hallmarks of several HSP90 binders. The ribose moiety is not forming any H-bonds with the protein itself but has hydroxyls oriented towards the solvent. The ether of the ribose is oriented towards the valine 107, adjacent to a rather hydrophobic part of the pocket coated by Y139, F138 and W162. The triphospate is solvent exposed and interacting with a small helix-loop-helix motive which, as we will probably see a bit later part of the more mobile regions of the binding site."
  },
  {
    "objectID": "posts/post-with-code/2023-04-03-binding-site-comparison-benchmark-I/2023-04-03-binding-site-comparison-benchmark-i.html#same-sequence-conformation",
    "href": "posts/post-with-code/2023-04-03-binding-site-comparison-benchmark-I/2023-04-03-binding-site-comparison-benchmark-i.html#same-sequence-conformation",
    "title": "Binding Site Comparison Benchmarks - I - Binding sites on the same protein",
    "section": "Same sequence & conformation",
    "text": "Same sequence & conformation\nAlright, here we go … the same sequence is the easiest case of all of them & several previous studies included a selection of structures, but as you’ll see even here to do things properly it gets quickly tricky. The following script will cover the required steps:\n\ndefine the sets of residues of our reference binding site\ngather all structures (PDB codes) containing a resolved HSP90 alpha human N terminal domain\nfilter out structures with mutations on binding site residues compared to the wild type\nget an all by all comparison of the binding sites (structurally speaking) which would allow for some rough clustering of conformations\n\n\nDefining the binding site\nOn Figure 1 we already displayed a set of amino-acids on the HSP90 structure surrounding the binding site. Let’s get a list defined by hand getting all residues:\n\n\nTable 1: ATP binding site residue selection on structure 4cwr\n\n\nWT Sequence Position\nChain\nResidue\n\n\n\n\nE47\nA\nE47\n\n\nL48\nA\nL48\n\n\nN51\nA\nN51\n\n\nS52\nA\nS52\n\n\nD54\nA\nD54\n\n\nA55\nA\nA55\n\n\nK58\nA\nK58\n\n\nD93\nA\nD93\n\n\nG95\nA\nG95\n\n\nI96\nA\nI96\n\n\nG97\nA\nG97\n\n\nM98\nA\nM98\n\n\nN106\nA\nN106\n\n\nL107\nA\nL107\n\n\nK112\nA\nK112\n\n\nI131\nA\nI131\n\n\nG132\nA\nG132\n\n\nQ133\nA\nQ133\n\n\nF134\nA\nF134\n\n\nG135\nA\nG135\n\n\nV136\nA\nV136\n\n\nG137\nA\nG137\n\n\nF138\nA\nF138\n\n\nY139\nA\nY139\n\n\nT152\nA\nY152\n\n\nG183\nA\nG183\n\n\nT184\nA\nT184\n\n\nV186\nA\nV186\n\n\n\n\n\n\nGathering all PDB codes containing the site\nNow we have the protein & binding site of interest defined, we can gather all RCSB PDB structures containing that portion without mutations compared to the WT sequence. The uniprot accession for the human HSP90 is P07900 (HS90A_HUMAN) & we will use the WT HSP90 alpha here as reference. NB: there is a known splice variant adding another 123 amino acids in front of ther canonical N-terminal part of the protein.\nIn order to retrieve all PDB structures of a particular protein sequences one can use various resources. The obvious one to start with would be uniprot, ncbi or the RCSB itself.\nFrom uniprot we can use something like the ID mapping service for instance:\n\n\nCode\n# Code adapted from here: https://www.uniprot.org/help/id_mapping\nimport re\nimport time\nimport json\nimport zlib\nfrom urllib.parse import urlparse, parse_qs, urlencode\nimport requests\nfrom requests.adapters import HTTPAdapter, Retry\n\n\nPOLLING_INTERVAL = 3\nAPI_URL = \"https://rest.uniprot.org\"\n\n\nretries = Retry(total=5, backoff_factor=0.25, status_forcelist=[500, 502, 503, 504])\nsession = requests.Session()\nsession.mount(\"https://\", HTTPAdapter(max_retries=retries))\n\n\ndef check_response(response):\n    try:\n        response.raise_for_status()\n    except requests.HTTPError:\n        print(response.json())\n        raise\n\n\ndef submit_id_mapping(from_db, to_db, ids):\n    request = requests.post(\n        f\"{API_URL}/idmapping/run\",\n        data={\"from\": from_db, \"to\": to_db, \"ids\": \",\".join(ids)},\n    )\n    check_response(request)\n    return request.json()[\"jobId\"]\n\n\ndef get_next_link(headers):\n    re_next_link = re.compile(r'&lt;(.+)&gt;; rel=\"next\"')\n    if \"Link\" in headers:\n        match = re_next_link.match(headers[\"Link\"])\n        if match:\n            return match.group(1)\n\n\ndef check_id_mapping_results_ready(job_id):\n    while True:\n        request = session.get(f\"{API_URL}/idmapping/status/{job_id}\")\n        check_response(request)\n        j = request.json()\n        if \"jobStatus\" in j:\n            if j[\"jobStatus\"] == \"RUNNING\":\n                print(f\"Retrying in {POLLING_INTERVAL}s\")\n                time.sleep(POLLING_INTERVAL)\n            else:\n                raise Exception(j[\"jobStatus\"])\n        else:\n            return bool(j[\"results\"] or j[\"failedIds\"])\n\n\ndef get_batch(batch_response, file_format, compressed):\n    batch_url = get_next_link(batch_response.headers)\n    while batch_url:\n        batch_response = session.get(batch_url)\n        batch_response.raise_for_status()\n        yield decode_results(batch_response, file_format, compressed)\n        batch_url = get_next_link(batch_response.headers)\n\n\ndef combine_batches(all_results, batch_results, file_format):\n    if file_format == \"json\":\n        for key in (\"results\", \"failedIds\"):\n            if key in batch_results and batch_results[key]:\n                all_results[key] += batch_results[key]\n    elif file_format == \"tsv\":\n        return all_results + batch_results[1:]\n    else:\n        return all_results + batch_results\n    return all_results\n\n\ndef get_id_mapping_results_link(job_id):\n    url = f\"{API_URL}/idmapping/details/{job_id}\"\n    request = session.get(url)\n    check_response(request)\n    return request.json()[\"redirectURL\"]\n\n\ndef decode_results(response, file_format, compressed):\n    if compressed:\n        decompressed = zlib.decompress(response.content, 16 + zlib.MAX_WBITS)\n        if file_format == \"json\":\n            j = json.loads(decompressed.decode(\"utf-8\"))\n            return j\n        elif file_format == \"tsv\":\n            return [line for line in decompressed.decode(\"utf-8\").split(\"\\n\") if line]\n        elif file_format == \"xlsx\":\n            return [decompressed]\n        else:\n            return decompressed.decode(\"utf-8\")\n    elif file_format == \"json\":\n        return response.json()\n    elif file_format == \"tsv\":\n        return [line for line in response.text.split(\"\\n\") if line]\n    elif file_format == \"xlsx\":\n        return [response.content]\n    return response.text\n\n\n\ndef print_progress_batches(batch_index, size, total):\n    n_fetched = min((batch_index + 1) * size, total)\n    print(f\"Fetched: {n_fetched} / {total}\")\n\n\ndef get_id_mapping_results_search(url):\n    parsed = urlparse(url)\n    query = parse_qs(parsed.query)\n    file_format = query[\"format\"][0] if \"format\" in query else \"tsv\"\n    if \"size\" in query:\n        size = int(query[\"size\"][0])\n    else:\n        size = 500\n        query[\"size\"] = size\n    compressed = (\n        query[\"compressed\"][0].lower() == \"true\" if \"compressed\" in query else False\n    )\n    parsed = parsed._replace(query=urlencode(query, doseq=True))\n    url = parsed.geturl()\n    request = session.get(url)\n    check_response(request)\n    results = decode_results(request, file_format, compressed)\n    total = int(request.headers[\"x-total-results\"])\n    print_progress_batches(0, size, total)\n    for i, batch in enumerate(get_batch(request, file_format, compressed), 1):\n        results = combine_batches(results, batch, file_format)\n        print_progress_batches(i, size, total)\n    return results\n\njob_id = submit_id_mapping(\n    from_db=\"UniProtKB_AC-ID\", to_db=\"PDB\", ids=[\"P07900\"]\n)\nif check_id_mapping_results_ready(job_id):\n    link = get_id_mapping_results_link(job_id)\n    results = get_id_mapping_results_search(link)\n    results_python = json.loads(results[0])[\"results\"]\n    # print(results_python)\n    up_pdbcodes=[element[\"to\"].lower() for element in results_python]\n    print(up_pdbcodes)\n\n\nFetched: 328 / 328\n['1byq', '1osf', '1uy6', '1uy7', '1uy8', '1uy9', '1uyc', '1uyd', '1uye', '1uyf', '1uyg', '1uyh', '1uyi', '1uyk', '1uyl', '1yc1', '1yc3', '1yc4', '1yer', '1yes', '1yet', '2bsm', '2bt0', '2bug', '2byh', '2byi', '2bz5', '2c2l', '2ccs', '2cct', '2ccu', '2fwy', '2fwz', '2h55', '2jjc', '2k5b', '2qf6', '2qfo', '2qg0', '2qg2', '2uwd', '2vci', '2vcj', '2wi1', '2wi2', '2wi3', '2wi4', '2wi5', '2wi6', '2wi7', '2xab', '2xdk', '2xdl', '2xds', '2xdu', '2xdx', '2xhr', '2xht', '2xhx', '2xjg', '2xjj', '2xjx', '2xk2', '2ye2', '2ye3', '2ye4', '2ye5', '2ye6', '2ye7', '2ye8', '2ye9', '2yea', '2yeb', '2yec', '2yed', '2yee', '2yef', '2yeg', '2yeh', '2yei', '2yej', '2yi0', '2yi5', '2yi6', '2yi7', '2yjw', '2yjx', '2yk2', '2yk9', '2ykb', '2ykc', '2yke', '2yki', '2ykj', '3b24', '3b25', '3b26', '3b27', '3b28', '3bm9', '3bmy', '3d0b', '3eko', '3ekr', '3ft5', '3ft8', '3hek', '3hhu', '3hyy', '3hyz', '3hz1', '3hz5', '3inw', '3inx', '3k97', '3k98', '3k99', '3mnr', '3o0i', '3ow6', '3owb', '3owd', '3q6m', '3q6n', '3qdd', '3qtf', '3r4m', '3r4n', '3r4o', '3r4p', '3r91', '3r92', '3rkz', '3rlp', '3rlq', '3rlr', '3t0h', '3t0z', '3t10', '3t1k', '3t2s', '3tuh', '3vha', '3vhc', '3vhd', '3wha', '3wq9', '4aif', '4awo', '4awp', '4awq', '4b7p', '4bqg', '4bqj', '4cgq', '4cgu', '4cgv', '4cgw', '4cwf', '4cwn', '4cwo', '4cwp', '4cwq', '4cwr', '4cws', '4cwt', '4eeh', '4eft', '4efu', '4egh', '4egi', '4egk', '4fcp', '4fcq', '4fcr', '4hy6', '4jql', '4l8z', '4l90', '4l91', '4l93', '4l94', '4lwe', '4lwf', '4lwg', '4lwh', '4lwi', '4nh7', '4nh8', '4o04', '4o05', '4o07', '4o09', '4o0b', '4r3m', '4u93', '4w7t', '4xip', '4xiq', '4xir', '4xit', '4ykq', '4ykr', '4ykt', '4yku', '4ykw', '4ykx', '4yky', '4ykz', '5cf0', '5fnc', '5fnd', '5fnf', '5ggz', '5j20', '5j27', '5j2v', '5j2x', '5j64', '5j6l', '5j6m', '5j6n', '5j80', '5j82', '5j86', '5j8m', '5j8u', '5j9x', '5lny', '5lnz', '5lo0', '5lo1', '5lo5', '5lo6', '5lq9', '5lr1', '5lr7', '5lrl', '5lrz', '5ls1', '5m4e', '5m4h', '5nyh', '5nyi', '5oci', '5od7', '5odx', '5t21', '5vyy', '5xqd', '5xqe', '5xr5', '5xr9', '5xrb', '5xrd', '5xre', '5zr3', '6b99', '6b9a', '6ceo', '6cyg', '6cyh', '6ei5', '6el5', '6eln', '6elo', '6elp', '6ey8', '6ey9', '6eya', '6eyb', '6f1n', '6fcj', '6fdp', '6gp4', '6gp8', '6gpf', '6gph', '6gpo', '6gpp', '6gpr', '6gpt', '6gpw', '6gpy', '6gq6', '6gqr', '6gqs', '6gqu', '6gr1', '6gr3', '6gr4', '6gr5', '6hhr', '6ksq', '6lr9', '6lsz', '6lt8', '6lti', '6ltk', '6n8x', '6olx', '6tn4', '6tn5', '6u98', '6u99', '6u9a', '6u9b', '7dmc', '7krj', '7kw7', '7l7i', '7l7j', '7lsz', '7lt0', '7ry1', '7s8y', '7s8z', '7s90', '7s95', '7s98', '7s99', '7s9f', '7s9g', '7s9h', '7s9i', '8agi', '8agj', '8agl']\n\n\nThis results in a list of 328 structures. As uniprot isn’t the only source to get that info, let’s check what comes out of the same type of query against the RCSB PDB, should be the same, right?\n\n\nCode\ninputjson=\"\"\"{\n  \"query\": {\n    \"type\": \"group\",\n    \"nodes\": [\n      {\n        \"type\": \"terminal\",\n        \"service\": \"text\",\n        \"parameters\": {\n          \"attribute\": \"rcsb_polymer_entity_container_identifiers.reference_sequence_identifiers.database_accession\",\n          \"operator\": \"in\",\n          \"value\": [\n            \"P07900\"\n          ]\n        }\n      },\n      {\n        \"type\": \"terminal\",\n        \"service\": \"text\",\n        \"parameters\": {\n          \"attribute\": \"rcsb_polymer_entity_container_identifiers.reference_sequence_identifiers.database_name\",\n          \"operator\": \"exact_match\",\n          \"value\": \"UniProt\",\n          \"negation\": false\n        }\n      }\n    ],\n    \"logical_operator\": \"and\",\n    \"label\": \"nested-attribute\"\n  },\n  \"return_type\": \"entry\",\n  \"request_options\": {\n    \"paginate\": {\n      \"start\": 0,\n      \"rows\": 500\n    },\n    \"results_content_type\": [\n      \"experimental\"\n    ],\n    \"sort\": [\n      {\n        \"sort_by\": \"score\",\n        \"direction\": \"desc\"\n      }\n    ],\n    \"scoring_strategy\": \"combined\"\n  }\n}\"\"\"\nurl=\"https://search.rcsb.org/rcsbsearch/v2/query?json=\"+inputjson\nresponse=requests.get(url)\ntmp=json.loads(response.text)[\"result_set\"]\nrcsb_pdbcodes=[element[\"identifier\"].lower() for element in tmp]\nprint(len(rcsb_pdbcodes))\nprint(rcsb_pdbcodes)\n\n\n331\n['1byq', '1osf', '1uy6', '1uy7', '1uy8', '1uy9', '1uyc', '1uyd', '1uye', '1uyf', '1uyg', '1uyh', '1uyi', '1uyk', '1uyl', '1yc1', '1yc3', '1yc4', '1yer', '1yes', '1yet', '2bsm', '2bt0', '2bug', '2byh', '2byi', '2bz5', '2c2l', '2ccs', '2cct', '2ccu', '2fwy', '2fwz', '2h55', '2jjc', '2k5b', '2qf6', '2qfo', '2qg0', '2qg2', '2uwd', '2vci', '2vcj', '2wi1', '2wi2', '2wi3', '2wi4', '2wi5', '2wi6', '2wi7', '2xab', '2xdk', '2xdl', '2xds', '2xdu', '2xdx', '2xhr', '2xht', '2xhx', '2xjg', '2xjj', '2xjx', '2xk2', '2ye2', '2ye3', '2ye4', '2ye5', '2ye6', '2ye7', '2ye8', '2ye9', '2yea', '2yeb', '2yec', '2yed', '2yee', '2yef', '2yeg', '2yeh', '2yei', '2yej', '2yi0', '2yi5', '2yi6', '2yi7', '2yjw', '2yjx', '2yk2', '2yk9', '2ykb', '2ykc', '2yke', '2yki', '2ykj', '3b24', '3b25', '3b26', '3b27', '3b28', '3bm9', '3bmy', '3d0b', '3eko', '3ekr', '3ft5', '3ft8', '3hek', '3hhu', '3hyy', '3hyz', '3hz1', '3hz5', '3inw', '3inx', '3k97', '3k98', '3k99', '3mnr', '3o0i', '3ow6', '3owb', '3owd', '3q6m', '3q6n', '3qdd', '3qtf', '3r4m', '3r4n', '3r4o', '3r4p', '3r91', '3r92', '3rkz', '3rlp', '3rlq', '3rlr', '3t0h', '3t0z', '3t10', '3t1k', '3t2s', '3tuh', '3vha', '3vhc', '3vhd', '3wha', '3wq9', '4aif', '4awo', '4awp', '4awq', '4b7p', '4bqg', '4bqj', '4cgq', '4cgu', '4cgv', '4cgw', '4cwf', '4cwn', '4cwo', '4cwp', '4cwq', '4cwr', '4cws', '4cwt', '4eeh', '4eft', '4efu', '4egh', '4egi', '4egk', '4fcp', '4fcq', '4fcr', '4hy6', '4jql', '4l8z', '4l90', '4l91', '4l93', '4l94', '4lwe', '4lwf', '4lwg', '4lwh', '4lwi', '4nh7', '4nh8', '4o04', '4o05', '4o07', '4o09', '4o0b', '4r3m', '4u93', '4w7t', '4xip', '4xiq', '4xir', '4xit', '4ykq', '4ykr', '4ykt', '4yku', '4ykw', '4ykx', '4yky', '4ykz', '5cf0', '5fnc', '5fnd', '5fnf', '5ggz', '5j20', '5j27', '5j2v', '5j2x', '5j64', '5j6l', '5j6m', '5j6n', '5j80', '5j82', '5j86', '5j8m', '5j8u', '5j9x', '5lny', '5lnz', '5lo0', '5lo1', '5lo5', '5lo6', '5lq9', '5lr1', '5lr7', '5lrl', '5lrz', '5ls1', '5m4e', '5m4h', '5nyh', '5nyi', '5oci', '5od7', '5odx', '5t21', '5vyy', '5xqd', '5xqe', '5xr5', '5xr9', '5xrb', '5xrd', '5xre', '5zr3', '6b99', '6b9a', '6ceo', '6cyg', '6cyh', '6ei5', '6el5', '6eln', '6elo', '6elp', '6ey8', '6ey9', '6eya', '6eyb', '6f1n', '6fcj', '6fdp', '6gp4', '6gp8', '6gpf', '6gph', '6gpo', '6gpp', '6gpr', '6gpt', '6gpw', '6gpy', '6gq6', '6gqr', '6gqs', '6gqu', '6gr1', '6gr3', '6gr4', '6gr5', '6hhr', '6ksq', '6lr9', '6lsz', '6lt8', '6lti', '6ltk', '6n8x', '6olx', '6tn4', '6tn5', '6u98', '6u99', '6u9a', '6u9b', '7dmc', '7krj', '7kw7', '7l7i', '7l7j', '7lsz', '7lt0', '7rxz', '7ry0', '7ry1', '7s8y', '7s8z', '7s90', '7s95', '7s98', '7s99', '7s9f', '7s9g', '7s9h', '7s9i', '7ur3', '8agi', '8agj', '8agl']\n\n\nFrom the RCSB we get 3 more structures than from Uniprot. Let’s see what the difference between both lists of pdb codes is:\n\n\n['7rxz', '7ry0', '7ur3']\n\n\nAgain a bit worrisome difference between the RCSB & Uniprot. An NCBI search seems to give yet another number of 273 structures. NB: when you have a look at the P07900 sequence cluster page of the RCSB, one gets 332 hits instead, so even one more than through the API. The RCSB seems to handle the uniprot accession code a bit differently from the Polymer Entity Group ID (or there’s an issue with the data of one structure) when searching through the advanced search through the UI. I’ll have to check with the RCSB folks on that one. For now I’ll stick to the 331 structures from the previous API call vs the RCSB.\n\n\nThings to keep in mind\n\nUniprot accession vs polymer entity group ID handling to be clarified with RCSB folks\n\nAs we can see in Table 1 the residues encompassing our binding site of interest range from amino acid E47 on the WT sequence to V186. So now we need to know whether the region expressed & resolved in each crystal structure includes our binding site of interest. This can now be done with a graphQL query versus the RCSB (after a lot of trial & error 😒 ). NB: I directly filter out structures (18) that contain mutations versus wild type.\n\n\nCode\nquery=\"\"\"\n{\n  entries(entry_ids: \"\"\"+str(rcsb_pdbcodes).replace(\"'\",\"\\\"\")+\"\"\")\n  {\n    rcsb_id\n    \n    polymer_entities {\n      rcsb_polymer_entity_container_identifiers {\n        entity_id\n        asym_ids\n        auth_asym_ids\n        reference_sequence_identifiers {\n          database_name\n          database_accession\n        }\n      }\n      rcsb_polymer_entity_align{\n        \n  reference_database_name\n        aligned_regions{\n          entity_beg_seq_id\n          length\n          ref_beg_seq_id\n        }\n        \n      }\n      entity_poly {\n        pdbx_seq_one_letter_code_can\n        rcsb_sample_sequence_length\n        type\n        rcsb_mutation_count\n      }\n      rcsb_polymer_entity {\n        formula_weight\n      }\n    }\n  }\n}\n\"\"\"\n\n# ugly I know, but does the job here\ndef extractSequenceRegions(data):\n  result={}\n  \n  for entry in data:  \n    result[entry[\"rcsb_id\"]]=[]\n    for entity in entry[\"polymer_entities\"]:\n      # print(entity[\"rcsb_polymer_entity_container_identifiers\"])\n      if entity[\"entity_poly\"][\"rcsb_mutation_count\"]==0:\n        for idx,identifier in enumerate(entity[\"rcsb_polymer_entity_container_identifiers\"][\"reference_sequence_identifiers\"]):\n          if identifier[\"database_name\"]==\"UniProt\" and identifier[\"database_accession\"]==\"P07900\":\n            if entity[\"rcsb_polymer_entity_align\"][idx][\"reference_database_name\"]==\"UniProt\":\n              for region in entity[\"rcsb_polymer_entity_align\"][idx][\"aligned_regions\"]:\n                result[entry[\"rcsb_id\"]].append((region[\"ref_beg_seq_id\"],region[\"ref_beg_seq_id\"]+region[\"length\"]))\n  return result\n\nresiduelist=[47,48,51,52,54,55,58,93,95,96,97,98,106,107,112,131,132,133,134,135,136,137,138,139,152,183,184,186]\n\nurl=f\"https://data.rcsb.org/graphql?query={query}\"\nresponse=requests.get(url)\ndataRCSBGQL=response.json()[\"data\"][\"entries\"]\n\n\nresolved_regions=extractSequenceRegions(dataRCSBGQL)\n\nselectedPdbCodes=[]\nfor pdbCode in resolved_regions:\n  for mapping in resolved_regions[pdbCode]:\n    if(all(i&gt;=mapping[0] and i&lt;=mapping[1] for i in residuelist)):\n      selectedPdbCodes.append(pdbCode)\n\nprint(selectedPdbCodes)\nprint(str(len(selectedPdbCodes)) + \" structures identified\")\n\n\n['1BYQ', '1OSF', '1UY6', '1UY7', '1UY8', '1UY9', '1UYC', '1UYD', '1UYE', '1UYF', '1UYG', '1UYH', '1UYI', '1UYK', '1UYL', '1YC1', '1YC3', '1YC4', '1YER', '1YES', '1YET', '2BSM', '2BT0', '2BYH', '2BYI', '2BZ5', '2CCS', '2CCT', '2CCU', '2FWY', '2FWZ', '2H55', '2JJC', '2K5B', '2QF6', '2QFO', '2QG0', '2QG2', '2UWD', '2VCI', '2VCJ', '2WI1', '2WI2', '2WI3', '2WI4', '2WI5', '2WI6', '2WI7', '2XAB', '2XDK', '2XDL', '2XDS', '2XDU', '2XDX', '2XHR', '2XHT', '2XHX', '2XJG', '2XJJ', '2XJX', '2XK2', '2YE2', '2YE3', '2YE4', '2YE5', '2YE6', '2YE7', '2YE8', '2YE9', '2YEA', '2YEB', '2YEC', '2YED', '2YEE', '2YEF', '2YEG', '2YEH', '2YEI', '2YEJ', '2YI0', '2YI5', '2YI6', '2YI7', '2YJW', '2YJX', '2YK2', '2YK9', '2YKB', '2YKC', '2YKE', '2YKI', '2YKJ', '3B24', '3B25', '3B26', '3B27', '3B28', '3BM9', '3BMY', '3D0B', '3EKO', '3EKR', '3FT5', '3FT8', '3HEK', '3HHU', '3HYY', '3HYZ', '3HZ1', '3HZ5', '3INW', '3INX', '3K97', '3K98', '3K99', '3MNR', '3O0I', '3OW6', '3OWB', '3OWD', '3QDD', '3QTF', '3R4M', '3R4N', '3R4O', '3R4P', '3R91', '3R92', '3RKZ', '3RLP', '3RLQ', '3RLR', '3T0H', '3T0Z', '3T10', '3T1K', '3T2S', '3TUH', '3VHA', '3VHC', '3VHD', '3WHA', '3WQ9', '4AWO', '4AWP', '4AWQ', '4B7P', '4BQG', '4BQJ', '4CWF', '4CWN', '4CWO', '4CWP', '4CWQ', '4CWR', '4CWS', '4CWT', '4EEH', '4EFT', '4EFU', '4EGH', '4EGI', '4EGK', '4FCP', '4FCQ', '4FCR', '4HY6', '4JQL', '4L8Z', '4L90', '4L91', '4L93', '4L94', '4LWE', '4LWF', '4LWG', '4LWH', '4LWI', '4NH7', '4NH8', '4O04', '4O05', '4O07', '4O09', '4O0B', '4R3M', '4U93', '4W7T', '4XIP', '4XIQ', '4XIR', '4XIT', '4YKQ', '4YKR', '4YKT', '4YKU', '4YKW', '4YKX', '4YKY', '4YKZ', '5CF0', '5FNC', '5FND', '5FNF', '5GGZ', '5J20', '5J27', '5J2V', '5J2X', '5J64', '5J6L', '5J6M', '5J6N', '5J82', '5J86', '5J8M', '5J8U', '5J9X', '5LNY', '5LNZ', '5LO0', '5LO1', '5LO5', '5LO6', '5LQ9', '5LR1', '5LR7', '5LRL', '5LRZ', '5LS1', '5M4E', '5M4H', '5NYH', '5NYI', '5OCI', '5OD7', '5ODX', '5T21', '5VYY', '5XQD', '5XQE', '5XR5', '5XR9', '5XRB', '5XRD', '5XRE', '5ZR3', '6B99', '6B9A', '6CEO', '6CYG', '6CYH', '6EI5', '6EL5', '6ELN', '6ELO', '6ELP', '6EY8', '6EY9', '6EYA', '6EYB', '6F1N', '6FCJ', '6GPR', '6GPT', '6GPW', '6GPY', '6GQ6', '6GQR', '6HHR', '6LR9', '6LSZ', '6LT8', '6LTI', '6LTK', '6N8X', '6TN4', '6TN5', '6U99', '6U9B', '7DMC', '7KRJ', '7KW7', '7L7I', '7L7J', '7LSZ', '7LT0', '7S8Y', '7S8Z', '7S90', '7S95', '7S98', '7S99', '7S9F', '7S9G', '7S9H', '7S9I', '7UR3', '8AGI']\n299 structures identified\n\n\nNow we have our list of 299 WT structures with the ATP binding site resolved. NB: you might have noticed that I’m not taking the resolution, Rfree or Rwork into account for the structure selection here. That’s on purpose. During the subsequent clustering step I’ll still check if all residues of interest of the binding site are resolved (or have been modelled by the crystallographer).\n\n\nThings to keep in mind\n\nUniprot accession vs polymer entity group ID handling to be clarified with RCSB folks\nDon’t forget to check if all sidechains of the binding site are resolved in the selected structures\n\n\n\nCluster by conformation\nThe ATP binding site of HSP90 can be fairly flexible in specific regions. In order to evaluate a pocket comparison method’s sensitivity to sidechain or backbone movements we can split down the 299 structures we just identified to smaller clusters of very similar conformations. This will allow us later to run tests using different pocket comparison algorithms.\nAlready doing all the previous work was not as straightforward as what one might have expected, but it’s still doable. Especially with the API available now from the RCSB. A few years back one had to rely on predictions from the SIFTS project from Dana et al. (2018) & Velankar et al. (2012).\nUsually one relies then on superposing all structures onto a single reference frame & detect main differences, calculate RMSD’s etc. However, the structural superimpositioning poses the following challenges here:\n\nin case of a multimer, shall we use all chains or all if the asymetric unit contains several copies of the same protein?\n\nIn theory we should assess if there are major differences between monomers or use the monomers as expected hit we should retrieve when comparing binding sites. Both should be covered by the overall dataset here so I’ll be lazy and will focus on the first chain\n\nshall we use a standard Kabsch superimpositioning (Kabsch 1976) (local/global?) & overall root mean square deviation to assess the similarity between binding site conformations?\n\nIf I’m bringing this thing up, I think it’s important to address it properly. I’ll try to explain a bit in more detail why\n\n\n\n\nThings to keep in mind\n\nUniprot accession vs polymer entity group ID handling to be clarified with RCSB folks\nDon’t forget to check if all sidechains of the binding site are resolved in the selected structures\nTreat homo-multimers rationally in the data-set construction\n\n\nWhy isn’t standard superimpositioning enough?\nI don’t have to write a ton of text here, citing the single, most relevant paper from Damm and Carlson (2006) should be argument enough 😁\nBut to showcase maybe a bit more clearly. HSP90 can adopt several conformations in different areas of the binding site:\n\n\nCode\n// Create drawing area\ndivNGL2 = html`&lt;div style=\"width:800px;height:600px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\nFigure 2: Comparison of distinct binding site conformations (3t0z,4cwr & 7l7j)\n\n\n\n\n\nCode\nstage2 = new NGL.Stage(divNGL2, { backgroundColor: \"black\",cameraType: \"orthographic\"});\npdbString1 = await FileAttachment(\"3t0z.pdb\").blob();\nstructure1 = await stage2.loadFile(pdbString1, {ext: \"pdb\", asTrajectory: false})\nstructure1.addRepresentation(\"cartoon\",{ \"sele\": \"protein\", \"color\": \"#325E73\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nstructure1.addRepresentation(\"ball+stick\",{ \"sele\": \"ATP\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\nCode\npdbString2 = await FileAttachment(\"pdbs/4cwr_aligned.pdb\").blob();\nstructure2 = await stage2.loadFile(pdbString2, {ext: \"pdb\", asTrajectory: false})\nstructure2.addRepresentation(\"cartoon\",{ \"sele\": \"protein\", \"color\": \"#B69849\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\npdbString3 = await FileAttachment(\"pdbs/7l7j_aligned.pdb\").blob();\nstructure3 = await stage2.loadFile(pdbString3, {ext: \"pdb\", asTrajectory: false})\nstructure3.addRepresentation(\"cartoon\",{ \"sele\": \"protein\", \"color\": \"#B66049\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nstructure1.autoView(\"ATP\");\n\n\n\n\n\n\n\n\n\nSo if you superimpose binding site residues only with a classical Kabsch algorithm you might alter significantly the positions of all binding site residues that appear to be stable (beta sheet & helix 44-58 for instance). Also clustering such superposed structures on differences on amino acid positions will yield sub-optimal results.\nFurthermore, one should decouple the superimpositioning two structures from the similarity measurement of conformations once they are superimposed. With the classical Kabsch algorithm & the resulting RMSD, all of this is intertwined.\nKufareva and Abagyan (2011) already wrote about that topic and stated the properties of an ideal protein similarity measure as:\n\nAn ideal measure should allow both a single ‘summary’ number within a fixed range (e.g. 0% to 100%) and an underlying detailed vector or matrix representation. The single number must distinguish well between related (correct) and non-related (incorrect) structure pairs, i.e. its distributions on the two sets must overlap to a minimal possible degree. It has to be relevant, i.e. capture the nature of protein folding or protein interaction determinants rather than satisfy simple geometric criteria. It has to have the minimal number of parameters, which in turn need to be well justified and understandable. It has to be stable and robust against minor or fractional (affecting a small fraction of the model) experimental and modeling errors; such changes in the structures should not lead to major leaps in the calculated similarity measure values. It has to capture the similarities or differences between the structures at any given level of accuracy/resolution. Ideally, it should have an intuitive visual interpretation.\n\nKufareva and Abagyan (2011) however conclude that even distance weighted optimization & related cartesian space metrics are always prone to several issues. In the end they conclude that contact based metrics are more robust. So this is what I’ll be using here.\n\n\nContact based conformation comparison\nAt first I’m going to use some tools already existing in MDanalysis(Gowers et al. (2016),Michaud-Agrawal et al. (2011)), a popular python toolkit for MD trajectory analysis. It contains already prebuilt funtions to calculate the contact maps of a protein structure. But overall, you can achieve the same thing with any other toolkit & a lot of looping.\n\nimport MDAnalysis as mda\nimport numpy as np\nfrom scipy.spatial.distance import cdist\nfrom MDAnalysis.analysis import distances\nimport seaborn as sns\nimport gemmi\nimport matplotlib.pyplot as plt\n\nfilename=\"3t0z.pdb\"\nu = mda.Universe(filename)\n\nresidue_seqnums=[47,48,51,52,54,55,58,93,95,96,97,98,106,107,112,131,132,133,134,135,136,137,138,139,152,183,184,186]\nresidues = u.select_atoms('protein and name CA and resnum {}'.format(' '.join(map(str, residue_seqnums))))\n\ndistances3t0z = distances.distance_array(residues.positions, residues.positions)\n\nsns.heatmap(distances3t0z,yticklabels=residue_seqnums,xticklabels=residue_seqnums,cmap=\"Blues\",square=True)\nplt.show()\n\n\n\n\nFigure 3: Contact matrix of alpha carbons of the ATP binding site of structure 3t0z\n\n\n\n\nThe code above has two main limitations that come to my mind. The first one is that the residue numbering I’m using is the canonical uniprot sequence one, but I’m not assured the residue numbering is the same in all HSP90 structures I selected. The second one is that I’m only computing distances between alpha carbons. This implies that I’ll only be able to measure differences in backbone conformations and as such important conformational changes. I won’t be able to detect subtle side-chain conformational changes. One could use an all atom distance matrix, or compute the center of mass for each residue & compare that instead. The time being let’s stick to alpha carbons. Also, I dont need to check for missing atoms in the structures for now with this simplification.\n\n\nThings to keep in mind\n\nUniprot accession vs polymer entity group ID handling to be clarified with RCSB folks\nDon’t forget to check if all sidechains of the binding site are resolved in the selected structures\nTreat homo-multimers rationally in the data-set construction\nHandle canonical residue numbering properly in distanceMatrix code\nConsider also optional side-chain sensitive distance calculations\n\nNow let’s calculate the same distance matrix on another structure, for instance 4cwr.\n\n\nCode\nfilename=\"pdbs/4cwr_aligned.pdb\"\nu = mda.Universe(filename)\nresidues = u.select_atoms('protein and name CA and resnum {}'.format(' '.join(map(str, residue_seqnums))))\ndistances4cwr = distances.distance_array(residues.positions, residues.positions)\n\n\nfig, ax = plt.subplots(1,2)\nsns.heatmap(distances3t0z,yticklabels=residue_seqnums,xticklabels=residue_seqnums,cmap=\"Blues\",square=True,ax=ax[0])\n\nsns.heatmap(distances4cwr,yticklabels=residue_seqnums,xticklabels=residue_seqnums,cmap=\"Blues\",square=True,ax=ax[1])\nplt.show()\n\n\n\n\n\nFigure 4: Comparison of distinct binding site conformations (3t0z,4cwr) using a CA contact matrix\n\n\n\n\nVisual inspection won’t help a lot here. Let’s calculate the difference between the two matrices. I’ll call the resulting matrix a contact difference matrix from hereon. And check if we can spot the residues we observe to be moving significantly.\n\n\nCode\ndistancematrix=np.abs(distances3t0z-distances4cwr)\nsns.heatmap(distancematrix,yticklabels=residue_seqnums,xticklabels=residue_seqnums,cmap=\"Blues\",square=True)\nplt.show()\n\n\n\n\n\nFigure 5: Comparison of distinct binding site conformations (3t0z,4cwr) using a contact difference matrix (colorscale in Angstroms)\n\n\n\n\nThat looks already a lot nicer. Here we can see that residues 106, 107 and 112 clearly move a lot when comparing both structures. Also the section 131-139 shows signficant motion when compared to residues 41-98. To understand better what is going on, let’s show both structures overlayed.\n\n\nCode\n// Create drawing area\ndivNGL3 = html`&lt;div style=\"width:800px;height:600px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\nFigure 6: Comparison of distinct binding site conformations (3t0z,4cwr) on specific residues\n\n\n\n\n\nCode\nstage3 = new NGL.Stage(divNGL3, { backgroundColor: \"black\",cameraType: \"orthographic\"});\npdbString31 = await FileAttachment(\"3t0z.pdb\").blob();\nstructure31 = await stage3.loadFile(pdbString31, {ext: \"pdb\", asTrajectory: false})\nstructure31.addRepresentation(\"trace\",{ \"sele\": \"protein\", \"color\": \"#325E73\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nstructure31.addRepresentation(\"ball+stick\",{ \"sele\": \"(106-107 or 112 or 131-139) and .CA\", \"color\": \"#325E73\"});\n\n\n\n\n\n\n\n\n\nCode\nstructure31.addRepresentation(\"label\", {\"sele\": \"(106-107 or 112 or 131-139) and .CA\", \"labelType\":\"resno\", \"color\": \"#7F9DAC\"});\n\n\n\n\n\n\n\n\n\nCode\npdbString32 = await FileAttachment(\"pdbs/4cwr_aligned.pdb\").blob();\nstructure32 = await stage3.loadFile(pdbString32, {ext: \"pdb\", asTrajectory: false});\nstructure32.addRepresentation(\"trace\",{ \"sele\": \"protein\", \"color\": \"#B69849\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nstructure32.addRepresentation(\"ball+stick\",{ \"sele\": \"(106-107 or 112 or 131-139) and .CA and :A\", \"color\": \"#B69849\"});\n\n\n\n\n\n\n\n\n\nCode\nstructure32.addRepresentation(\"label\", {\"sele\": \"(106-107 or 112 or 131-139) and .CA and :A\", \"labelType\":\"resno\", \"color\": \"#FFEBB8\"});\n\n\n\n\n\n\n\n\n\nCode\nstructure31.autoView(\"(106-107 or 112 or 131-139) and .CA and :A\");\n\n\n\n\n\n\n\n\n\nThe contact difference matrix nicely catches the small shift of the 131-139 region. There is a subtle backbone movement ongoing. Regarding residues 106, 107 and 112 they are involved in a helical region that unfolds in one of the two structures. Observing that none of the residues between 107 and 112 are in the distance matrix is due to the fact that we did our initial residue selection based on a single reference structure to define the binding site. In the structure 4cwr this segment however structures itself into a helix. By doing so for instance I11O is now exposed to the binding site lumen. As a result, do we need to adjust the binding site residue selection? In theory, if we want to properly track & understand structural changes in the dataset at hand, yes. In this particular example the difference is captured by the surrounding residues 106-107 and 112. So let’s put it on my list of things to keep in mind which is getting longer 😱.\n\n\nThings to keep in mind\n\nUniprot accession vs polymer entity group ID handling to be clarified with RCSB folks\nDon’t forget to check if all sidechains of the binding site are resolved in the selected structures\nTreat homo-multimers rationally in the data-set construction\nHandle canonical residue numbering properly in distanceMatrix code\nConsider also optional side-chain sensitive distance calculations\nWhat to do with large motions implicating new residues in binding sites?\n\nI’m interested to check on how such a contact difference matrix looks like on very similar structures, so I prepared an example between 4cwr & 1uyd, which are very similar (as a lot of the HSP90 alpha human structures actually).\n\n\nCode\nfilename=\"pdbs/1uyd.pdb\"\nu = mda.Universe(filename)\nresidues = u.select_atoms('protein and name CA and resnum {}'.format(' '.join(map(str, residue_seqnums))))\ndistances1uyd = distances.distance_array(residues.positions, residues.positions)\n\ndistancematrix=np.abs(distances4cwr-distances1uyd)\nsns.heatmap(distancematrix,yticklabels=residue_seqnums,xticklabels=residue_seqnums,cmap=\"Blues\",square=True,vmax=3.7)\nplt.show()\n\n\n\n\n\nFigure 7: Comparison of distinct binding site conformations (4cwe,1uyd) using a CA distance matrix\n\n\n\n\nI used the same color scale as on Figure 5 on purpose, just to have something slightly comparable (visually). However, if you look in more detail, you’ll notice that there are differences (around 0.7A max) between parts of the binding site. But obviously, they are less drastic conformational changes than what we observed before with the comparison of 3t0z & 4cwr.\nLast example that I wanted to check is the impact on such a matrix of the closed conformation of the binding site. This is structure 7l7j which was already displayed in red in Figure 2 before.\n\n\nCode\nfilename=\"pdbs/7l7j_aligned.pdb\"\nu = mda.Universe(filename)\nresidues = u.select_atoms('protein and chainID A and name CA and resnum {}'.format(' '.join(map(str, residue_seqnums))))\ndistances7l7j = distances.distance_array(residues.positions, residues.positions)\n\ndistancematrix=np.abs(distances4cwr-distances7l7j)\nsns.heatmap(distancematrix,yticklabels=residue_seqnums,xticklabels=residue_seqnums,cmap=\"Blues\",square=True)\nplt.show()\n\n\n\n\n\nFigure 8: Comparison of distinct binding site conformations (4cwe,7l7j) using a CA distance matrix\n\n\n\n\nIn the figure above I didn’t set a maximum to the color scale. This way you can see the full extent of movements observed especially around residue 112 - 133. Again, let’s repeat the exercise and plot the residues that appear to be significantly moving here: 106,112, 131-133\n\n\nCode\n// Create drawing area\ndivNGL4 = html`&lt;div style=\"width:800px;height:600px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\nFigure 9: Comparison of distinct binding site conformations (4cwr, 7l7j) on specific residues\n\n\n\n\n\nCode\nstage4 = new NGL.Stage(divNGL4, { backgroundColor: \"black\",cameraType: \"orthographic\"});\n\npdbString42 = await FileAttachment(\"pdbs/4cwr_aligned.pdb\").blob();\nstructure42 = await stage4.loadFile(pdbString42, {ext: \"pdb\", asTrajectory: false});\nstructure42.addRepresentation(\"trace\",{ \"sele\": \"protein\", \"color\": \"#B69849\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nstructure42.addRepresentation(\"ball+stick\",{ \"sele\": \"(106 or 112 or 131-133) and .CA\", \"color\": \"#B69849\"});\n\n\n\n\n\n\n\n\n\nCode\nstructure42.addRepresentation(\"label\", {\"sele\": \"(106 or 112 or 131-133) and .CA\", \"labelType\":\"resno\", \"color\": \"#FFEBB8\"});\n\n\n\n\n\n\n\n\n\nCode\npdbString41 = await FileAttachment(\"pdbs/7l7j_aligned.pdb\").blob();\nstructure41 = await stage4.loadFile(pdbString41, {ext: \"pdb\", asTrajectory: false});\nstructure41.addRepresentation(\"trace\",{ \"sele\": \"protein\", \"color\": \"#B66049\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nstructure41.addRepresentation(\"ball+stick\",{ \"sele\": \"(106 or 112 or 131-133) and .CA and :A\", \"color\": \"#B66049\"});\n\n\n\n\n\n\n\n\n\nCode\nstructure41.addRepresentation(\"label\", {\"sele\": \"(106 or 112 or 131-133) and .CA and :A\", \"labelType\":\"resno\", \"color\": \"#FFC7B8\"});\n\n\n\n\n\n\n\n\n\nCode\nstructure41.autoView(\"(106 or 112 or 131-133) and .CA and :A\");\n\n\n\n\n\n\n\n\n\nThe conformational changes are very important (as expected). Furthermore the selection of residues one could extract from the distance matrix is relevant also versus what can be observed above.\n\n\nClustering contact (distance) matrices\nNow, in order to know whether one structure is close to another we can use these contact matrices calculated before & compare these one to another. The comparison between 4cwr & 3t0z results in a contact difference matrix (Figure 5). The comparison of 4cwr and 1uyd results in another contact difference matrix (Figure 7). Let’s try to compute an average of all the values of each contact difference matrix and see what we get.\n\n\nCode\ndistanceMatrixList=[distances4cwr,distances3t0z,distances1uyd,distances7l7j]\nlabels=[\"4cwr\",\"3t0z\",\"1uyd\",\"7l7j\"]\nnMatrices=len(distanceMatrixList)\n\nresult=np.zeros((nMatrices,nMatrices))\nfor i in range(nMatrices):\n  for j in range(nMatrices):\n    if i==j:\n      result[i][j]=0.0\n    elif i&lt;j:\n      result[i][j]=np.mean(np.abs(distanceMatrixList[i]-distanceMatrixList[j]))\n      result[j][i]=result[i][j]\n\nsns.heatmap(result,yticklabels=labels,xticklabels=labels,cmap=\"Blues\",square=True)\nplt.show()\n\n\n\n\n\nFigure 10: Comparison of distinct binding sites for clustering\n\n\n\n\nThat looks already rather promising. We expect to see 4cwr & 1uyd to be close to each other, and 3t0z to be closer to 4cwr than to 7l7j. However, 7l7j is not close to any of the other structures and likely closest to 3t0z (as both have the helical unfolding around residues 107-112). Now we have a distance matrix that we can feed into a clustering algorithm. I’m not a big fan of k-means as I don’t know how many clusters I expect beforehand. In the end I want the dataset preparation steps I’m going through here to be as automated as possible. So I’ll use a hierarchical clustering algorithm instead.\n\n\nCode\nimport scipy\nimport scipy.spatial.distance as ssd\ndistArray = ssd.squareform(result)\n\nclusters=scipy.cluster.hierarchy.linkage(distArray, method='single', metric='euclidean')\nscipy.cluster.hierarchy.dendrogram(clusters,labels=labels,leaf_rotation=90)\nplt.show()\n\n\n\n\n\nFigure 11: Dendrogram from single linkage clustering of previous distance matrix\n\n\n\n\nNow that I have this, I can cut the result at any given distance and get the clusters. Obviously this example is a bit too tiny to draw any interesting insights. So in order to get ready for our first full dataset, we need to repeat the whole process for all the structures we’ve identified earlier. In order to do so I first need to properly address two items on my todo list that I tracked as side notes in the previous sections (I’ll put it here again as reference).\n\n\nThings to keep in mind\n\nUniprot accession vs polymer entity group ID handling to be clarified with RCSB folks\nDon’t forget to check if all sidechains of the binding site are resolved in the selected structures\nTreat homo-multimers rationally in the data-set construction\nHandle canonical residue numbering properly in distanceMatrix code\nConsider also optional side-chain sensitive distance calculations\nWhat to do with large motions implicating new residues in binding sites?\n\n\nI need to verify that all structures have a canonical uniprot sequence residue numbering. If not I need to map the residue numbers to the canonical uniprot sequence.\nI need to know which chain I use beforehand (7l7j contains two different proteins for instance - so just sticking without a selection is not an option)\n\n\n\n\nAutomating things\nThe first issue previously mentioned was briefly checked against 3decision. In the case of the selected HSP90 structures and this binding site, it’s not an issue to perform residue selections using the residue numbers I used here. You could extract that kind of info using a graphQL query from the RCSB as well, but I’ll pass here and will come back to that if / when needed. In order to address the second of the previously mentioned issues I am going to adjust a bit the graphQL query I used earlier and track for each structure which chain corresponds to HSP90 containing the binding site we are interested in here.\n\n\nCode\n# here we can reuse the already retrieved data from the GraphQL query that we did earlier against the RCSB, because it already contains the information we need.\n\n# a bit of rewrite of the function we had before (still very ugly, feel free to make it pretty ;) \n\ndef extractSequenceRegionsAndChains(data):\n  result={}\n  \n  for entry in data:  \n    result[entry[\"rcsb_id\"]]=[]\n    for entity in entry[\"polymer_entities\"]:\n      # print(entity[\"rcsb_polymer_entity_container_identifiers\"])\n      if entity[\"entity_poly\"][\"rcsb_mutation_count\"]==0:\n        chain_ids=entity[\"rcsb_polymer_entity_container_identifiers\"][\"auth_asym_ids\"]\n        for idx,identifier in enumerate(entity[\"rcsb_polymer_entity_container_identifiers\"][\"reference_sequence_identifiers\"]):\n          if identifier[\"database_name\"]==\"UniProt\" and identifier[\"database_accession\"]==\"P07900\":\n            if entity[\"rcsb_polymer_entity_align\"][idx][\"reference_database_name\"]==\"UniProt\":\n              for region in entity[\"rcsb_polymer_entity_align\"][idx][\"aligned_regions\"]:\n                result[entry[\"rcsb_id\"]].append((region[\"ref_beg_seq_id\"],region[\"ref_beg_seq_id\"]+region[\"length\"]))\n                result[entry[\"rcsb_id\"]].append(chain_ids)\n  return result\n\n# residuelist=[47,48,51,52,54,55,58,93,95,96,97,98,106,107,112,131,132,133,134,135,136,137,138,139,152,183,184,186]\n\n\nresolved_regions=extractSequenceRegionsAndChains(dataRCSBGQL)\n\nselectedPdbCodesAndChains=[]\nfor pdbCode in resolved_regions:\n  mapping = resolved_regions[pdbCode]\n  if(len(mapping)&gt;0 and all(i&gt;=mapping[0][0] and i&lt;=mapping[0][1] for i in residuelist)):\n    selectedPdbCodesAndChains.append({\"pdbCode\":pdbCode,\"chain\":mapping[1][0]})\n\nprint(selectedPdbCodesAndChains)\n# print(str(len(selectedPdbCodes)) + \" structures identified\")\n\n\n[{'pdbCode': '1BYQ', 'chain': 'A'}, {'pdbCode': '1OSF', 'chain': 'A'}, {'pdbCode': '1UY6', 'chain': 'A'}, {'pdbCode': '1UY7', 'chain': 'A'}, {'pdbCode': '1UY8', 'chain': 'A'}, {'pdbCode': '1UY9', 'chain': 'A'}, {'pdbCode': '1UYC', 'chain': 'A'}, {'pdbCode': '1UYD', 'chain': 'A'}, {'pdbCode': '1UYE', 'chain': 'A'}, {'pdbCode': '1UYF', 'chain': 'A'}, {'pdbCode': '1UYG', 'chain': 'A'}, {'pdbCode': '1UYH', 'chain': 'A'}, {'pdbCode': '1UYI', 'chain': 'A'}, {'pdbCode': '1UYK', 'chain': 'A'}, {'pdbCode': '1UYL', 'chain': 'A'}, {'pdbCode': '1YC1', 'chain': 'A'}, {'pdbCode': '1YC3', 'chain': 'A'}, {'pdbCode': '1YC4', 'chain': 'A'}, {'pdbCode': '1YER', 'chain': 'A'}, {'pdbCode': '1YES', 'chain': 'A'}, {'pdbCode': '1YET', 'chain': 'A'}, {'pdbCode': '2BSM', 'chain': 'A'}, {'pdbCode': '2BT0', 'chain': 'A'}, {'pdbCode': '2BYH', 'chain': 'A'}, {'pdbCode': '2BYI', 'chain': 'A'}, {'pdbCode': '2BZ5', 'chain': 'A'}, {'pdbCode': '2CCS', 'chain': 'A'}, {'pdbCode': '2CCT', 'chain': 'A'}, {'pdbCode': '2CCU', 'chain': 'A'}, {'pdbCode': '2FWY', 'chain': 'A'}, {'pdbCode': '2FWZ', 'chain': 'A'}, {'pdbCode': '2H55', 'chain': 'A'}, {'pdbCode': '2JJC', 'chain': 'A'}, {'pdbCode': '2K5B', 'chain': 'A'}, {'pdbCode': '2QF6', 'chain': 'A'}, {'pdbCode': '2QFO', 'chain': 'A'}, {'pdbCode': '2QG0', 'chain': 'A'}, {'pdbCode': '2QG2', 'chain': 'A'}, {'pdbCode': '2UWD', 'chain': 'A'}, {'pdbCode': '2VCI', 'chain': 'A'}, {'pdbCode': '2VCJ', 'chain': 'A'}, {'pdbCode': '2WI1', 'chain': 'A'}, {'pdbCode': '2WI2', 'chain': 'A'}, {'pdbCode': '2WI3', 'chain': 'A'}, {'pdbCode': '2WI4', 'chain': 'A'}, {'pdbCode': '2WI5', 'chain': 'A'}, {'pdbCode': '2WI6', 'chain': 'A'}, {'pdbCode': '2WI7', 'chain': 'A'}, {'pdbCode': '2XAB', 'chain': 'A'}, {'pdbCode': '2XDK', 'chain': 'A'}, {'pdbCode': '2XDL', 'chain': 'A'}, {'pdbCode': '2XDS', 'chain': 'A'}, {'pdbCode': '2XDU', 'chain': 'A'}, {'pdbCode': '2XDX', 'chain': 'A'}, {'pdbCode': '2XHR', 'chain': 'A'}, {'pdbCode': '2XHT', 'chain': 'A'}, {'pdbCode': '2XHX', 'chain': 'A'}, {'pdbCode': '2XJG', 'chain': 'A'}, {'pdbCode': '2XJJ', 'chain': 'A'}, {'pdbCode': '2XJX', 'chain': 'A'}, {'pdbCode': '2XK2', 'chain': 'A'}, {'pdbCode': '2YE2', 'chain': 'A'}, {'pdbCode': '2YE3', 'chain': 'A'}, {'pdbCode': '2YE4', 'chain': 'A'}, {'pdbCode': '2YE5', 'chain': 'A'}, {'pdbCode': '2YE6', 'chain': 'A'}, {'pdbCode': '2YE7', 'chain': 'A'}, {'pdbCode': '2YE8', 'chain': 'A'}, {'pdbCode': '2YE9', 'chain': 'A'}, {'pdbCode': '2YEA', 'chain': 'A'}, {'pdbCode': '2YEB', 'chain': 'A'}, {'pdbCode': '2YEC', 'chain': 'A'}, {'pdbCode': '2YED', 'chain': 'A'}, {'pdbCode': '2YEE', 'chain': 'A'}, {'pdbCode': '2YEF', 'chain': 'A'}, {'pdbCode': '2YEG', 'chain': 'A'}, {'pdbCode': '2YEH', 'chain': 'A'}, {'pdbCode': '2YEI', 'chain': 'A'}, {'pdbCode': '2YEJ', 'chain': 'A'}, {'pdbCode': '2YI0', 'chain': 'A'}, {'pdbCode': '2YI5', 'chain': 'A'}, {'pdbCode': '2YI6', 'chain': 'A'}, {'pdbCode': '2YI7', 'chain': 'A'}, {'pdbCode': '2YJW', 'chain': 'A'}, {'pdbCode': '2YJX', 'chain': 'A'}, {'pdbCode': '2YK2', 'chain': 'A'}, {'pdbCode': '2YK9', 'chain': 'A'}, {'pdbCode': '2YKB', 'chain': 'A'}, {'pdbCode': '2YKC', 'chain': 'A'}, {'pdbCode': '2YKE', 'chain': 'A'}, {'pdbCode': '2YKI', 'chain': 'A'}, {'pdbCode': '2YKJ', 'chain': 'A'}, {'pdbCode': '3B24', 'chain': 'A'}, {'pdbCode': '3B25', 'chain': 'A'}, {'pdbCode': '3B26', 'chain': 'A'}, {'pdbCode': '3B27', 'chain': 'A'}, {'pdbCode': '3B28', 'chain': 'A'}, {'pdbCode': '3BM9', 'chain': 'A'}, {'pdbCode': '3BMY', 'chain': 'A'}, {'pdbCode': '3D0B', 'chain': 'A'}, {'pdbCode': '3EKO', 'chain': 'A'}, {'pdbCode': '3EKR', 'chain': 'A'}, {'pdbCode': '3FT5', 'chain': 'A'}, {'pdbCode': '3FT8', 'chain': 'A'}, {'pdbCode': '3HEK', 'chain': 'A'}, {'pdbCode': '3HHU', 'chain': 'A'}, {'pdbCode': '3HYY', 'chain': 'A'}, {'pdbCode': '3HYZ', 'chain': 'A'}, {'pdbCode': '3HZ1', 'chain': 'A'}, {'pdbCode': '3HZ5', 'chain': 'A'}, {'pdbCode': '3INW', 'chain': 'A'}, {'pdbCode': '3INX', 'chain': 'A'}, {'pdbCode': '3K97', 'chain': 'A'}, {'pdbCode': '3K98', 'chain': 'A'}, {'pdbCode': '3K99', 'chain': 'A'}, {'pdbCode': '3MNR', 'chain': 'P'}, {'pdbCode': '3O0I', 'chain': 'A'}, {'pdbCode': '3OW6', 'chain': 'A'}, {'pdbCode': '3OWB', 'chain': 'A'}, {'pdbCode': '3OWD', 'chain': 'A'}, {'pdbCode': '3QDD', 'chain': 'A'}, {'pdbCode': '3QTF', 'chain': 'A'}, {'pdbCode': '3R4M', 'chain': 'A'}, {'pdbCode': '3R4N', 'chain': 'A'}, {'pdbCode': '3R4O', 'chain': 'A'}, {'pdbCode': '3R4P', 'chain': 'A'}, {'pdbCode': '3R91', 'chain': 'A'}, {'pdbCode': '3R92', 'chain': 'A'}, {'pdbCode': '3RKZ', 'chain': 'A'}, {'pdbCode': '3RLP', 'chain': 'A'}, {'pdbCode': '3RLQ', 'chain': 'A'}, {'pdbCode': '3RLR', 'chain': 'A'}, {'pdbCode': '3T0H', 'chain': 'A'}, {'pdbCode': '3T0Z', 'chain': 'A'}, {'pdbCode': '3T10', 'chain': 'A'}, {'pdbCode': '3T1K', 'chain': 'A'}, {'pdbCode': '3T2S', 'chain': 'A'}, {'pdbCode': '3TUH', 'chain': 'A'}, {'pdbCode': '3VHA', 'chain': 'A'}, {'pdbCode': '3VHC', 'chain': 'A'}, {'pdbCode': '3VHD', 'chain': 'A'}, {'pdbCode': '3WHA', 'chain': 'A'}, {'pdbCode': '3WQ9', 'chain': 'A'}, {'pdbCode': '4AWO', 'chain': 'A'}, {'pdbCode': '4AWP', 'chain': 'A'}, {'pdbCode': '4AWQ', 'chain': 'A'}, {'pdbCode': '4B7P', 'chain': 'A'}, {'pdbCode': '4BQG', 'chain': 'A'}, {'pdbCode': '4BQJ', 'chain': 'A'}, {'pdbCode': '4CWF', 'chain': 'A'}, {'pdbCode': '4CWN', 'chain': 'A'}, {'pdbCode': '4CWO', 'chain': 'A'}, {'pdbCode': '4CWP', 'chain': 'A'}, {'pdbCode': '4CWQ', 'chain': 'A'}, {'pdbCode': '4CWR', 'chain': 'A'}, {'pdbCode': '4CWS', 'chain': 'A'}, {'pdbCode': '4CWT', 'chain': 'A'}, {'pdbCode': '4EEH', 'chain': 'A'}, {'pdbCode': '4EFT', 'chain': 'A'}, {'pdbCode': '4EFU', 'chain': 'A'}, {'pdbCode': '4EGH', 'chain': 'A'}, {'pdbCode': '4EGI', 'chain': 'A'}, {'pdbCode': '4EGK', 'chain': 'A'}, {'pdbCode': '4FCP', 'chain': 'A'}, {'pdbCode': '4FCQ', 'chain': 'A'}, {'pdbCode': '4FCR', 'chain': 'A'}, {'pdbCode': '4HY6', 'chain': 'A'}, {'pdbCode': '4JQL', 'chain': 'A'}, {'pdbCode': '4L8Z', 'chain': 'A'}, {'pdbCode': '4L90', 'chain': 'A'}, {'pdbCode': '4L91', 'chain': 'A'}, {'pdbCode': '4L93', 'chain': 'A'}, {'pdbCode': '4L94', 'chain': 'A'}, {'pdbCode': '4LWE', 'chain': 'A'}, {'pdbCode': '4LWF', 'chain': 'A'}, {'pdbCode': '4LWG', 'chain': 'A'}, {'pdbCode': '4LWH', 'chain': 'A'}, {'pdbCode': '4LWI', 'chain': 'A'}, {'pdbCode': '4NH7', 'chain': 'A'}, {'pdbCode': '4NH8', 'chain': 'A'}, {'pdbCode': '4O04', 'chain': 'A'}, {'pdbCode': '4O05', 'chain': 'A'}, {'pdbCode': '4O07', 'chain': 'A'}, {'pdbCode': '4O09', 'chain': 'A'}, {'pdbCode': '4O0B', 'chain': 'A'}, {'pdbCode': '4R3M', 'chain': 'A'}, {'pdbCode': '4U93', 'chain': 'A'}, {'pdbCode': '4W7T', 'chain': 'A'}, {'pdbCode': '4XIP', 'chain': 'A'}, {'pdbCode': '4XIQ', 'chain': 'A'}, {'pdbCode': '4XIR', 'chain': 'A'}, {'pdbCode': '4XIT', 'chain': 'A'}, {'pdbCode': '4YKQ', 'chain': 'A'}, {'pdbCode': '4YKR', 'chain': 'A'}, {'pdbCode': '4YKT', 'chain': 'A'}, {'pdbCode': '4YKU', 'chain': 'A'}, {'pdbCode': '4YKW', 'chain': 'A'}, {'pdbCode': '4YKX', 'chain': 'A'}, {'pdbCode': '4YKY', 'chain': 'A'}, {'pdbCode': '4YKZ', 'chain': 'A'}, {'pdbCode': '5CF0', 'chain': 'A'}, {'pdbCode': '5FNC', 'chain': 'A'}, {'pdbCode': '5FND', 'chain': 'A'}, {'pdbCode': '5FNF', 'chain': 'A'}, {'pdbCode': '5GGZ', 'chain': 'A'}, {'pdbCode': '5J20', 'chain': 'A'}, {'pdbCode': '5J27', 'chain': 'A'}, {'pdbCode': '5J2V', 'chain': 'A'}, {'pdbCode': '5J2X', 'chain': 'A'}, {'pdbCode': '5J64', 'chain': 'A'}, {'pdbCode': '5J6L', 'chain': 'A'}, {'pdbCode': '5J6M', 'chain': 'A'}, {'pdbCode': '5J6N', 'chain': 'A'}, {'pdbCode': '5J82', 'chain': 'A'}, {'pdbCode': '5J86', 'chain': 'A'}, {'pdbCode': '5J8M', 'chain': 'A'}, {'pdbCode': '5J8U', 'chain': 'A'}, {'pdbCode': '5J9X', 'chain': 'A'}, {'pdbCode': '5LNY', 'chain': 'A'}, {'pdbCode': '5LNZ', 'chain': 'A'}, {'pdbCode': '5LO0', 'chain': 'A'}, {'pdbCode': '5LO1', 'chain': 'A'}, {'pdbCode': '5LO5', 'chain': 'A'}, {'pdbCode': '5LO6', 'chain': 'A'}, {'pdbCode': '5LQ9', 'chain': 'A'}, {'pdbCode': '5LR1', 'chain': 'A'}, {'pdbCode': '5LR7', 'chain': 'A'}, {'pdbCode': '5LRL', 'chain': 'A'}, {'pdbCode': '5LRZ', 'chain': 'A'}, {'pdbCode': '5LS1', 'chain': 'A'}, {'pdbCode': '5M4E', 'chain': 'A'}, {'pdbCode': '5M4H', 'chain': 'A'}, {'pdbCode': '5NYH', 'chain': 'A'}, {'pdbCode': '5NYI', 'chain': 'A'}, {'pdbCode': '5OCI', 'chain': 'A'}, {'pdbCode': '5OD7', 'chain': 'A'}, {'pdbCode': '5ODX', 'chain': 'A'}, {'pdbCode': '5T21', 'chain': 'A'}, {'pdbCode': '5VYY', 'chain': 'A'}, {'pdbCode': '5XQD', 'chain': 'A'}, {'pdbCode': '5XQE', 'chain': 'A'}, {'pdbCode': '5XR5', 'chain': 'A'}, {'pdbCode': '5XR9', 'chain': 'A'}, {'pdbCode': '5XRB', 'chain': 'A'}, {'pdbCode': '5XRD', 'chain': 'A'}, {'pdbCode': '5XRE', 'chain': 'A'}, {'pdbCode': '5ZR3', 'chain': 'A'}, {'pdbCode': '6B99', 'chain': 'A'}, {'pdbCode': '6B9A', 'chain': 'A'}, {'pdbCode': '6CEO', 'chain': 'A'}, {'pdbCode': '6CYG', 'chain': 'A'}, {'pdbCode': '6CYH', 'chain': 'A'}, {'pdbCode': '6EI5', 'chain': 'A'}, {'pdbCode': '6EL5', 'chain': 'A'}, {'pdbCode': '6ELN', 'chain': 'A'}, {'pdbCode': '6ELO', 'chain': 'A'}, {'pdbCode': '6ELP', 'chain': 'A'}, {'pdbCode': '6EY8', 'chain': 'A'}, {'pdbCode': '6EY9', 'chain': 'A'}, {'pdbCode': '6EYA', 'chain': 'A'}, {'pdbCode': '6EYB', 'chain': 'A'}, {'pdbCode': '6F1N', 'chain': 'A'}, {'pdbCode': '6FCJ', 'chain': 'A'}, {'pdbCode': '6GPR', 'chain': 'A'}, {'pdbCode': '6GPT', 'chain': 'A'}, {'pdbCode': '6GPW', 'chain': 'A'}, {'pdbCode': '6GPY', 'chain': 'A'}, {'pdbCode': '6GQ6', 'chain': 'A'}, {'pdbCode': '6GQR', 'chain': 'A'}, {'pdbCode': '6HHR', 'chain': 'A'}, {'pdbCode': '6LR9', 'chain': 'A'}, {'pdbCode': '6LSZ', 'chain': 'A'}, {'pdbCode': '6LT8', 'chain': 'A'}, {'pdbCode': '6LTI', 'chain': 'A'}, {'pdbCode': '6LTK', 'chain': 'A'}, {'pdbCode': '6N8X', 'chain': 'A'}, {'pdbCode': '6TN4', 'chain': 'AAA'}, {'pdbCode': '6TN5', 'chain': 'AAA'}, {'pdbCode': '6U99', 'chain': 'A'}, {'pdbCode': '6U9B', 'chain': 'A'}, {'pdbCode': '7DMC', 'chain': 'A'}, {'pdbCode': '7KRJ', 'chain': 'A'}, {'pdbCode': '7KW7', 'chain': 'A'}, {'pdbCode': '7L7I', 'chain': 'A'}, {'pdbCode': '7L7J', 'chain': 'A'}, {'pdbCode': '7LSZ', 'chain': 'A'}, {'pdbCode': '7LT0', 'chain': 'A'}, {'pdbCode': '7S8Y', 'chain': 'A'}, {'pdbCode': '7S8Z', 'chain': 'A'}, {'pdbCode': '7S90', 'chain': 'A'}, {'pdbCode': '7S95', 'chain': 'A'}, {'pdbCode': '7S98', 'chain': 'A'}, {'pdbCode': '7S99', 'chain': 'A'}, {'pdbCode': '7S9F', 'chain': 'A'}, {'pdbCode': '7S9G', 'chain': 'A'}, {'pdbCode': '7S9H', 'chain': 'A'}, {'pdbCode': '7S9I', 'chain': 'A'}, {'pdbCode': '7UR3', 'chain': 'A'}, {'pdbCode': '8AGI', 'chain': 'A'}]\n\n\nNow we have the list of pdb codes & the chain we need to use here. Let’s wrap up the rest of the whole process to produce a larger distance matrix & clustering result. In the list of pdb codes above, several structures are NOT anymore available in the PDB format. So I have to adapt the previous code to work with mmCIF files instead. And lucky as I am, MDanalysis doesn’t seem to support them very well, nor mmtf which apparently doesn’t read in chain information from mmCIF files. So I’ll have to rewrite all of that using a different toolkit closer to crystallographers, i.e. gemmi.\n\nfrom gemmi import cif\nimport urllib\n\npdbCode=\"3t0z\"\nchainCode=\"A\"\ncontent= urllib.request.urlopen(\"https://files.rcsb.org/view/\"+pdbCode+\".cif\").read()\n\nblock=cif.read_string(content)[0]\nstructure=gemmi.make_structure_from_block(block)\n\npositions=[]\nfor model in structure:\n  for chain in model:\n    if chain.name == chainCode:\n      for residue in chain:\n        if residue.seqid.num in residuelist:\n          for atom in residue:\n            if atom.name==\"CA\":\n              positions.append(atom.pos.tolist())\n\nif(len(positions)!=len(residuelist)):\n  print(\"Not all positions found\")\n  print(\"stopping here\")\n\npositions_np=np.array(positions)\ndistances3t0zgemmi = cdist(positions_np, positions_np, 'euclidean')\nif(np.all(distances3t0z-distances3t0zgemmi&lt;0.0001)):\n  print(\"distances match with previous analysis\")\nelse:\n  print(\"distances don't match with previous analysis\")\n\ndistances match with previous analysis\n\n\n\n\nThings to keep in mind\n\nUniprot accession vs polymer entity group ID handling to be clarified with RCSB folks\nDon’t forget to check if all sidechains of the binding site are resolved in the selected structures\nTreat homo-multimers rationally in the data-set construction\nHandle canonical residue numbering properly in distanceMatrix code\nConsider also optional side-chain sensitive distance calculations\nWhat to do with large motions implicating new residues in binding sites?\nDecide how to handle NMR conformations in the dataset\n\nIn the code snippet above I’m checking if the results we obtained with the horrible quadruple loop match the results we got earlier with MDAnalysis on the same structure. This appears to be the case here.\nNow let’s put the whole thing into a function, loop over all our structures & I guess adjust what needs adjustments (as for sure I’ll have something that will fail 😫). By the time of the writing 4 structures were found to have 1 residue implicated in the binding site to be not resolved. They’ll be discarded from further analyses.\n\n\nCode\ndef getContactMatrix(pdbCode, chainCode, residueSelection, debug=False):\n  content= urllib.request.urlopen(\"https://files.rcsb.org/view/\"+pdbCode+\".cif\").read()\n\n  block=cif.read_string(content)[0]\n  structure=gemmi.make_structure_from_block(block)\n\n  positions=[]\n  for model in structure:\n    if model.name==\"1\":\n      for chain in model:\n        if chain.name == chainCode:\n          for residue in chain:\n            if residue.seqid.num in residueSelection:\n              if debug: print(residue.seqid.num)\n              for atom in residue:\n                if atom.name==\"CA\":\n                  if debug: print(\"ok\")\n                  positions.append(atom.pos.tolist())\n                  break #we need that for multiple occurences\n\n  if(len(positions)!=len(residueSelection)):\n    print(\"Not all positions found for \"+pdbCode+\" discarding structure\")\n    return None\n\n  positions_np=np.array(positions)\n  return cdist(positions_np, positions_np, 'euclidean')\n\ndef clusterMatrices(matrixList):  \n  nMatrices=len(matrixList)\n  result=np.zeros((nMatrices,nMatrices))\n  for i in range(nMatrices):\n    for j in range(nMatrices):\n      if i==j:\n        result[i][j]=0.0\n      elif i&lt;j:\n        result[i][j]=np.mean(np.abs(matrixList[i]-matrixList[j]))\n        result[j][i]=result[i][j]\n\n  \n  distArray = ssd.squareform(result)\n  clusters=scipy.cluster.hierarchy.linkage(result, method='single', metric='euclidean')\n  return(clusters)\n\n\ncontactMatrices=[getContactMatrix(structure[\"pdbCode\"],structure[\"chain\"],residuelist) for structure in selectedPdbCodesAndChains]\n\nnone_indices = [ic for ic, matrix in enumerate(contactMatrices) if matrix is None]\n\nlabels=[structure[\"pdbCode\"] for structure in selectedPdbCodesAndChains]\nchainCodes=[structure[\"chain\"] for structure in selectedPdbCodesAndChains]\nfilteredContactMatrices = [matrix for i, matrix in enumerate(contactMatrices) if i not in none_indices]\n\nfilteredLabels = [label for idx, label in enumerate(labels) if idx not in none_indices]\nfilteredChainCodes= [code for idx, code in enumerate(chainCodes) if idx not in none_indices]\n\nclusters=clusterMatrices(filteredContactMatrices)\n\nplt.figure(figsize=(10, 40))\n\nscipy.cluster.hierarchy.dendrogram(clusters,labels=filteredLabels,orientation='right',leaf_font_size=7,color_threshold=1.0)\nplt.show()\n\n\nNot all positions found for 2YI5 discarding structure\nNot all positions found for 3HYZ discarding structure\nNot all positions found for 4FCR discarding structure\nNot all positions found for 6EYA discarding structure\n\n\n/var/folders/51/p06ylvs507q40bm1kxbl65km0000gp/T/ipykernel_94855/1742338535.py:41: ClusterWarning:\n\nscipy.cluster: The symmetric non-negative hollow observation matrix looks suspiciously like an uncondensed distance matrix\n\n\n\n\n\n\nFigure 12: Result of hierarchical clustering of HSP90 ATP binding sites based on CA positions\n\n\n\n\nAlright, this is starting to look like something useable. The colors encode clusters, when cutting the dendrogram at a distance of 1.0 we get 3 very large clusters and several smaller ones & outliers.\nLet’s cherrypick 2 structures from each of the 3 large clusters and see if we can observe structural reasons underlinging these results:\n\n\nCode\n// Create drawing area\ndivNGL5 = html`&lt;div style=\"width:800px;height:600px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\nFigure 13: Comparison of 2 representative binding sites for each of the 3 large clusters identified. Orange, 2 structures from the orange cluster of Figure 12; red, 2 structures from the red cluster of Figure 12; blue, 2 structures from the brown cluster of Figure 12.\n\n\n\n\n\nCode\nstage5 = new NGL.Stage(divNGL5, { backgroundColor: \"black\",cameraType: \"orthographic\"});\n{\n  let files=[await FileAttachment(\"pdbs/4yku_aligned.pdb\").blob(),\n    await FileAttachment(\"pdbs/2yi6_aligned.pdb\").blob(),\n    await FileAttachment(\"pdbs/1yc4_aligned.pdb\").blob(),\n    await FileAttachment(\"pdbs/2xjg_aligned.pdb\").blob(),\n    await FileAttachment(\"pdbs/4o05_aligned.pdb\").blob(),\n    await FileAttachment(\"pdbs/2xdu_aligned.pdb\").blob()]\n  let colors=[\"#EF740E\",\"#EF740E\",\"#B7040D\",\"#B7040D\",\"#48ABAB\",\"#48ABAB\"]\n  let structures=[]\n\n  for (let [index,file] of files.entries()){\n    let structure = await stage5.loadFile(file, {ext: \"pdb\", asTrajectory: false});\n    structure.addRepresentation(\"ribbon\",{ \"radius\":0.1,\"sele\": \"protein\", \"color\": colors[index]});\n    structures.push(structure)\n  };\n  structures[0].autoView(\"(106-107 or 112 or 131-139) and .CA\");\n}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nIn the 3D View we can nicely see that we clustered the different conformations that occur for the majority of HSP90 alpha human structures in the PDB.\n\n\nCode\nfrom scipy.cluster.hierarchy import cut_tree\nh_cluster_id = cut_tree(clusters, height=1.0).reshape(-1, )\nsns.displot(h_cluster_id)\n\n\n\n\n\nFigure 14: Size distribution of identified clusters (cut at 1A distance).\n\n\n\n\nThe histogram above here shows nicely these 3 larger groups and the rest. Obviously we can play around with where do we cut the dendrogram to get more or less clusters. However, here I’ll rather stick to the current cut at 1A. We can revise that at a later stage if needed.\n\n\nWrap-up\nWell that got more complicated than it should have been, didn’t it? And unfortunately that was the easy part. Now we can extend the set gradually 🎉.\nBut let’s resume a bit what can be done with these results & scripts I provide here. We now have a set of structures that:\n\nhave been automagically selected from the PDB\nthis selection can be updated at any time (unless they change their API, which they will at some point)\nwe have performed local structure comparison to know which known ATP binding sites are similar to each other in terms of conformation\n\nThis set of structures, and especially the clusters, can be used to serve as known positives for binding site benchmarking. It can also be used to evaluate rank ordering for binding site comparison methods.\n\n\nCode\nfrom IPython.display import Markdown\nfrom tabulate import tabulate\nidentifiers=[\"{}:{}\".format(a_, b_) for a_, b_ in zip(filteredLabels, filteredChainCodes)]\ntable = list(zip(identifiers, h_cluster_id))\nMarkdown(tabulate(\n  table, \n  headers=[\"Structure\",\"Cluster ID\"], colalign=(\"center\",\"center\")\n))\n\n\n\nFinal List of structures and their corresponding cluster ID of the selected HSP90 alpha human ATP binding site containing structures \n\n\nStructure\nCluster ID\n\n\n\n\n1BYQ:A\n0\n\n\n1OSF:A\n0\n\n\n1UY6:A\n1\n\n\n1UY7:A\n1\n\n\n1UY8:A\n1\n\n\n1UY9:A\n1\n\n\n1UYC:A\n1\n\n\n1UYD:A\n1\n\n\n1UYE:A\n1\n\n\n1UYF:A\n1\n\n\n1UYG:A\n1\n\n\n1UYH:A\n1\n\n\n1UYI:A\n1\n\n\n1UYK:A\n1\n\n\n1UYL:A\n2\n\n\n1YC1:A\n0\n\n\n1YC3:A\n0\n\n\n1YC4:A\n0\n\n\n1YER:A\n2\n\n\n1YES:A\n0\n\n\n1YET:A\n0\n\n\n2BSM:A\n2\n\n\n2BT0:A\n2\n\n\n2BYH:A\n0\n\n\n2BYI:A\n0\n\n\n2BZ5:A\n0\n\n\n2CCS:A\n2\n\n\n2CCT:A\n2\n\n\n2CCU:A\n2\n\n\n2FWY:A\n1\n\n\n2FWZ:A\n1\n\n\n2H55:A\n1\n\n\n2JJC:A\n2\n\n\n2K5B:A\n3\n\n\n2QF6:A\n0\n\n\n2QFO:A\n0\n\n\n2QG0:A\n0\n\n\n2QG2:A\n1\n\n\n2UWD:A\n2\n\n\n2VCI:A\n2\n\n\n2VCJ:A\n2\n\n\n2WI1:A\n2\n\n\n2WI2:A\n2\n\n\n2WI3:A\n2\n\n\n2WI4:A\n1\n\n\n2WI5:A\n2\n\n\n2WI6:A\n0\n\n\n2WI7:A\n1\n\n\n2XAB:A\n2\n\n\n2XDK:A\n0\n\n\n2XDL:A\n2\n\n\n2XDS:A\n1\n\n\n2XDU:A\n1\n\n\n2XDX:A\n0\n\n\n2XHR:A\n0\n\n\n2XHT:A\n0\n\n\n2XHX:A\n0\n\n\n2XJG:A\n0\n\n\n2XJJ:A\n0\n\n\n2XJX:A\n0\n\n\n2XK2:A\n0\n\n\n2YE2:A\n2\n\n\n2YE3:A\n2\n\n\n2YE4:A\n2\n\n\n2YE5:A\n2\n\n\n2YE6:A\n2\n\n\n2YE7:A\n1\n\n\n2YE8:A\n1\n\n\n2YE9:A\n2\n\n\n2YEA:A\n2\n\n\n2YEB:A\n2\n\n\n2YEC:A\n2\n\n\n2YED:A\n2\n\n\n2YEE:A\n1\n\n\n2YEF:A\n0\n\n\n2YEG:A\n2\n\n\n2YEH:A\n2\n\n\n2YEI:A\n1\n\n\n2YEJ:A\n1\n\n\n2YI0:A\n2\n\n\n2YI6:A\n2\n\n\n2YI7:A\n2\n\n\n2YJW:A\n2\n\n\n2YJX:A\n1\n\n\n2YK2:A\n1\n\n\n2YK9:A\n1\n\n\n2YKB:A\n1\n\n\n2YKC:A\n1\n\n\n2YKE:A\n1\n\n\n2YKI:A\n1\n\n\n2YKJ:A\n1\n\n\n3B24:A\n2\n\n\n3B25:A\n1\n\n\n3B26:A\n0\n\n\n3B27:A\n0\n\n\n3B28:A\n0\n\n\n3BM9:A\n2\n\n\n3BMY:A\n0\n\n\n3D0B:A\n1\n\n\n3EKO:A\n0\n\n\n3EKR:A\n0\n\n\n3FT5:A\n2\n\n\n3FT8:A\n1\n\n\n3HEK:A\n0\n\n\n3HHU:A\n2\n\n\n3HYY:A\n1\n\n\n3HZ1:A\n1\n\n\n3HZ5:A\n1\n\n\n3INW:A\n1\n\n\n3INX:A\n1\n\n\n3K97:A\n0\n\n\n3K98:A\n0\n\n\n3K99:A\n4\n\n\n3MNR:P\n1\n\n\n3O0I:A\n1\n\n\n3OW6:A\n0\n\n\n3OWB:A\n2\n\n\n3OWD:A\n0\n\n\n3QDD:A\n1\n\n\n3QTF:A\n1\n\n\n3R4M:A\n0\n\n\n3R4N:A\n0\n\n\n3R4O:A\n0\n\n\n3R4P:A\n0\n\n\n3R91:A\n1\n\n\n3R92:A\n1\n\n\n3RKZ:A\n1\n\n\n3RLP:A\n0\n\n\n3RLQ:A\n0\n\n\n3RLR:A\n0\n\n\n3T0H:A\n2\n\n\n3T0Z:A\n0\n\n\n3T10:A\n0\n\n\n3T1K:A\n0\n\n\n3T2S:A\n0\n\n\n3TUH:A\n0\n\n\n3VHA:A\n0\n\n\n3VHC:A\n0\n\n\n3VHD:A\n0\n\n\n3WHA:A\n0\n\n\n3WQ9:A\n1\n\n\n4AWO:A\n5\n\n\n4AWP:A\n5\n\n\n4AWQ:A\n5\n\n\n4B7P:A\n0\n\n\n4BQG:A\n1\n\n\n4BQJ:A\n0\n\n\n4CWF:A\n1\n\n\n4CWN:A\n1\n\n\n4CWO:A\n1\n\n\n4CWP:A\n1\n\n\n4CWQ:A\n1\n\n\n4CWR:A\n1\n\n\n4CWS:A\n1\n\n\n4CWT:A\n1\n\n\n4EEH:A\n2\n\n\n4EFT:A\n1\n\n\n4EFU:A\n1\n\n\n4EGH:A\n2\n\n\n4EGI:A\n0\n\n\n4EGK:A\n0\n\n\n4FCP:A\n2\n\n\n4FCQ:A\n2\n\n\n4HY6:A\n1\n\n\n4JQL:A\n0\n\n\n4L8Z:A\n1\n\n\n4L90:A\n1\n\n\n4L91:A\n1\n\n\n4L93:A\n0\n\n\n4L94:A\n2\n\n\n4LWE:A\n1\n\n\n4LWF:A\n2\n\n\n4LWG:A\n2\n\n\n4LWH:A\n2\n\n\n4LWI:A\n2\n\n\n4NH7:A\n1\n\n\n4NH8:A\n1\n\n\n4O04:A\n1\n\n\n4O05:A\n1\n\n\n4O07:A\n1\n\n\n4O09:A\n1\n\n\n4O0B:A\n1\n\n\n4R3M:A\n1\n\n\n4U93:A\n1\n\n\n4W7T:A\n0\n\n\n4XIP:A\n1\n\n\n4XIQ:A\n1\n\n\n4XIR:A\n1\n\n\n4XIT:A\n1\n\n\n4YKQ:A\n2\n\n\n4YKR:A\n2\n\n\n4YKT:A\n2\n\n\n4YKU:A\n2\n\n\n4YKW:A\n6\n\n\n4YKX:A\n2\n\n\n4YKY:A\n2\n\n\n4YKZ:A\n2\n\n\n5CF0:A\n1\n\n\n5FNC:A\n1\n\n\n5FND:A\n2\n\n\n5FNF:A\n1\n\n\n5GGZ:A\n0\n\n\n5J20:A\n1\n\n\n5J27:A\n1\n\n\n5J2V:A\n7\n\n\n5J2X:A\n2\n\n\n5J64:A\n2\n\n\n5J6L:A\n0\n\n\n5J6M:A\n8\n\n\n5J6N:A\n8\n\n\n5J82:A\n1\n\n\n5J86:A\n8\n\n\n5J8M:A\n2\n\n\n5J8U:A\n2\n\n\n5J9X:A\n1\n\n\n5LNY:A\n1\n\n\n5LNZ:A\n1\n\n\n5LO0:A\n1\n\n\n5LO1:A\n1\n\n\n5LO5:A\n1\n\n\n5LO6:A\n8\n\n\n5LQ9:A\n1\n\n\n5LR1:A\n1\n\n\n5LR7:A\n1\n\n\n5LRL:A\n1\n\n\n5LRZ:A\n1\n\n\n5LS1:A\n1\n\n\n5M4E:A\n2\n\n\n5M4H:A\n9\n\n\n5NYH:A\n1\n\n\n5NYI:A\n2\n\n\n5OCI:A\n1\n\n\n5OD7:A\n1\n\n\n5ODX:A\n1\n\n\n5T21:A\n1\n\n\n5VYY:A\n8\n\n\n5XQD:A\n2\n\n\n5XQE:A\n1\n\n\n5XR5:A\n1\n\n\n5XR9:A\n1\n\n\n5XRB:A\n1\n\n\n5XRD:A\n2\n\n\n5XRE:A\n1\n\n\n5ZR3:A\n1\n\n\n6B99:A\n0\n\n\n6B9A:A\n0\n\n\n6CEO:A\n2\n\n\n6CYG:A\n0\n\n\n6CYH:A\n0\n\n\n6EI5:A\n1\n\n\n6EL5:A\n1\n\n\n6ELN:A\n2\n\n\n6ELO:A\n2\n\n\n6ELP:A\n1\n\n\n6EY8:A\n1\n\n\n6EY9:A\n8\n\n\n6EYB:A\n1\n\n\n6F1N:A\n2\n\n\n6FCJ:A\n2\n\n\n6GPR:A\n0\n\n\n6GPT:A\n0\n\n\n6GPW:A\n2\n\n\n6GPY:A\n0\n\n\n6GQ6:A\n0\n\n\n6GQR:A\n0\n\n\n6HHR:A\n2\n\n\n6LR9:A\n1\n\n\n6LSZ:A\n2\n\n\n6LT8:A\n0\n\n\n6LTI:A\n2\n\n\n6LTK:A\n1\n\n\n6N8X:A\n1\n\n\n6TN4:AAA\n2\n\n\n6TN5:AAA\n2\n\n\n6U99:A\n1\n\n\n6U9B:A\n1\n\n\n7DMC:A\n1\n\n\n7KRJ:A\n10\n\n\n7KW7:A\n11\n\n\n7L7I:A\n10\n\n\n7L7J:A\n10\n\n\n7LSZ:A\n1\n\n\n7LT0:A\n1\n\n\n7S8Y:A\n2\n\n\n7S8Z:A\n2\n\n\n7S90:A\n2\n\n\n7S95:A\n2\n\n\n7S98:A\n2\n\n\n7S99:A\n2\n\n\n7S9F:A\n1\n\n\n7S9G:A\n1\n\n\n7S9H:A\n1\n\n\n7S9I:A\n1\n\n\n7UR3:A\n12\n\n\n8AGI:A\n13\n\n\n\n\n\n\n\nComparison to existing literature\nThis section is to verify how this very first section on very similar binding sites differs from already existing papers. The idea is to provide constructive criticism and not to bash anyone’s work - and probably I’ll have to revise a few things on my side while reading yet again into some details of some of the published work.\n\nProspeccts Ehrt, Brinkjost, and Koch (2018)\n\nThe first data set (structures with identical sequences) was designed to evaluate the tools’ sensitivity to the binding site definition. This definition often depends on the size and location of bound ligands. Different ligands can address various regions of the binding site of interest (sub-pockets). Because of these different site definitions, similar sub-pockets are more difficult to match. Although binding sites can interact with a broad variety of ligands, they share common properties and distinct similarities. Thus, the scoring scheme has to be optimized for this scenario to enrich similar binding site pairs with different cavity definitions in a ranked list. Data set 1 contains structures with identical sequences, which bind to chemically different ligands located at identical sites, leading to diverse binding site definitions used for the comparisons.\n\n\nFirst first major difference that pops up here is that the binding site appears to be defined using the ligand bound to HSP90\n\nThis is something I already discussed in my previous post on the drawbacks of binding site comparison benchmarks\nNo apo structures can be considered here\nOn top of structural variation one adds the variation of the definition on where the binding site exactly is\n\nEhrt, Brinkjost, and Koch (2018) et al are totally right that this is something to check. I’m just relunctant to use this to define an ideal benchmark set.\n\n\nOne drawback I have here is that my binding site definition is totally fixed by residue numbers. If the structure moves (i.e. residues 107-112 in HSP90) this definition might change.\n\nSecond they cluster by identical sequence, as opposed to what I did here (same protein strictly speaking)\n\nthat very likely something I might revise on my side when starting with the 2nd set of structures with similar sequences on non identical proteins - but for let’s keep it clean & simple.\n\n\n\nThe sequences of all single chain entries of the sc-PDB[65] were sequence culled using the PISCES[104] server (with a sequence identity threshold of 25%). The single chain sc-PDB entry sequences of the culled set were compared to those of all single chain proteins as stored in the PDB using USEARCH[105]. Structures whose sequences were identical to those of at least nine others were retained. This resulted in a data set of 13 groups of diverse structures. The PDB structures within each group were aligned and the ligand-occupied binding sites were compared to ensure that all ligands were located at the same site. This visual inspection led to the exclusion of one group represented by the sc-PDB entry with the PDB ID 4l8u (chain A) as the ligand-defined binding sites differed for the structures with 100% sequence identity. A complete list of data set 1 can be found in S9 Table. An all-against-all comparison was performed to assess the performance of each tool. Site pairs of proteins with identical sequences were regarded as positives while other matches were defined as negatives.\n\n\nI’m a bit puzzled by the fact that they obtain only 13 groups through such an approach (that’s just a comment)\nThe structures were aligned, but not sure how (cf the discussion that I had earlier) & that’s not reproducible now\nVisual inspection is ok, but not reproducible as well\nIn the end we have a set with binding site locations & conformations that could potentially vary significantly (i.e. the 7l7j vs 4cwr comparison that we had in the post)\nI’m not sure I understood how the sc-PDB is used as reference or limit here (goes back to point #1 above)\nAs this is not reproducible, I cannot use the approach to update a benchmark set at any time\nThe approch used by the authors only considers single chain structures, which can be a limitation when you want to extend you dataset\nAgain I’m not sure how the sc-PDB vs PDB query is run here and to which extent there are quality filters in there. I don’t filter at all by commonly used quality filters\n\n\n\nAPoc Gao and Skolnick (2013)\n\n\nBench Subject/Control Sets. Two sets are used to benchmark the performance of APoc. Complete linkage clustering was first conducted on unique ligands curated from the PDB (see above) at a Tc threshold of 0.5, which indicates a high level chemical similarity (the mean/sd of Tc is 0.16/0.12 among all ligands in the PDB). In each cluster, the ligand type most found frequently in the pockets of protein chains curated at 90% sequence identity is selected as the cluster representative, e.g. ADP represents a cluster of ligands including AMP, ATP, etc. Within each cluster, we used a graph-based algorithm, SIMCOMP (Hattori et al., 2010), to obtain the equivalence between heavy atoms of each pair of ligands. We collect atomic contacts between heavy atoms of the ligand and protein. Two ligand–protein contacts from two separate structures are of the same type if the ligand atoms are mapped each other in the SIMCOMP alignment and the protein residues belong to the same group defined above for Equation 4. We then define the Subject set as pairs of pockets such that:\n\n\nLigands found in these two pockets have a Tc ≥ 0.5,\nSequence similarity &lt; 30% between the two associated proteins,\nThey share ≥ 50 atomic ligand–protein contacts of same type. In total, we found 38 066 pairs of pockets for the Subject set. We expect that a significant number of entries in this set share a high level of pocket similarity because they recognize the same or similar types of ligands and likely possess a putative common anchor region due to the overlap of a large number of ligand-pocket contacts (Brylinski and Skolnick, 2009). Note that no geometric information is explicitly used in this procedure.\n\n\nWell this is a totally different approach and very much focused around the “similar ligands bind to similar pockets” assumption, strengthened by the use of contact analysis. As such the dataset is not at all comparable to what we have for now, it is likely already very challenging.\n\n\nThough Dataset Govindaraj and Brylinski (2018)\n\nFirst, we identified in the PDB protein chains composed of 50–999 amino acids that non-covalently bind small organic molecules (“Select ligand-bound proteins”). No constraints were imposed on the resolution to maximize the coverage and include experimentally determined structures of varied quality. Next, we retained those proteins binding a single ligand whose TC to at least one FDA-approved drug is ≥0.5 (“Select drug-like molecules”). The TC is calculated for 1024-bit molecular fingerprints with OpenBabel [44] against FDA-approved drugs in the DrugBank database [45]. Subsequently, protein sequences were clustered with CD-HIT [46] at 40% sequence similarity (“Cluster proteins”). From each homologous cluster, we selected a representative set of proteins binding chemically dissimilar ligands whose pairwise TC is &lt; 0.5 at different locations separated by at least 8 Å (“Select representative complexes”). … In the next step, all target-bound ligands were clustered with the SUBSET program [49] (“Cluster ligands”). Using a TC threshold of 0.7 produced 1266 groups of chemically similar molecules. From all possible combinations of protein pairs within each cluster of similar compounds, we selected those having a TM-score of &lt; 0.4 as reported by Fr-TM-align [50] (“Select globally dissimilar protein pairs”). The Positive subset of TOUGH-M1 comprises 505,116 protein pairs having different structures, yet binding chemically similar ligands. Finally, we identified a representative structure within each group of proteins binding similar compounds, and considered all pairwise combinations of structures from different clusters that have a TM-score to one another of &lt; 0.4 (“Select globally dissimilar protein pairs”). The Negative subset of TOUGH-M1 comprises 556,810 protein pairs that have different structures and bind chemically dissimilar ligands.\n\nThe approach taken to create the Tough M1 dataset is similar to the one for APoc. It’s focused on identifying positive matching binding sites using ligand similarity & structural dissimilarity as main drivers. So the conclusion is the same as for APoc, it’s not at all overlapping with what I did here.\n\n\n\nShaper & Fuzcav Desaphy et al. (2012) & Weill and Rognan (2010)\n\nAn sc-PDB binding site is defined by any monomer (amino acid, ion, cofactor, prosthetic group) presenting one heavy atom closer than 6.5 Å from any heavy atom of the pharmacological ligand. All protein-ligand binding sites have been retrieved from the 2008 release of the sc-PDB database, which currently comprises 5952 entries … Data set 1 is composed of 769 pairs of nonredundant similar binding sites seeded with 769 pairs of nonredundant dissimilar binding sites. The similar pairs have been selected as follows. First, all entries from the sc-PDB database have been clustered according to their UniProt name, leading to 911 clusters and 1204 singletons. Second, an all-against-all comparison of all active sites within each cluster was realized with the 3-D alignment tool SiteAlign to generate a distance matrix … In the current study, two entries were randomly selected from each of the 911 clusters if their binding sites were found similar (d1 e 0.6 and d2 e 0.2). The same number of dissimilar binding sites was randomly selected from the initial set of 911 clusters. Binding site pairs with an Enzyme Commission (E.C.) annotation differing at the first level were retrieved until the final number of 769 pairs was reached. …\n\n\nAgain, a ligand position & surroundings are used to define the area of the binding site\nThe expected hits were obtained using another algorithm called SiteAlign (Schalon et al. (2008)). This would be the corresponding method to what I did with the contact matrices here, but SiteAlign works on a larger variety of structures. However, it’s already giving an output score of the binding site similarity, which is interesting, but already biasing the set as well\nThe set is composed of 769 pairs of non redudant similar & dissimilar binding sites. Redundancy reduction is an important aspect for the work around sc-PDB, this set & statistical significance on evaluations performed using such a set. On my end, my first data-set is nearly 100% redundant (😱) and will allow to verify the stability of a pocket comparison algorithm on similar binding sites (apo & holo) … so my first set doesn’t have exactly the same purpose as this one here."
  },
  {
    "objectID": "posts/post-with-code/2023-24-04-forced-revamp/2023-24-04-forced-revamp.html",
    "href": "posts/post-with-code/2023-24-04-forced-revamp/2023-24-04-forced-revamp.html",
    "title": "Forced revamp ongoing",
    "section": "",
    "text": "This blog is under migration to quarto.\n\nInitially I used fastai’s fastpages framework to run & expose jupyter notebooks as blog posts here. Unfortunately fastpages was discontinued a while ago and I got a bit fed up investigating & fixing github actions etc everytime I want to post an article. As suggested by the fastpages author, I’m thus discovering & migrating to quarto. which looks indeed very nice.\nDuring this migration process I had to redo most of the graphing & interactive display bits, switching from altair & 3dmoljs’s python bindings to ngl & ojs (observable js) supported by quarto. If you are interested in seeing in more detail how I integrated that, feel free to check out the source code of the blog posts of interest (look out for qmd files).\nQuarto brings a bunch of nice improvements over fastpages for me, notably proper citation management & reference lists at the end of posts, which is great.\nFurthermore, quarto allows me to locally preview what I write. For markdown that’s not really important, but for the coding bits & interactive viz things that should work it’s really nice to have that possibility.\nDuring the rewrite of some of the posts, obviously some things weren’t reproducible anymore or I found mistakes I made on my own. I tried to correct everything & adapt even the old posts, notably the torsion angle scan part with xtb. I also had to rerun the COD to sdf transformation, so I have a fresh COD version locally now with that as well :tada:\nAnyway, I really hope that quarto will stick around a bit longer & will be less tedious to maintain, but I’m mildly optimistic!"
  },
  {
    "objectID": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html",
    "href": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html",
    "title": "Binding site comparison - current benchmark issues",
    "section": "",
    "text": "First of all, what is written here is my personal viewpoint on the matter. It is conceivable that other people might have different opinions on this topic ;)\nThere has been a lot of interest on the comparison (in 3D) of binding sites since initiating work in that scope by Jambon et al. Today several methods exist, some of them freely available and some of them … not. I also got sucked into the field by the end of my PhD but never ended writing up papers about the whole topic. There are several reasons for that. The main one is likely laziness and total frustration with the scientific publishing & reviewing process. So now I decided to write things up gradually here and maybe one day I’ll spend some time shaping that into a paper ;) This post is mainly about the shortcomings in the way these algorithms are generally validated & intends to challenge currently accepted benchmark datasets in the field. NB: my focus here is to validate at some point my own algorithms, but given the state of the art, a bit of work on the datasets themselves is in order! Also, I’m focusing on how can such binding site methods be applied in the context of drug-discovery when sieving through all structural information available within resources like the RCSB PDB or a model database, like Alphafold or derivatives.\n\n\nIn its simplest form, the fact to be able to compare two pockets from two structures and assess to what extent they are similar. I guess you can already see the various pitfalls in this definition. Binding site comparison could have some rather nice applications when applied on a larger scale (compare one or multiple binding sites to millions of others) in order to identify potential off-targets (or promiscuity prediction) or chemical matter that might bind in such an environment (drug repurposing or bioisosteric replacements, fragment based designs etc …). Comparing binding sites is not a trivial task and the perception on how this should be done can vary significantly depending on the use-case or mind-set at hand. Here are some potential use cases that require dedicated datasets & validation: - idea generation in drug discovery (hit id & lead opt) - polypharmacology prediction (toxicology) - protein function prediction\n\n\n\nToday there are a lot of papers published on that topic. As usual with method development papers in science, with them a ton of ways proving that the authors’ method is for sure always the best one compared to a small selected set of the other existing ones … The field of binding site comparison lacked for a very long time a throuroughly built & commonly accepted benchmark dataset and this for various reasons. But in the end, we end up with the typical mess with a ton of methods each better than the other but not really comparable nor compared to one another.\n\n\nA recent (well now not so recent anymore …) review article by Christiane Ehrt, Tobias Brinkhorst & Oliver Koch tries to address some of the historical shortcomings in the field. They summarize some approaches known today (not extensive, but representative). You can find them in table 1 of the paper by Ehrt, Brinkjost, and Koch (2018). I fully understand that benchmarking a posteriori tens of different methods & developers must be daunting task & am really grateful the team tackled such an effort.\nThe paper reuses / discusses some of the older datasets in the litterature, and I’ll cover mainly two of the ones used by the authors.\nEhrt et al also touch upon a different topic in that paper: a dataset to benchmark a method depends on the scope of capabilities you want to test your method on. That’s a reality that was simply absent from validations before. If you want to prove that your method is capable of detecting remote relationships between binding sites on very different proteins known to bind similar ligands (or not), you have to actually validate that on a relevant dataset.\n\n\n\nOriginal paper from Govindaraj and Brylinski (2018). This dataset was introduced by Govindaraj & Brylinski the same year as the publication of prospeccts. It is an interesting one, because it focuses on one of the “dreams” in the binding site comparison community: “Two very different binding sites known to bind a similar ligand, must be to some extent similar”. I’ll come to that statement a bit later. Basically their viewpoint is that some of the previous studies had performances published that were too good, because the underlying protein structures used in the binding site comparison evaluation were too similar.\nSo they set up a process to generate a more challenging (“tough”) dataset for such methods as described in figure 1 of that paper from Govindaraj and Brylinski (2018)\nI’m currently still trying to wrap my head around the actual procedure and its potential advantages & drawbacks but have to admit that the process is as so often not reproducible as is. So one has to live with the dataset established in 2018, which itself also difficult to reproduce for reasons I won’t elaborate further - but a few lines of code from a paper about deeplytough from benevolent actually helped to get to the actual dataset at least.\n\n\n\nPaper by Kahraman et al. (2009). That’s historically the most used & cited one in the field and it was developed for a totally different purpose. To highlight that, find here the abstract from that paper: &gt; Most function prediction methods that identify cognate ligands from binding site analyses work on the assumption of molecular complementarity. These approaches build on the conjectured complementarity of geometrical and physicochemical properties between ligands and binding sites so that similar binding sites will bind similar ligands. We found that this assumption does not generally hold for protein–ligand interactions and observed that it is not the chemical composition of ligand molecules that dictates the complementarity between protein and ligand molecules, but that the ligand’s share within the functional mechanism of a protein determines the degree of complementarity. Here, we present for a set of cognate ligands a descriptive analysis and comparison of the physicochemical properties that each ligand experiences in various nonhomologous binding pockets. The comparisons in each ligand set reveal large variations in their experienced physicochemical properties, suggesting that the same ligand can bind to distinct physicochemical environments. In some protein ligand complexes, the variation was found to correlate with the electrochemical characteristic of ligand molecules, whereas in others it was disclosed as a prerequisite for the biochemical function of the protein. To achieve binding, proteins were observed to engage in subtle balancing acts between electrostatic and hydrophobic interactions to generate stabilizing free energies of binding. For the presented analysis, a new method for scoring hydrophobicity from molecular environments was developed showing high correlations with experimental determined desolvation energies. The presented results highlight the complexities of molecular recognition and underline the challenges of computational structural biology in developing methods to detect these important subtleties.\nHow on earth did this end up as benchmark dataset for binding site comparison? The conclusions of that paper are a very interesting read and if you have the chance to have access to the paper I invite you to read them."
  },
  {
    "objectID": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#what-is-binding-site-comparison",
    "href": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#what-is-binding-site-comparison",
    "title": "Binding site comparison - current benchmark issues",
    "section": "",
    "text": "In its simplest form, the fact to be able to compare two pockets from two structures and assess to what extent they are similar. I guess you can already see the various pitfalls in this definition. Binding site comparison could have some rather nice applications when applied on a larger scale (compare one or multiple binding sites to millions of others) in order to identify potential off-targets (or promiscuity prediction) or chemical matter that might bind in such an environment (drug repurposing or bioisosteric replacements, fragment based designs etc …). Comparing binding sites is not a trivial task and the perception on how this should be done can vary significantly depending on the use-case or mind-set at hand. Here are some potential use cases that require dedicated datasets & validation: - idea generation in drug discovery (hit id & lead opt) - polypharmacology prediction (toxicology) - protein function prediction"
  },
  {
    "objectID": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#existing-literature",
    "href": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#existing-literature",
    "title": "Binding site comparison - current benchmark issues",
    "section": "",
    "text": "Today there are a lot of papers published on that topic. As usual with method development papers in science, with them a ton of ways proving that the authors’ method is for sure always the best one compared to a small selected set of the other existing ones … The field of binding site comparison lacked for a very long time a throuroughly built & commonly accepted benchmark dataset and this for various reasons. But in the end, we end up with the typical mess with a ton of methods each better than the other but not really comparable nor compared to one another.\n\n\nA recent (well now not so recent anymore …) review article by Christiane Ehrt, Tobias Brinkhorst & Oliver Koch tries to address some of the historical shortcomings in the field. They summarize some approaches known today (not extensive, but representative). You can find them in table 1 of the paper by Ehrt, Brinkjost, and Koch (2018). I fully understand that benchmarking a posteriori tens of different methods & developers must be daunting task & am really grateful the team tackled such an effort.\nThe paper reuses / discusses some of the older datasets in the litterature, and I’ll cover mainly two of the ones used by the authors.\nEhrt et al also touch upon a different topic in that paper: a dataset to benchmark a method depends on the scope of capabilities you want to test your method on. That’s a reality that was simply absent from validations before. If you want to prove that your method is capable of detecting remote relationships between binding sites on very different proteins known to bind similar ligands (or not), you have to actually validate that on a relevant dataset.\n\n\n\nOriginal paper from Govindaraj and Brylinski (2018). This dataset was introduced by Govindaraj & Brylinski the same year as the publication of prospeccts. It is an interesting one, because it focuses on one of the “dreams” in the binding site comparison community: “Two very different binding sites known to bind a similar ligand, must be to some extent similar”. I’ll come to that statement a bit later. Basically their viewpoint is that some of the previous studies had performances published that were too good, because the underlying protein structures used in the binding site comparison evaluation were too similar.\nSo they set up a process to generate a more challenging (“tough”) dataset for such methods as described in figure 1 of that paper from Govindaraj and Brylinski (2018)\nI’m currently still trying to wrap my head around the actual procedure and its potential advantages & drawbacks but have to admit that the process is as so often not reproducible as is. So one has to live with the dataset established in 2018, which itself also difficult to reproduce for reasons I won’t elaborate further - but a few lines of code from a paper about deeplytough from benevolent actually helped to get to the actual dataset at least.\n\n\n\nPaper by Kahraman et al. (2009). That’s historically the most used & cited one in the field and it was developed for a totally different purpose. To highlight that, find here the abstract from that paper: &gt; Most function prediction methods that identify cognate ligands from binding site analyses work on the assumption of molecular complementarity. These approaches build on the conjectured complementarity of geometrical and physicochemical properties between ligands and binding sites so that similar binding sites will bind similar ligands. We found that this assumption does not generally hold for protein–ligand interactions and observed that it is not the chemical composition of ligand molecules that dictates the complementarity between protein and ligand molecules, but that the ligand’s share within the functional mechanism of a protein determines the degree of complementarity. Here, we present for a set of cognate ligands a descriptive analysis and comparison of the physicochemical properties that each ligand experiences in various nonhomologous binding pockets. The comparisons in each ligand set reveal large variations in their experienced physicochemical properties, suggesting that the same ligand can bind to distinct physicochemical environments. In some protein ligand complexes, the variation was found to correlate with the electrochemical characteristic of ligand molecules, whereas in others it was disclosed as a prerequisite for the biochemical function of the protein. To achieve binding, proteins were observed to engage in subtle balancing acts between electrostatic and hydrophobic interactions to generate stabilizing free energies of binding. For the presented analysis, a new method for scoring hydrophobicity from molecular environments was developed showing high correlations with experimental determined desolvation energies. The presented results highlight the complexities of molecular recognition and underline the challenges of computational structural biology in developing methods to detect these important subtleties.\nHow on earth did this end up as benchmark dataset for binding site comparison? The conclusions of that paper are a very interesting read and if you have the chance to have access to the paper I invite you to read them."
  },
  {
    "objectID": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#a-quick-peek-into-the-tough-m1-dataset",
    "href": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#a-quick-peek-into-the-tough-m1-dataset",
    "title": "Binding site comparison - current benchmark issues",
    "section": "A quick peek into the TOUGH-M1 dataset",
    "text": "A quick peek into the TOUGH-M1 dataset\nThe paper introducing the TOUGH dataset didn’t include a single figure showing what types of binding sites & thus ligands were selected to establish the benchmark dataset. So to get a glimpse of that here I’ll show a set of the most common clusters of molecules in their “positive” dataset, so a set of binding sites to be compared to others binding similar ligands.\n\nA bit of code\nLet’s read in the positive list from the TOUGH-M1 dataset and read all sd files available in the distributed version of the dataset.\n\n\nCode\n# prerequisit: get the zip file and unzip to a folder of your choice: wget https://dataverse.harvard.edu/api/access/datafile/:persistentId?persistentId=doi:10.7910/DVN/L7H7JJ/UFO5CB \n# get the positive list from the TOUGH-M1 set from the SI of the paper itself\n\nimport pandas as pd\nfrom pathlib import Path\nfrom rdkit import Chem\nfrom rdkit import RDLogger\nlg = RDLogger.logger()\nlg.setLevel(RDLogger.CRITICAL)\n\npositiveList=pd.read_csv(\"/Users/peter/Downloads/TOUGH-M1_positive.list\",delim_whitespace=True)\nuniquePdbCodes=positiveList.iloc[:, 0].unique()\nprint(\"Number of distinct PDB structures: {}\".format(len(uniquePdbCodes)))\nmolecules=[]\nfor pdbCode in uniquePdbCodes:\n    sdFilePath='/Users/peter/Downloads/TOUGH-M1_dataset/'+pdbCode+'/'+pdbCode+'00.sdf'\n    for mol in Chem.SDMolSupplier(sdFilePath,removeHs=False,sanitize=True):\n        if mol:\n            mol.RemoveAllConformers()\n            molecules.append(mol)\n\nprint(\"Read {} molecules\".format(len(molecules)))\n\n\nNumber of distinct PDB structures: 5965\nRead 5917 molecules\n\n\nFirst of all you notice that a few molecules cannot be read. I won’t go too much into detail, but feel free to peek in here which ones these are & how this could happen. Now let’s do a very basic clustering just to get a rough idea on what the dataset looks like.\n\n\nCode\nfrom rdkit.Chem import AllChem\nimport numpy as np\n\n#Define clustering setup\ndef ClusterFps(fps,cutoff=0.2):\n    from rdkit import DataStructs\n    from rdkit.ML.Cluster import Butina\n\n    # first generate the distance matrix:\n    dists = []\n    nfps = len(fps)\n    for i in range(1,nfps):\n        sims = DataStructs.BulkTanimotoSimilarity(fps[i],fps[:i])\n        dists.extend([1-x for x in sims])\n    cs = Butina.ClusterData(dists,nfps,cutoff,isDistData=True)\n    return cs\n\nfps = [AllChem.GetMorganFingerprintAsBitVect(mol,2,1024) for mol in molecules if mol]\nclusters=ClusterFps(fps,cutoff=0.4)\nclusterSizes=np.array([len(cluster) for cluster in clusters])\nsortedClusterIndices=np.argsort(clusterSizes)[::-1]\nselectedSizes=clusterSizes[sortedClusterIndices]\nfrom rdkit.Chem import Draw\nfrom rdkit.Chem.Draw import IPythonConsole\nmols=[molecules[clusters[sortedClusterIndices[idx]][0]] for idx in range(0,50)]\nlegend=[\"Cluster \"+str(sortedClusterIndices[idx])+\" - \"+str(s) for idx,s in enumerate(selectedSizes[:50])]\nDraw.MolsToGridImage(mols,molsPerRow=5,legends=legend)\n\n\n\n\n\n\n\nCode\n# Here is a bit of code if you want ot get a peek into each cluster, did that but won't show the results. Overall they look fairly clean: \n#mols=[molecules[clusters[sortedClusterIndices[0]][idx]] for idx in range(0,50)]\n#Draw.MolsToGridImage(mols,molsPerRow=5)\n\n\n\n\nResults\nThe majority of the dataset is composed of nucleotides /-sides, sugars & derivatives … ah and hemes. We can also find what we usually would consider as crystallographic surfactants, very small fragments, and a few lipids as well. In other words, the overall composition of the dataset appears to be somehow close to the Kahraman dataset despite being on a different scale (5000 structures versus 40 roughly). Here again I’d argue that such a dataset is useful in the scope of protein function prediction, but I doubt it’s the best suited for drug discovery."
  },
  {
    "objectID": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#how-about-prospeccts",
    "href": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#how-about-prospeccts",
    "title": "Binding site comparison - current benchmark issues",
    "section": "How about Prospeccts",
    "text": "How about Prospeccts\nDuring my binding site comparison tests, I also played a bit more in detail with the Prospeccts dataset 1 & 7.\n\nDataset 1\nIt tries to give indicators on how sensitive a comparison method is towards the binding site definition itself. It’s composed of 12 different protein binding sites that can be identified relatively easily with the table S9 from supporting information. Several structures are available for each binding site and a binding site comparison algorithm should ideally be able to identify binding sites of the same protein with higher similarities than binding sites of the other proteins of the dataset (used as decoy here). The authors state, that “It was generated to evaluate the sensitivity of binding site comparison tools with respect to the binding site definition. A tool which is not able to enrich similar binding sites accommodating different ligands should not be applied for drug repurposing projects or the prediction of putative off-targets”. The second sentence, does not really apply for this dataset in my opinion. I used this kind of approach though to test if naturally a binding site comparison method is able to enrich results (from a huge heterogeneous set of pockets) with binding sites from the same protein (same location) or protein family, or orthologs. Ehrt et al argue that the benchmark set depend on the purpose of the binding site comparison sofware and that’s true. Datasets like the dataset 1 from the Prospeccts paper allow first of all to check if there is some reasonable signal in identifying similar binding sites. I’m saying binding sites, not interaction patterns (!!!). As such, dataset 1 & thoroughly built extensions of these can be used to evaluate if a binding site comparison method could be used also as idea generator and for validation of off-target identification scenarios (but there aren’t any in dataset 1 as for now).\n\n\nDataset 7\nThis dataset from the prospeccts paper from Ehrt, Brinkjost, and Koch (2018) is one of these examples where you say, on paper that looks great and about what we need. But once looking into the details, it’s again rather small and there are a few very worrying errors in it as well (i.e. two PIM kinase ATP binding sites as decoy pair, a lot of NAD / FAD binding sites etc).\n\n\nHow about the Barelier dataset\nLet’s check out Barelier et al. (2015) dataset, which again is supposed to give us a few examples where the same or similar ligands bind to very different proteins. Again this is used throughout the binding site comparison community as valid benchmark dataset. The set is rather small, so I’ll just display the chemical matter that has been used here. The Barelier set is also used within the prospeccts paper. The molecules were extracted from the residue codes available in table1 SI - class A (ligands make similar interactions in related residues in both binding sites), table 2 SI - class B (same ligand groups interact with dissimilar residues & environments)), table 3 SI - class C (different parts of the ligand interacts).\n\n\nCode\nfrom rdkit.Chem import AllChem\nfrom rdkit import Chem\nimport numpy as np\nimport requests\nimport json\n\n#I love copying codes from PDF's, ACS, you cannot imagine how painful this is\nclassA=[\"2AN\",\"3IP\",\"ACD\",\"AEF\",\"AGI\",\"AMZ\",\"BRN\",\"CAU\",\"DAO\",\"CXX\",\"EIC\",\"FLN\",\"GNT\",\"HXA\",\"IBP\",\"NTZ\",\"VCA\",\"X8Z\"]\nclassB=[\"0YN\",\"IGP\",\"1QK\",\"4AX\",\"4HP\",\"4NP\",\"ALE\",\"BIO\",\"C2R\",\"CEL\",\"CFF\",\"CPB\",\"CSN\",\"DHF\",\"XDE\",\"EMO\",\"ES1\",\"FUN\",\"H2B\",\"IAC\",\"LOC\",\"LVA\",\"MTE\",\"MYC\",\"NAR\",\"OCA\",\"PDN\",\"PT1\"]\nclassC=[\"16A\",\"2AL\",\"2TN\",\"3PO\",\"AIN\",\"AZM\",\"BER\",\"CLM\",\"EMU\",\"FLF\",\"IAC\",\"LUM\",\"PHN\"]\n\n\ndef getMoleculesFromRcsb(residueCode):\n    response=requests.get(\"https://data.rcsb.org/rest/v1/core/chemcomp/\"+residueCode)\n    if(response.status_code==requests.codes.ok):\n        d=json.loads((response.text))\n        smiles=d[\"rcsb_chem_comp_descriptor\"][\"smiles\"]\n        return(Chem.MolFromSmiles(smiles))\n    return None\n\n\nclassAmolecules=[getMoleculesFromRcsb(residue) for residue in classA]\nclassBmolecules=[getMoleculesFromRcsb(residue) for residue in classB]\nclassCmolecules=[getMoleculesFromRcsb(residue) for residue in classC]\n\n\n\n\nClass A molecules\n\n\nCode\nDraw.MolsToGridImage(classAmolecules,molsPerRow=5)\n\n\n\n\n\n\n\nClass B molecules\n\n\nCode\nDraw.MolsToGridImage(classBmolecules,molsPerRow=5)\n\n\n\n\n\n\n\nClass C molecules\n\n\nCode\nDraw.MolsToGridImage(classCmolecules,molsPerRow=5)\n\n\n\n\n\nAn overall observation is that several molecules in all three classes are rather fragments than actual specific drug-like molecules. This is usually a warning sign on the reliability of the structure & the positioning of the fragment itself. There are several examples underlinging these limitations, but one of the more recent ones can be found here - Mehlman et al. (2022). The dataset also contains saturated & unsaturated alkyl chains or fatty acids. Obtaining any sort of specificity in purely hydrophobic binding sites is not straightforward to say the least. We find yet again several nucleosides or derivatives. Last, some molecules wouldn’t even pass filters like PAINS or such."
  },
  {
    "objectID": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#what-is-obviously-similar-should-be-retrieved-first",
    "href": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#what-is-obviously-similar-should-be-retrieved-first",
    "title": "Binding site comparison - current benchmark issues",
    "section": "What is obviously similar should be retrieved first",
    "text": "What is obviously similar should be retrieved first\nWhen searching large collections of structures having a single or a set of binding sites as query, I’d expect to find the structures of the same protein containing the same binding site with no or few changes (mutations, flexibility) before any other hits (proteins / binding sites), unless these other hits are locally as similar as the query protein structures themselves. This can / should happen for close homologs in common protein families."
  },
  {
    "objectID": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#what-is-objectively-similar",
    "href": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#what-is-objectively-similar",
    "title": "Binding site comparison - current benchmark issues",
    "section": "What is objectively similar",
    "text": "What is objectively similar\nThat’s a principle that is easy to say, but not as easy to verify & implement. While the previous point was scoped on the same or similar sequence space (protein families, homologs), this one should check known obvious similarities, like same fold & minor mutations / flexibility in the binding site."
  },
  {
    "objectID": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#totally-unrelated-proteins",
    "href": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#totally-unrelated-proteins",
    "title": "Binding site comparison - current benchmark issues",
    "section": "Totally unrelated proteins",
    "text": "Totally unrelated proteins\nTricky, but that’s what a lot of academics seem to focus on."
  },
  {
    "objectID": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#no-explicit-definition-of-decoys",
    "href": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#no-explicit-definition-of-decoys",
    "title": "Binding site comparison - current benchmark issues",
    "section": "No explicit definition of decoys",
    "text": "No explicit definition of decoys\nThat’s another not so trivial thing, but typically in the prospeccts paper (and others) decoys are usually defined as pairs of binding sites that shouldn’t match. For similar reasons as with decoys in virtual screening experiments, when there is no actual experimental proof that a decoy is a decoy one shouldn’t use it as a decoy. Not to mention biases this introduces intrinsically as well. If no decoys are available, we won’t be able however to compare against ROC curves vs the litterature, if that was to be our aim. Rather than following that path, I’d set up binding site similarity searches against all known & putative pockets and evaluate how much of what I should get out from a similarity search, I actually get out."
  },
  {
    "objectID": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html",
    "href": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html",
    "title": "Crystallography Open Database and torsion angle statistics with rdkit",
    "section": "",
    "text": "When designing compounds in 3D, especially within the binding site, it is often very complicated to assess if what you’ve just designed actually makes sense. Is the molecule strained? Does it make ok or favourable interactions? Does it bump into the binding site somewhere? Especially when talking to medicinal chemists, they usually want to know whether their design passes all potential physical hurdles … and while we’re at it a prediction of the binding affinity would be nice and this in 1 second.\nAmong all of these things to evaluate on a compound in 3D, the strain is something that can be either calculated (quantum mecanics, or force-field if you trust that) or compared to a set of reference compounds we know the structures of.\nA very popular reference database for small molecule conformations is the CCDC CSD. It contains more than a million small molecule crystal structures. It is widely used in pharma industry to assess various things … among them: ligand strain. I won’t enter the debate here whether the conformations observed in small molecule crystal structures are relevant and all the other debates on the use of such a database.\nThe thing is, the CSD is not freely available. However, there’s a free alternative available … I guess the poor man’s CSD and it’s called COD for Crystallography Open Database. It contains less structures than the CSD (466 000 by the time I’m writing this), that’s for sure, but it’s still maintained and people are depositing structures in there. The quality appears to be OK as well according to what I read so far, no tests done yet.\nHere I’ll outline a few steps on how to get the COD and use rdkit to extract all torsion angles of all molecules - a long and bumpy ride. Here we go."
  },
  {
    "objectID": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#context",
    "href": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#context",
    "title": "Crystallography Open Database and torsion angle statistics with rdkit",
    "section": "",
    "text": "When designing compounds in 3D, especially within the binding site, it is often very complicated to assess if what you’ve just designed actually makes sense. Is the molecule strained? Does it make ok or favourable interactions? Does it bump into the binding site somewhere? Especially when talking to medicinal chemists, they usually want to know whether their design passes all potential physical hurdles … and while we’re at it a prediction of the binding affinity would be nice and this in 1 second.\nAmong all of these things to evaluate on a compound in 3D, the strain is something that can be either calculated (quantum mecanics, or force-field if you trust that) or compared to a set of reference compounds we know the structures of.\nA very popular reference database for small molecule conformations is the CCDC CSD. It contains more than a million small molecule crystal structures. It is widely used in pharma industry to assess various things … among them: ligand strain. I won’t enter the debate here whether the conformations observed in small molecule crystal structures are relevant and all the other debates on the use of such a database.\nThe thing is, the CSD is not freely available. However, there’s a free alternative available … I guess the poor man’s CSD and it’s called COD for Crystallography Open Database. It contains less structures than the CSD (466 000 by the time I’m writing this), that’s for sure, but it’s still maintained and people are depositing structures in there. The quality appears to be OK as well according to what I read so far, no tests done yet.\nHere I’ll outline a few steps on how to get the COD and use rdkit to extract all torsion angles of all molecules - a long and bumpy ride. Here we go."
  },
  {
    "objectID": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#get-the-cod",
    "href": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#get-the-cod",
    "title": "Crystallography Open Database and torsion angle statistics with rdkit",
    "section": "Get the COD",
    "text": "Get the COD\nThat’s rather easy. You can simply retrieve cif or hkl files from their server using this here:\nmkdir -p cif; rsync -av --delete rsync://www.crystallography.net/cif/ cif/\nThis should run for a bit."
  },
  {
    "objectID": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#parsing-cif-in-rdkit",
    "href": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#parsing-cif-in-rdkit",
    "title": "Crystallography Open Database and torsion angle statistics with rdkit",
    "section": "Parsing CIF in rdkit",
    "text": "Parsing CIF in rdkit\nThe first hurdle is as usual linked to molecular formats. To the best of my knowledge no cif parser was ported yet to rdkit. I tried a few parsers (gemmi - no mol or other useable output yet, pdbccdutils -&gt; only macromolecular cif files, I think) before ending up again with openbabel in the end. Let’s stick with that for now.\nLet’s try to see what this looks like for a single cif file from the COD:\n```{python}\nfrom rdkit import Chem\nfrom openbabel import pybel\nimport dask\nmol = next(pybel.readfile(\"cif\", \"/Users/peter/Downloads/cod/cif/1/00/00/1000007.cif\")) \n\nmolblock=mol.write(\"mol\")    #write out as a molfile string and ship that now into rdkit\n\nm = Chem.MolFromMolBlock(molblock,removeHs=False)\nChem.MolToMolFile(m,\"samplemolecule.mol\")\nm\n```\nWell, that looks rather nasty. Let’s check in 3D:\n\n\nCode\n// Create drawing area\ndiv_mol = html`&lt;div style=\"width:400px;height:400px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\n\n\n\nCode\nNGL = require(\"ngl@next\");\n\n   molBlock = await FileAttachment(\"samplemolecule.mol\").blob();\n\nstage = new NGL.Stage(div_mol, { backgroundColor: \"black\",cameraType: \"orthographic\"});\nstructure = await stage.loadFile(molBlock, {ext: \"sdf\", asTrajectory: false})\nstructure.addRepresentation(\"licorice\",{ \"sele\": \"all\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nstructure.autoView();\n\n\n\n\n\n\n\n\n\nSo good news, cif parsing seems to work (at least on this particular example). The bad news, how can I get to relevant molecules in the COD?"
  },
  {
    "objectID": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#extracting-relevant-molecules-from-the-cod",
    "href": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#extracting-relevant-molecules-from-the-cod",
    "title": "Crystallography Open Database and torsion angle statistics with rdkit",
    "section": "Extracting relevant molecules from the COD",
    "text": "Extracting relevant molecules from the COD\nThanks to researchgate I came across this page where they provide a datawarrior file of the content of the cod (at least a curated subpart of that). You can see that the COD contains organic, inorganic and metalorganic structures.\n\n\n\ndatawarrior screenshot\n\n\nAs you might already observe on the screenshot above, there’s a lot of noise (for drug discovery) in there.\nSo how can we filter out only the organic ones? I checked the individual cif files, and no easy way to get to this classification … would have been too easy. So two solutions - either take the prepared datawarrior file (which I would not prefer, because I’m dependent on somebody else doing this nice work during his free-time, Thomas Sander), or trial and error and identify organic compounds with a set of rules. Good thing is, I can use Thomas Sanders work (the datawarrior file) to check if the filter works or not (+ visual inspection).\nThe COD dump you can download via rsync is structured a bit like the PDB: with two levels of subfolders, numbered and 100 files max per subfolder. Basically I’ll have to loop over all of this -&gt; let’s blow up the notebook ;) I’ll loop over all molecules and try to run through sanitize. All failing molecules should not be added. Next I’m checking as well if there’s at least a carbon atom in the structure (for a lot of them there isn’t). I filter out metalorganics as well. Last I keep only molecules with more than 6 atoms.\nAs this is a bit slow and can be easily put on several cpu’s I’m doing that right here as well. I wanted to test how dask behaves on such a task. It’s total overkill for what I’m doing here, but I want to see how the scheduling behaves on short living and often failing jobs (difficult to orchestrate, unless you handle it yourself in the code).\nBelow you have a standalone python script (was not optimal in the notebook) to run all of this quick and dirty preparation. There are tons of rdkit & openbabel warnings popping out of that, as expected:\n```{python}\n#| tags: []\n#| eval: false\nfrom rdkit import Chem\nfrom openbabel import pybel\nimport glob\nimport pandas as pd\nimport os\nimport multiprocessing as mp\n# from wrapt_timeout_decorator import *\nfrom rdkit import rdBase\nrdBase.DisableLog('rdApp.error')\nrdBase.DisableLog('rdApp.warning')\n\nob_log_handler = pybel.ob.OBMessageHandler()\nob_log_handler.SetOutputLevel(0)\n\ncarbon = Chem.MolFromSmarts(\"[#6]\")\n\n\n\ndef is_transition_metal(at):\n    n = at.GetAtomicNum()\n    return (n&gt;=22 and n&lt;=29) or (n&gt;=40 and n&lt;=47) or (n&gt;=72 and n&lt;=79)\n\n\ndef write_output(filenames,outputname=\"out.sdf\"):\n    w = Chem.SDWriter(outputname)\n    for filename in filenames:\n        try:\n            if os.stat(filename).st_size / (1024 * 1024)&lt;2.0:\n                mol = next(pybel.readfile(\"cif\",str(filename))) \n                molblock=mol.write(\"mol\")    #write out as a molfile string and ship that now into rdkit\n                m = Chem.MolFromMolBlock(molblock,removeHs=False,sanitize=True)\n                m.SetProp('COD',os.path.basename(filename).split(\".\")[0])\n                w.write(m)\n        except Exception:\n            pass\n    w.close()\n\ndef select_molecule(filename):\n\n    blacklist=[\"/Users/peter/Downloads/cod/cif/2/31/17/2311717.cif\",\"/Users/peter/Downloads/cod/cif/2/10/46/2104629.cif\",\"/Users/peter/Downloads/cod/cif/2/10/59/2105953.cif\"]\n    if(filename not in blacklist):\n        try:\n            mol = next(pybel.readfile(\"cif\",str(filename))) \n            molblock=mol.write(\"mol\")    #write out as a molfile string and ship that now into rdkit\n            m = Chem.MolFromMolBlock(molblock,removeHs=False,sanitize=True)\n            \n            if m is not None and len(m.GetSubstructMatches(carbon))&gt;0 and m.GetNumAtoms()&gt; 6  :\n                \n                if(True not in [is_transition_metal(atom) for atom in m.GetAtoms()]):\n                    return filename\n        except Exception:\n            return None\n        return None\n    return None\n\n\nif __name__ == '__main__':\n    files=glob.glob('/Users/peter/Downloads/cod/cif/**/*.cif', recursive=True)\n    n=0\n\n    pool = mp.Pool(mp.cpu_count())\n    results = pool.map(select_molecule, files)\n    \n    validresults=[el for el in results if el is not None]\n    codids=[int(os.path.basename(filename).split(\".\")[0]) for filename in validresults]\n    write_output(validresults)\n    # df = pd.read_table('/Users/peter/Downloads/COD_2020jun13.txt',  header=0)\n\n    # dwr=df[\"COD Number\"]\n\n    # common=list(set(dwr) & set(codids))\n\n    \n    # print(\"common molecules\")\n    # print(len(common))\n\n    # import numpy as np\n    # print(\"in mine, not in datawarrior\")\n    # intersect1=np.setdiff1d(codids,dwr)\n    # np.savetxt(\"out_intersect1.csv\",intersect1.astype(int),delimiter=\",\",fmt='%i')\n    # print(len(intersect1))\n\n    # print(\"in datawarrior, not in mine\")\n    # intersect2=np.setdiff1d(dwr,codids)\n    # np.savetxt(\"out_intersect2.csv\",intersect2.astype(int),delimiter=\",\",fmt='%i')\n    # print(len(intersect2))\n```\nI finally decided to strip out the dask code and run it through multiprocessing. Anyhow, easy to set up and a quick discussion on that below as well!"
  },
  {
    "objectID": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#dask-multiprocessing-interlude",
    "href": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#dask-multiprocessing-interlude",
    "title": "Crystallography Open Database and torsion angle statistics with rdkit",
    "section": "Dask & multiprocessing interlude",
    "text": "Dask & multiprocessing interlude\nBefore analyzing the results, let’s briefly assess how dask performs here. Dask enables us to run the code in a classical threaded, but also distributed mode, even on a local machine. As I have 12 cores’s hanging in my MacPro I tested a distributed calculation. That is rather easy to set up. A bit like a multiprocessing Pool, but with the advantage that the functions are not 100% isolated (advantage or disadvantage, I let you decide ;)).\nThe other nice thing (I didn’t know about) is that dask (if installed through conda at least) comes with bokeh, a tool allowing you to do some monitoring of your jobs. It’s not super advanced, but gives you an overview of the worker loads, the job queue and the overall advancement. So that’s quite cool compared to being completely blind on what’s happening in your queue.\n\n\n\ndask screenshot\n\n\nI tested quite a range of combinations and ways to run this in dask (bag, compute, map …. ) and combinations of number of worker nodes vs threads. In the end, parallelization still isn’t optimally spread over all cpu’s, but I guess that’s likely due to the fact that every calculation can range from immediate failure to runnning for a very long time. I guess, that on longer living and more stable jobs this is far more efficient.\nThe most frustrating thing was that the script completely froze on a single job during the last 10% of the molecules. I narrowed down the issue to 3 molecules that openbabel naturally had issues with. When I say naturally, have a look at these:\n\n\n\nissues with these cod’s\n\n\nThe nasty thing here is that I even tried to kill these freezing jobs with timeout decorators and such. Without success. Even a ctrl+c in a shell didn’t kill the job … only a kill -9 did. So in the end I kept the multiprocessing version here in the code and filtered out the three incriminating molecules ( by hand, but would be really interested to know how this can be handled in a more geeky way)."
  },
  {
    "objectID": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#final-filtered-cod",
    "href": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#final-filtered-cod",
    "title": "Crystallography Open Database and torsion angle statistics with rdkit",
    "section": "Final filtered COD",
    "text": "Final filtered COD\nLet’s come back to the actual aim of this post. Extract torsion angle statistics from small molecule crystal structures. First let’s have a look what molecules I have in common now with Datawarrior and which ones are different and whether the filter should / could be refined a bit.\n\n\n\n\nobabel & rdkit\nDatawarrior\n\n\n\n\nobabel & rdkit\n78643\n117674\n\n\nDatawarrior\n117674\n18344\n\n\n\nThe majority of retained molecules are in common with datawarrior, but I am, I guess still a bit permissive for now. I don’t want to go too much into the analysis of differences here and now. Quickly checking the sd file (above 1Gb) with datawarrior gives a few ideas on what to filter out. I guess I can also use some of the published usual filters on top of that.\n\n\n\nquick overview\n\n\nNB: the results above are from the initial post. I had to repeat the whole thing when I moved the blog to quarto. During this redo I published the output sd file on zenodo so you can use it. It’s the state of the COD of April 2023."
  },
  {
    "objectID": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#towards-torsion-angles",
    "href": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#towards-torsion-angles",
    "title": "Crystallography Open Database and torsion angle statistics with rdkit",
    "section": "Towards torsion angles",
    "text": "Towards torsion angles\nNow the next step is to identify whether there’s enough data to gather some statistics on some typical torsion angles that you can encounter in druglike molecules. Fortunately Sereina Riniker & Greg Landrum already did something a bit similar in the past with data from the CSD and the PDB to write the ETKDG (I hope I got that right) conformer generator for rdkit.\nThe SI of that paper lists a bunch of smarts patterns describing such torsion angles. I’ll blindly use these here to sieve through all molecules from the COD to see what I can get out of that. The smarts patterns are available here - freely available … unlike the paper behind it :(\n\nimport pandas as pd\nfrom rdkit.Chem import rdMolTransforms\n\nimport matplotlib.pyplot as plt \nimport matplotlib.image as mpimg\nimport numpy as np\nimport urllib.parse\n\ntorsions=pd.read_table(\"data/list_torsion_patterns.txt\",header=None,usecols=[1])\nsuppl = Chem.SDMolSupplier('out.sdf',removeHs=False)\npatterns=torsions[1][:3]\n\nfor torsionSmarts in patterns:\n    print(torsionSmarts)\n    angles=[]\n    torsionQuery = Chem.MolFromSmarts(torsionSmarts)\n    i=0\n    #suppl.reset()\n    for mol in suppl:\n        i+=1\n        if mol is None: continue\n        conf=mol.GetConformer(0)\n        matches = mol.GetSubstructMatches(torsionQuery)\n        if(len(matches)&gt;0):\n            for match in matches:\n                angle=rdMolTransforms.GetDihedralDeg(conf, match[0],match[1],match[2],match[3])\n                angles.append(angle)\n\n\n    if(len(angles)):\n        smarts=urllib.parse.quote(torsionSmarts)\n        img = mpimg.imread(\"https://smarts.plus/smartsview/download_rest?smarts=\"+smarts,format=\"png\")\n\n        fig = plt.figure(figsize=(10, 5))\n        fig.add_subplot(121)\n        plt.title('smarts pattern')\n        plt.axis('off')\n        plt.imshow(img)\n\n        fig.add_subplot(122)\n        plt.title('torsion angle histogram')\n        \n        #df = pd.DataFrame(angles,columns = [torsionSmarts])  \n        \n        plt.hist(np.array(angles),bins=36,range=[-180, 180])\n\n  \nI’m only showing 3 smarts patterns here, but the code is written to run on all of the smarts patterns from the Riniker & Landrum paper. So feel free to adjust it to get the full results on your machine (to big for the notebook here ;).\nAs you can see, there is still a lot of errors when re-reading the molecules from the SD file … so still a lot of curation to be done. Also, on fullerenes or graphene or other larger structures (that are still in there), we’ll likely get a repeated overrepresentation of several torsion angles. So something to think about when normalizing all of this data in the end.\nIn theory, the order of the smarts patterns in the file I used here should be comparable to torsion angles provided in the S1.zip by both authors (fingers crossed). These histograms were generated on a filtered / curated CCDC CSD dataset (unlike my hairy monster dataset here).\n\n\n\ntorsions\n\n\nThe first thing to notice is that they calculated a dihedral between 0 and 360, I just took the angles popping out of rdkit (between -180 and 180). So a bit of a mindgame to compare both. On smarts patterns 1 and 3 we have peaks around 0, which coincides with the CSD results. It is interesting to see that there’s a bit of data for smarts pattern 1 suggesting angles around 180° might be possible, though not favourable (again, more filtering and quality checks needed to confirm/discard that).\nSmarts pattern 2 doesn’t coincide at all with results from the CSD however, which makes me worried … a bit ;)"
  },
  {
    "objectID": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#debugging-smarts-pattern-2",
    "href": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#debugging-smarts-pattern-2",
    "title": "Crystallography Open Database and torsion angle statistics with rdkit",
    "section": "Debugging smarts pattern 2",
    "text": "Debugging smarts pattern 2\n\npattern=\"[O:1]=[C:2]([N])!@;-[O:3]~[C:4]\"\ni=0\ntorsionQuery = Chem.MolFromSmarts(pattern)\nfor mol in suppl:\n    i+=1\n    if mol is None: continue\n    conf=mol.GetConformer(0)\n    matches = mol.GetSubstructMatches(torsionQuery)\n    if(len(matches)):\n        for match in matches:\n                angle=rdMolTransforms.GetDihedralDeg(conf, match[0],match[1],match[2],match[3])\n                #break\n                print(angle)\n                print(mol.GetProp(\"COD\"))\n    if(i&gt;5000):\n        break\n\nHere are 4 compounds where we calculate in theory wrong angles. Let’s visualize the last one and check what dihedral angle we are actually calculating here\n\nfor mol in suppl:\n    if str(mol.GetProp(\"COD\"))==str(7039689):\n        mol.GetSubstructMatches(torsionQuery)\n        break\n\nmatches=mol.GetSubstructMatches(torsionQuery)\nprint(matches)\nflat_list = [item for sublist in matches for item in sublist]\nmolblock=Chem.MolToMolBlock(mol)\nviewer = py3Dmol.view(width=300, height=300)\nviewer.addModel(molblock, 'mol')\nviewer.setStyle({\"stick\":{}})\n#viewer.setStyle({'serial':flat_list},{'stick':{'color': 'pink'}})\nviewer.setStyle({'serial':flat_list},{'stick':{'color': 'pink'}})\n\nviewer.zoomTo()\n\nThe matching atoms are coloured in pink here.\nFrom the substructure matches above, we can see that the smarts pattern matches 5 atoms, instead of 4. Including the nitrogen (the third atom matching here). In the end, this doesn’t describe the bond or the torsion angle we want at all, thus the discrepancies in the results."
  },
  {
    "objectID": "posts/post-with-code/2021-02-02-fpocket-towards-biologics/2021-02-02-fpocket-towards-biologics.html",
    "href": "posts/post-with-code/2021-02-02-fpocket-towards-biologics/2021-02-02-fpocket-towards-biologics.html",
    "title": "fpocket 4.0 - Towards biologics",
    "section": "",
    "text": "I just released the last version of fpocket (4.0) which contains quite a few new features. Most of the work was done by Mael Shorkar, an eager summer intern we took in at Discngine during last year’s COVID-mess summer. He did a great job under these circumstances (remote work in a new company etc). So kudos to him for these new additions."
  },
  {
    "objectID": "posts/post-with-code/2021-02-02-fpocket-towards-biologics/2021-02-02-fpocket-towards-biologics.html#mmcif-support",
    "href": "posts/post-with-code/2021-02-02-fpocket-towards-biologics/2021-02-02-fpocket-towards-biologics.html#mmcif-support",
    "title": "fpocket 4.0 - Towards biologics",
    "section": "MMCIF support",
    "text": "MMCIF support\nFirst of all, fpocket now supports mmCIF. Yay … yet another very painful task to integrate for yet another painfully crappy molecular file format (I admire the openbabel folks … ;) ). Same as for the PDB format we forked essentially an integration from the VMD molfile plugin and extended that a bit further. Mael also integrated mmCIF writers so all output files can be written in this new crappy format as well. Essentially you now have the choice to write either only pdb or cif or both. So everybody should be happy (nah … that’s never going to be case anyway)."
  },
  {
    "objectID": "posts/post-with-code/2021-02-02-fpocket-towards-biologics/2021-02-02-fpocket-towards-biologics.html#new-command-line-flags",
    "href": "posts/post-with-code/2021-02-02-fpocket-towards-biologics/2021-02-02-fpocket-towards-biologics.html#new-command-line-flags",
    "title": "fpocket 4.0 - Towards biologics",
    "section": "New command line flags",
    "text": "New command line flags\nThe most interesting part (for me) of this release are additional command line flags and behind these several use cases that can be addressed now. These command line arguments enable mainly to work in a more controlled way with multi chain protein structures. This can be particularly useful if: 1. you want to study only one domain of one of these novel gigantic cryoEM structures 2. you want to study in detail a protein - biomolecule binding site (so other than small molecule) 3. you want to learn key characteristics of peptide/protein binding sites vs RNA/DNA binding sites vs drug binding sites\n    -c char : (Default is none): Use this flag to choose which chains you want to delete before running fpocket. The selected chains can be specified with ',' or ':' delimiters, for example you can use it '-c B,D' or '-c B:D'. You can delete up to 20 different chains.\nThis flag essentially allows you to explicitly delete particular chain(s) before doing the fpocket run. This allows you to identify (without any bias) clefts that might occur on the PPI that were inaccessible before for pocket prediction.\n    -k char : (Default is none): Use this flag to choose which chains you want to keep before running fpocket. The selected chains can be specified with ',' or ':' delimiters, for example you can use it '-k A,B,E' or '-k A:B:E'. You can keep up to 20 different chains.\nThis is essentially the inverse operator of the previous flag. If you do not want to list n chains, you can decide to keep only the relevant ones here.\n    -a char : (Default is none): With this flag you can select a chain you want to be considered as a ligand. Works the same way as the \"-r\" flag but with a whole chain. Only a single chain can be chosen, for example '-a D'.\nThis flag essentially allows you to target for only one particular binding epitope. If you want to extract descriptors for only that binding site where the select chain is located then you can use the -a flag. Fpocket will hide the chain specified via the flag. Run vertice detection and then will choose all vertices overlapping with the chain you specified in -a. These will then be clustered together into a final “pocket”. This is rather generic and can be applied on protein chains, RNA, DNA … whatever you like given that it is defined in a seperate chain. It is so generic, that in theory you can do even very nasty stuff, but let’s see if you can find that out yourselves.\nThis argument is particularly interesting when you want to extract examples (3D patches) or numerical descriptors (polar/apolar ASA, curvature, buriedness …) for other binding sites than classical small molecule binding sites. It essentially lies out the basics for training & learning what such other binding epitopes look like. You can use that for a fancy model, or to characterize binding epitopes ultimately."
  },
  {
    "objectID": "posts/post-with-code/2021-02-02-fpocket-towards-biologics/2021-02-02-fpocket-towards-biologics.html#miscellaneous",
    "href": "posts/post-with-code/2021-02-02-fpocket-towards-biologics/2021-02-02-fpocket-towards-biologics.html#miscellaneous",
    "title": "fpocket 4.0 - Towards biologics",
    "section": "Miscellaneous",
    "text": "Miscellaneous\nSeperately, several things were added to the github repo of fpocket, namely the old documentation was ported to markdown (that was painful). There’s also a tiny testing environment, CI/CD pipes finally set up to check compilation and unit tests upon PR’s.\nLast, an official fpocket docker image is also available on dockerhub."
  },
  {
    "objectID": "posts/post-with-code/2021-02-02-fpocket-towards-biologics/2021-02-02-fpocket-towards-biologics.html#extracting-descriptors-with-fpocket",
    "href": "posts/post-with-code/2021-02-02-fpocket-towards-biologics/2021-02-02-fpocket-towards-biologics.html#extracting-descriptors-with-fpocket",
    "title": "fpocket 4.0 - Towards biologics",
    "section": "Extracting descriptors with fpocket",
    "text": "Extracting descriptors with fpocket\nOk running these things on individual examples is nice. You can automate things with fpocket quite easily and extract descriptors on a larger scale using the fancy -d flag (oh yes, yet another flag) if the only thing you’re after is descriptor extraction.\n\nWhy would I ever want to extract descriptors?\nCalculating descriptors on binding epitopes is generating the basis for using these to derive several potential applications afterwards. For instance, to derive the druggability prediction in fpocket, first we extracted descriptors of known druggable and supposed non-druggable (no religious debate here) pockets, second we determined the most relevant descriptors and last we trained a scoring function based on these descriptors.\nYou can very well imagine to do the same on other types of binding epitopes (there are a few papers out there on that already I guess), like protein protein interfaces, antibody / antigene interfaces more specifically, crystal contacts, protein DNA/RNA interfaces etc…\nUltimately these characterisations will allow you to train functions or super fancy deep learning models (if you really need that).\nIn order to do that on a larger scale you could use dpocket (a less well-known sibling of fpocket), but it currently still doesn’t fully integrate the logic with selecting chains as ligands (still a bit of work needed here). So let’s stick to fpocket on a larger scale example for descriptor extraction which will work just fine:\ndata/peptide_data/3uqp.pdb B\ndata/peptide_data/3uri.pdb B\ndata/peptide_data/4rcp.pdb B\ndata/peptide_data/4tpg.pdb E\ndata/peptide_data/5jxh.pdb H\nLet’s suppose we have a csv file like this one above. It defines a set of PDB files and the chain we want to consider as a ligand explicitly during the fpocket run to assess the binding epitope this chain is making with the “receptor”. You could run this in a very geeky way using this here:\nawk '{ print \"fpocket -f \" $1 \" -a \"$2 \" -d\"}' list.txt | sh\nThis will output a messy thing like this:\ncav_id drug_score volume nb_asph inter_chain apol_asph_proportion mean_asph_radius as_density mean_asph_solv_acc mean_loc_hyd_dens flex hydrophobicity_score volume_score charge_score polarity_score a0_apol a0_pol af_apol af_pol n_abpa ala cys asp glu phe gly his ile lys leu met asn pro gln arg ser thr val trp tyr chain_1_type chain_2_type num_res_chain_1 num_res_chain_2 lig_het_tag name_chain_1 name_chain_2\n1 0.0021 4091.2471 213 0 0.1831 4.3624 10.8343 0.5065 10.3590 0.0000 17.6957 4.1304 3 31 176.3137 207.7781 91.7446 196.2307 21 1 4 2 3 0 3 1 4 0 4 1 3 0 1 1 6 4 2 3 3 0 0 457 457 PSA A A\ncav_id drug_score volume nb_asph inter_chain apol_asph_proportion mean_asph_radius as_density mean_asph_solv_acc mean_loc_hyd_dens flex hydrophobicity_score volume_score charge_score polarity_score a0_apol a0_pol af_apol af_pol n_abpa ala cys asp glu phe gly his ile lys leu met asn pro gln arg ser thr val trp tyr chain_1_type chain_2_type num_res_chain_1 num_res_chain_2 lig_het_tag name_chain_1 name_chain_2\n1 0.1847 4801.9624 204 0 0.3529 4.4814 10.8531 0.5450 22.0000 0.0000 27.5882 3.4706 -8 26 183.5595 226.1442 124.2374 226.0680 11 1 0 0 7 0 2 1 7 0 8 4 0 0 4 0 9 5 0 2 1 0 0 328 328 NULL A A\ncav_id drug_score volume nb_asph inter_chain apol_asph_proportion mean_asph_radius as_density mean_asph_solv_acc mean_loc_hyd_dens flex hydrophobicity_score volume_score charge_score polarity_score a0_apol a0_pol af_apol af_pol n_abpa ala cys asp glu phe gly his ile lys leu met asn pro gln arg ser thr val trp tyr chain_1_type chain_2_type num_res_chain_1 num_res_chain_2 lig_het_tag name_chain_1 name_chain_2\n1 1.0000 2998.7053 187 0 0.5241 4.3207 11.5341 0.5341 48.6735 0.0000 34.3462 5.0769 3 16 107.4789 84.2598 47.7836 96.3200 8 1 2 1 2 0 0 1 1 1 1 3 3 0 3 0 1 0 1 4 1 0 0 238 238 NULL A A\ncav_id drug_score volume nb_asph inter_chain apol_asph_proportion mean_asph_radius as_density mean_asph_solv_acc mean_loc_hyd_dens flex hydrophobicity_score volume_score charge_score polarity_score a0_apol a0_pol af_apol af_pol n_abpa ala cys asp glu phe gly his ile lys leu met asn pro gln arg ser thr val trp tyr chain_1_type chain_2_type num_res_chain_1 num_res_chain_2 lig_het_tag name_chain_1 name_chain_2\n1 0.9998 1552.9973 110 0 0.4182 4.5201 6.7627 0.4934 36.8261 0.0000 34.2593 4.8519 0 17 105.0637 48.2599 82.1878 27.8238 12 1 1 2 0 0 3 2 0 0 2 1 1 0 3 1 2 0 0 6 2 0 0 594 594 NULL A A\ncav_id drug_score volume nb_asph inter_chain apol_asph_proportion mean_asph_radius as_density mean_asph_solv_acc mean_loc_hyd_dens flex hydrophobicity_score volume_score charge_score polarity_score a0_apol a0_pol af_apol af_pol n_abpa ala cys asp glu phe gly his ile lys leu met asn pro gln arg ser thr val trp tyr chain_1_type chain_2_type num_res_chain_1 num_res_chain_2 lig_het_tag name_chain_1 name_chain_2\n1 0.0044 3875.7029 152 0 0.1513 4.4958 9.8519 0.5972 9.5652 0.0000 -7.5946 3.4865 -7 27 114.7247 187.8280 70.7198 141.5900 15 2 3 2 8 0 0 4 4 2 0 1 0 0 0 2 2 4 1 1 1 0 0 499 499 NULL A A\n\n\nLet’s clean this up the geeky way:\nawk '{ print \"fpocket -f \" $1 \" -a \"$2 \" -d\"}' list.txt | sh | awk '{if(NR%2==0)print}'\nThis should only give the descriptors:\n1 0.0021 3972.3301 213 0 0.1831 4.3624 10.8343 0.5065 10.3590 0.0000 17.6957 4.1304 3 31 176.3137 207.7781 91.7446 196.2307 21 1 4 2 3 0 3 1 4 0 4 1 3 0 1 1 6 4 2 3 3 0 0 457 457 PSA A A\n1 0.1847 4604.5068 204 0 0.3529 4.4814 10.8531 0.5450 22.0000 0.0000 27.5882 3.4706 -8 26 183.5595 226.1442 124.2374 226.0680 11 1 0 0 7 0 2 1 7 0 8 4 0 0 4 0 9 5 0 2 1 0 0 328 328 NULL A A\n1 1.0000 2895.7646 187 0 0.5241 4.3207 11.5341 0.5341 48.6735 0.0000 34.3462 5.0769 3 16 107.4789 84.2598 47.7836 96.3200 8 1 2 1 2 0 0 1 1 1 1 3 3 0 3 0 1 0 1 4 1 0 0 238 238 NULL A A\n1 0.9998 1574.4559 110 0 0.4182 4.5201 6.7627 0.4934 36.8261 0.0000 34.2593 4.8519 0 17 105.0637 48.2599 82.1878 27.8238 12 1 1 2 0 0 3 2 0 0 2 1 1 0 3 1 2 0 0 6 2 0 0 594 594 NULL A A\n1 0.0044 3794.7029 152 0 0.1513 4.4958 9.8519 0.5972 9.5652 0.0000 -7.5946 3.4865 -7 27 114.7247 187.8280 70.7198 141.5900 15 2 3 2 8 0 0 4 4 2 0 1 0 0 0 2 2 4 1 1 1 0 0 499 499 NULL A A\nI did this on a larger list of peptide binding structures and this is typically a good way to start studying some of the properties of these epitopes compared to drug binding sites or others.\n\nimport seaborn as sns\nimport pandas as pd\nimport matplotlib.pyplot as plt\nsns.set_context('notebook')\nsns.set_style('dark')\n\n\ndf=pd.read_table('peptide_out.txt',delim_whitespace=True,header=None,names=[\"cav_id\",\"drug_score\",\"volume\",\"nb_asph\",\"inter_chain\",\"apol_asph_proportion\",\"mean_asph_radius\",\"as_density\",\"mean_asph_solv_acc\",\"mean_loc_hyd_dens\",\"flex\",\"hydrophobicity_score\",\"volume_score\",\"charge_score\",\"polarity_score\",\"a0_apol\",\"a0_pol\",\"af_apol\",\"af_pol\",\"n_abpa\",\"ala\",\"cys\",\"asp\",\"glu\",\"phe\",\"gly\",\"his\",\"ile\",\"lys\",\"leu\",\"met\",\"asn\",\"pro\",\"gln\",\"arg\",\"ser\",\"thr\",\"val\",\"trp\",\"tyr\",\"chain_1_type\",\"chain_2_type\",\"num_res_chain_1\",\"num_res_chain_2\",\"lig_het_tag\",\"name_chain_1\",\"name_chain_2\"])\n# d=as.data.frame(read.table(\"peptide_out.txt\",sep=\" \", header=TRUE, col.names=c(\"cav_id\",\"drug_score\",\"volume\",\"nb_asph\",\"inter_chain\",\"apol_asph_proportion\",\"mean_asph_radius\",\"as_density\",\"mean_asph_solv_acc\",\"mean_loc_hyd_dens\",\"flex\",\"hydrophobicity_score\",\"volume_score\",\"charge_score\",\"polarity_score\",\"a0_apol\",\"a0_pol\",\"af_apol\",\"af_pol\",\"n_abpa\",\"ala\",\"cys\",\"asp\",\"glu\",\"phe\",\"gly\",\"his\",\"ile\",\"lys\",\"leu\",\"met\",\"asn\",\"pro\",\"gln\",\"arg\",\"ser\",\"thr\",\"val\",\"trp\",\"tyr\",\"chain_1_type\",\"chain_2_type\",\"num_res_chain_1\",\"num_res_chain_2\",\"lig_het_tag\",\"name_chain_1\",\"name_chain_2\")))\np=sns.histplot(data=df, x=\"a0_apol\", color=\"skyblue\",bins=20, label=\"apolar surface area\", kde=True)\np.set(xlabel='Surface in A^2', ylabel='Count')\n\np=sns.histplot(data=df, bins=20,x=\"a0_pol\", color=\"red\", label=\"polar surface area\", kde=True)\np.set(xlabel='Surface in A^2', ylabel='Count')\n\np.legend() \n\n&lt;matplotlib.legend.Legend at 0x7fb9ebf9ee80&gt;\n\n\n\n\n\n\nsns.scatterplot(data=df, x=\"n_abpa\", y=\"a0_apol\")\n\n&lt;AxesSubplot:xlabel='n_abpa', ylabel='a0_apol'&gt;\n\n\n\n\n\nThe plot above shows the relationship between the number of ABPA’s (almost burried polar atoms - if you don’t know what these are, you should read this paper on shielded hydrogen bonds and the apolar surface area. Coloring done is by volume of the “pocket”."
  },
  {
    "objectID": "posts/post-with-code/2021-02-02-fpocket-towards-biologics/2021-02-02-fpocket-towards-biologics.html#perspectives",
    "href": "posts/post-with-code/2021-02-02-fpocket-towards-biologics/2021-02-02-fpocket-towards-biologics.html#perspectives",
    "title": "fpocket 4.0 - Towards biologics",
    "section": "Perspectives",
    "text": "Perspectives\nAll of these new functionalities (a part from the support of yet another “useless” file format) set the grounds for characterization of various types of binding epitopes using fpocket. This can terefore be used for functional characterization of protein structures, ultimately indicating where might bind what on a protein structure.\nBut still a few sleepless nights to go until we can achieve that. Fortunately everything is opensource, so you can do that before!!! ;)"
  },
  {
    "objectID": "posts/post-with-code/2021-02-16-torsion-angle-scans-xtb/2021-02-16-torsion-angle-scans-xtb.html",
    "href": "posts/post-with-code/2021-02-16-torsion-angle-scans-xtb/2021-02-16-torsion-angle-scans-xtb.html",
    "title": "Torsion angle scan with rdkit & xtb",
    "section": "",
    "text": "Post #4 will be along the lines of dihedral / torsion angle analysis again. The aim is to log some of the hurdles I had to overcome to run a torsion angle analysis with xtb and / or rdkit.\nWhat I’m trying to accomplish here is mainly to see how torsion angle scans can be performed - easily and robustly - using open source tools available. This is in preparation of a larger work track on analysing the data from the COD, where first steps have already been set here."
  },
  {
    "objectID": "posts/post-with-code/2021-02-16-torsion-angle-scans-xtb/2021-02-16-torsion-angle-scans-xtb.html#aim",
    "href": "posts/post-with-code/2021-02-16-torsion-angle-scans-xtb/2021-02-16-torsion-angle-scans-xtb.html#aim",
    "title": "Torsion angle scan with rdkit & xtb",
    "section": "Aim",
    "text": "Aim\nGiven an input molecule and a particular torsion angle I’d like to see what the energy langscape of the molecule looks like when rotating around that torsion angle. I’d like to know how easy/complicated this is using two different tools:\n\nrdkit with the integrated MMFF\nxtb from the Grimme lab\n\nThe post is also inspired by an older post done by iwatobipen analyzing openforcefield with Ani2 on some torsion energy predictions using the torsion drive dataset from the openforcefield initiative\nAll code used for this post is available on this separate repo, as it uses a slightly different environment (you’ll see why)."
  },
  {
    "objectID": "posts/post-with-code/2021-02-16-torsion-angle-scans-xtb/2021-02-16-torsion-angle-scans-xtb.html#dihedral-scan-with-rdkit",
    "href": "posts/post-with-code/2021-02-16-torsion-angle-scans-xtb/2021-02-16-torsion-angle-scans-xtb.html#dihedral-scan-with-rdkit",
    "title": "Torsion angle scan with rdkit & xtb",
    "section": "Dihedral scan with rdkit",
    "text": "Dihedral scan with rdkit\nI don’t really know why, but I started out with this molecule here:\n\n\nCode\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem\nfrom rdkit.Chem import Draw\nmol=Chem.AddHs(Chem.MolFromSmiles('CCCOC1=CC=C(Cl)C(C)=C1'))\nfor i, a in enumerate(mol.GetAtoms()):\n        a.SetAtomMapNum(i)\nAllChem.EmbedMolecule(mol,randomSeed=10)    #generate an initial random conformation (randomSeed is fixed to have something reproducible)\n#mol\nDraw.MolToFile(mol,\"mol.png\",includeAtomNumbers=True,highlightAtoms=(1,2,3,4))        #sorry - rdkit 2019.03 issues with newer python versions (I guess)\n\n\n\nThe torsion angle I’m interested in is highlighted in red and situated between carbons 1,2,3 & 4. Now let’s try to set up a torsion angle scan in rdkit using MMFF (UFF should be similar procedure … )\n\nfrom rdkit.Chem import rdMolTransforms\nimport copy\nimport pandas as pd\nfrom rdkit.Chem import rdForceFieldHelpers\nfrom rdkit.Chem import ChemicalForceFields\nfrom rdkit.Chem import rdMolTransforms\n\n\nconformer=mol.GetConformer(0)\n\nm2=copy.deepcopy(mol)\nmp2 = AllChem.MMFFGetMoleculeProperties(m2)\n\nenergy=[]\nconfid=0\nangles=range(-180,182,2)\n\nprint(\"Initial angle:\")\nprint(rdMolTransforms.GetDihedralDeg(conformer,1,2,3,4))\nfor angle in angles:\n    confid+=1\n    ff2 = AllChem.MMFFGetMoleculeForceField(m2, mp2)\n    ff2.MMFFAddTorsionConstraint(1,2,3,4, False, angle - .2, angle + .2, 1000.0)\n    ff2.Minimize()\n    energy.append(ff2.CalcEnergy())\n\n    xyz=ff2.Positions()\n    new_conf = Chem.Conformer(mol.GetNumAtoms())\n    for i in range(mol.GetNumAtoms()):\n        new_conf.SetAtomPosition(i, (m2.GetConformer(-1).GetAtomPosition(i)))\n    new_conf.SetId(confid)\n    mol.AddConformer(new_conf)\n\n\ndfrdkit = pd.DataFrame({'angle':angles, 'energy':energy})\n\nInitial angle:\n179.99983170835984\n\n\n\n\nCode\n#! echo: false\nimport seaborn as sns\n\nsns.lineplot(\n    data=dfrdkit,\n    x=\"angle\", y=\"energy\",\n    markers=True, dashes=False\n)\n\n\n&lt;Axes: xlabel='angle', ylabel='energy'&gt;\n\n\n\n\n\n\nI’m printing the angle of the initial conformation here as well & start the scan from around that angle. Before I didn’t and obviously it created a lot of issues with the minimization of the subsequent conformers. Here is the plot from iwatobipen’s post on the same molecule & same torsion scan:\n\nLet’s first have a look at the minimized conformers. Here’s a bit of code to browse through them. I collected all conformations generated with the torsion scan before.\n\n\nCode\npatt = Chem.MolFromSmarts('c1ccccc1');patt\nmatch = mol.GetSubstructMatch(patt)\n\nAllChem.AlignMolConformers(mol,atomIds=match)\n\nconformerIds=[conf.GetId() for conf in mol.GetConformers()]\nw = Chem.SDWriter(\"conformers.sdf\")\nfor cid in range(mol.GetNumConformers()):\n    w.write(mol, confId=cid)\nw.close()\n\nojs_define(conformerIds=list(conformerIds))\n\n\n\n\n\n\n\nCode\nNGL=require(\"ngl@next\")\nviewof trajInput = Inputs.range([1, conformerIds.length], {value: 1, step: 1, label: \"Conformer ID\"});\nmd`Conformer ID: ${conformerIds[trajInput - 1]}`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n// Create drawing area\ndivNGLConf = html`&lt;div style=\"width:500px;height:400px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\n\n\n\nCode\ntrajPDB = {\n  let stage = new NGL.Stage(divNGLConf, {clipDist: 0.0, backgroundColor: \"black\"});\n  let pdbString = await FileAttachment(\"conformers.sdf\").blob();\n  let structure = await stage.loadFile(pdbString, {ext: \"sdf\", asTrajectory: true})\n  let traj = structure.addTrajectory().trajectory\n  structure.addRepresentation(\"licorice\");\n  structure.autoView();\n  return traj;\n};\n\n// Create function to update trajectory\nupdate_traj = function(traj, id){\n  traj.setFrame(id)\n};\n\n// Update trajectory based on slider\nupdate_traj(trajPDB, trajInput - 1);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou can use the slider above to browse through the first conformers. They look fairly reasonable to me so far.\nEven though we can observe a peak around 0° that is common between what I have here & iwatobipens post. The wells around -75° and 75° are not that easily distinguishible unfortunately."
  },
  {
    "objectID": "posts/post-with-code/2021-02-16-torsion-angle-scans-xtb/2021-02-16-torsion-angle-scans-xtb.html#dihedral-scan-with-xtb",
    "href": "posts/post-with-code/2021-02-16-torsion-angle-scans-xtb/2021-02-16-torsion-angle-scans-xtb.html#dihedral-scan-with-xtb",
    "title": "Torsion angle scan with rdkit & xtb",
    "section": "Dihedral scan with xtb",
    "text": "Dihedral scan with xtb\nXTB is a toolkit implementing semiempirical quantum mechanics and you can do quite a lot of things. Among these: energy optimization, dihedral scans, constrained optimizations, metadynamics etc…It’s conda packaged, so easy to deploy anywhere. In contrary to things like Gaussian, Jaguar etc, it’s:\n\nfree\nopensource\nactually quite fast\n\nRunning an energy optimization with xtb is rather straightforward and would work like this:\nxtb mol.sdf --opt --charge 0\nThis will write the optimized molecule in an SD file, together with the energy (in hartree).\nXTB also supports dihedral scans as described in the documentation and the examples work well on ethane. The thing is, as usual … we are not working with ethane or 1-Bromo-2-chloroethane (the other example).\nLong story short, I tried to integrate a dihedral scan as described in the documentation, but on my molecule above (which still remains rather simple)\nThis resulted in a ton of segmentation faults (fond memories of Gaussian came back to me) after a few dihedral scan cycles. My suspicion is that the xtb optimizer is not robust enough to allow to resolve really ugly clashes generated during the scan (I’m just guessing here).\nSo here’s the workaround I came up with: preparing “good enough” starting conformations with rdkit and constrained optimizing with xtb and last, gathering the final energy values.\n\n\nCode\nimport os\n# angles=range(-180,180,5)\nxtbenergy=[]\nw = Chem.SDWriter('mol.sdf')\nw.write(mol,confId=1)\nw.close()\n#loop over the previous conformations we obtained with rdkit\nfor idx,deg in enumerate(angles):\n#   Chem.MolToMolFile(mol,'molecule.mol')\n  atoms = '2,3,4,5' #set atoms to define the dihedral - NB: xtb indexes start at 1, rdkit at 0\n  # Now write the xtb input file:\n  fh = open(\"dihedral_constraint.inp\",\"w\")\n  fh.write(\"\"\"$constrain\n    force constant=1.0\n    dihedral: {},{}\n  $end\"\"\".format(atoms,float(deg)))\n  fh.close()\n  # run xtb\n  if idx==1: \n    inputfilename=\"mol.sdf\"\n  else:\n    inputfilename=\"xtbopt.sdf\"\n  os.popen(\"obabel -isdf \"+inputfilename+\" -osdf -Oobabelmol.sdf && export OMP_STACKSIZE=48G && export OMP_NUM_THREADS=12 && xtb obabelmol.sdf --opt vtight --charge 0 --input dihedral_constraint.inp\").read()\n  with open('xtbopt.sdf') as f:\n    first_line = f.readline()\n    xtbenergy.append(float(first_line.split(\"gnorm\")[0].split(\":\")[1]))\n\nprint(xtbenergy)\nprint(angles)\nprint(dfrdkit[\"energy\"])\n\nsns.lineplot(\n    data=dfrdkit,\n    x=\"angle\", y=\"energy\",\n    markers=True, dashes=False\n)\n\n\n[-36.667513607102, -36.667309140177, -36.667281342484, -36.667239620489, -36.667184526773, -36.667117066126, -36.667037048311, -36.666945068211, -36.666842035773, -36.666727935772, -36.666604060224, -36.666472299839, -36.666331713852, -36.666184708292, -36.666031740213, -36.665874503518, -36.665713626478, -36.665550482059, -36.66538825599, -36.665225539683, -36.665065448331, -36.664908207787, -36.664756200554, -36.664609973167, -36.664471049714, -36.664340711715, -36.664220117532, -36.664110543681, -36.664013292087, -36.663929734669, -36.663861827436, -36.663811930617, -36.663785358953, -36.663798737338, -36.664979277748, -36.66520794, -36.665435059634, -36.665662744478, -36.665885124937, -36.666103090883, -36.66631293046, -36.666513718719, -36.666703584448, -36.666881133011, -36.66704466986, -36.667193605558, -36.667326090946, -36.667441655993, -36.667539140451, -36.667617824736, -36.667676838596, -36.667715513415, -36.667733191444, -36.667729259909, -36.667703174391, -36.667654498956, -36.667582681905, -36.667487621575, -36.667369122472, -36.667227133502, -36.667061760273, -36.666873378488, -36.666662375664, -36.666429356721, -36.666175209343, -36.665900780799, -36.665607020687, -36.665295092731, -36.664966346322, -36.664622108195, -36.664264015668, -36.663893894368, -36.663513617705, -36.663125457688, -36.662731505843, -36.662334108898, -36.661935609452, -36.661538373839, -36.661144767473, -36.660757102954, -36.660377606895, -36.660008348515, -36.659651419864, -36.659308746758, -36.658982148344, -36.65867330741, -36.658383810707, -36.658115108876, -36.657868511125, -36.657644953523, -36.657446596701, -36.657273573907, -36.65712674186, -36.657007487457, -36.656916139656, -36.656853449108, -36.656820030572, -36.65681652035, -36.656843563867, -36.656901487252, -36.656991065908, -36.657113141754, -36.657268773622, -36.657460253667, -36.657691643264, -36.657995009871, -36.658377284791, -36.658734779587, -36.659101032723, -36.65947082494, -36.65983907601, -36.660205762865, -36.660568445789, -36.660925547559, -36.661276290406, -36.661622045455, -36.661961151255, -36.662293542142, -36.662618617756, -36.662935539654, -36.663243196539, -36.663539682536, -36.663825629787, -36.664097088781, -36.66435469442, -36.664595178208, -36.664818301433, -36.66502278909, -36.665207515844, -36.66537160691, -36.665514564786, -36.665636254032, -36.665736540925, -36.66581574069, -36.665874412542, -36.665913153582, -36.665933064251, -36.665933964303, -36.665917822483, -36.665884812253, -36.665836013797, -36.665772163003, -36.665693615985, -36.665604836221, -36.665503223322, -36.665391578063, -36.665270323778, -36.665142434253, -36.665007952167, -36.664869075563, -36.664728209023, -36.664586960773, -36.664449514058, -36.664316973593, -36.664201080863, -36.664966618261, -36.665079218636, -36.665198049586, -36.665324534034, -36.665457378424, -36.665594877696, -36.665735947942, -36.665879336208, -36.666023480717, -36.666167690138, -36.666309918055, -36.666449518595, -36.666584866403, -36.666714785838, -36.666838170524, -36.666953893713, -36.667061007153, -36.667158583164, -36.667245753906, -36.667321770371, -36.667385989984, -36.667437794223, -36.667476728724, -36.667502584037, -36.667514883009, -36.667513577254]\nrange(-180, 182, 2)\n0      19.936138\n1      19.942480\n2      19.958324\n3      19.989942\n4      20.018098\n         ...    \n176    19.900734\n177    19.870128\n178    19.849113\n179    19.837853\n180    19.835944\nName: energy, Length: 181, dtype: float64\n\n\n&lt;Axes: xlabel='angle', ylabel='energy'&gt;\n\n\n\n\n\nThis runs for a while, but it’s still reasonably fast. Also, you might have noticed that I specified an argument to the --opt flag. This argument allows you to tweak how loose or precise the optimisation should be. More information on that can be found in the xtb documentation here. In this example I specified a rather precise method. Feel free to play around with them and check the outcome (rather interesting as well).\n\nimport numpy as np\n# angle=np.array(range(180,-180,-1))\n\ndfxtb = pd.DataFrame({'angle':angles, 'xtb':xtbenergy,'MMFF':dfrdkit[\"energy\"]})\n# dfxtb = pd.DataFrame({'angle':angles, 'xtb':xtbenergy})\n\nimport matplotlib.pyplot as plt\nsns.lineplot(x=\"angle\",y=\"xtb\",data=dfxtb, color=\"g\")\nax2 = plt.twinx()\nsns.lineplot(x=\"angle\",y=\"MMFF\",data=dfxtb, color=\"b\", ax=ax2)\n\n&lt;Axes: xlabel='angle', ylabel='MMFF'&gt;\n\n\n\n\n\nOn this plot we can see both results, from rdkit’s MMFF implementation and xtb. Good news…at least they agree on the maximum around 0°. Other than that there are quite important discrepancies on the location of the global minimum and the importance & extent of the energy barriers between them. Interestingly, openFF and ani2 also predict 180° as a global minimum."
  },
  {
    "objectID": "posts/post-with-code/2021-02-16-torsion-angle-scans-xtb/2021-02-16-torsion-angle-scans-xtb.html#comparing-vs-cod",
    "href": "posts/post-with-code/2021-02-16-torsion-angle-scans-xtb/2021-02-16-torsion-angle-scans-xtb.html#comparing-vs-cod",
    "title": "Torsion angle scan with rdkit & xtb",
    "section": "Comparing vs COD",
    "text": "Comparing vs COD\nLet’s double check these results now with the initial work done on the COD (not yet cleaned and curated - so there will be some noise in here still). This is for sure not the only experimental data-source one should use, but I’ll define it as my golden source of truth here within the scope of this post. First I’ll try to identify the smarts patterns from the torsion library that match the dihedral under investigation here:\n\npatterns=pd.read_table(\"list_torsion_patterns.txt\",header=None,usecols=[1])\nselectedPatterns=[]\nfor torsionSmarts in patterns[1]:\n    torsionQuery = Chem.MolFromSmarts(torsionSmarts)\n    matches = mol.GetSubstructMatches(torsionQuery)\n    if(len(matches)&gt;0):\n        if (matches==((1,2,3,4),)):\n            selectedPatterns.append(torsionQuery)\n            print(\"selected: \",torsionSmarts)\n\nselected:  [C:1][CX4H2:2]!@;-[OX2:3][c:4]\nselected:  [!#1:1][CX4H2:2]!@;-[OX2:3][c:4]\nselected:  [C:1][CX4H2:2]!@;-[OX2:3][!#1:4]\nselected:  [!#1:1][CX4H2:2]!@;-[OX2:3][!#1:4]\nselected:  [!#1:1][CX4:2]!@;-[OX2:3][!#1:4]\n\n\nNow we have the selected patterns, let’s run these through the prepared COD molecules (a huge local sd file right now) and gather statistics on angles. NB: the smart patterns used here might be redundant and map the same molecules. So here I’m keeping track of which molecule was previously selected and don’t include it in a subsequent calculation anymore:\n\n\n[C:1][C&X4&H2:2]!@&-[O&X2:3][c:4]\n[!#1:1][C&X4&H2:2]!@&-[O&X2:3][c:4]\n[C:1][C&X4&H2:2]!@&-[O&X2:3][!#1:4]\n[!#1:1][C&X4&H2:2]!@&-[O&X2:3][!#1:4]\n[!#1:1][C&X4:2]!@&-[O&X2:3][!#1:4]\n\n\n[21:00:06] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:00:06] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:07] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:10] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:12] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:19] \n\n****\nPost-condition Violation\nElement '6 H' not found\nViolation occurred on line 93 in file /Users/runner/miniforge3/conda-bld/rdkit_1678104751770/work/Code/GraphMol/PeriodicTable.h\nFailed Expression: anum &gt; -1\n****\n\n[21:00:19] ERROR: Element '6 H' not found\n[21:00:19] ERROR: moving to the beginning of the next molecule\n[21:00:19] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:00:21] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:00:26] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:00:31] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:00:37] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:44] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:58] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:01:06] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:01:06] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:01:06] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:01:07] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:01:07] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:01:07] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:01:11] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:01:16] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:01:20] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:01:20] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:01:20] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:01:21] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:01:57] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:02:13] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:02:29] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:02:29] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:02:29] Conflicting single bond directions around double bond at index 5.\n[21:02:29]   BondStereo set to STEREONONE and single bond directions set to NONE.\n[21:02:31] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:02:36] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:02:46] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:02:47] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:02:48] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:02:51] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:02:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:01] \n\n****\nPost-condition Violation\nElement '6 H' not found\nViolation occurred on line 93 in file /Users/runner/miniforge3/conda-bld/rdkit_1678104751770/work/Code/GraphMol/PeriodicTable.h\nFailed Expression: anum &gt; -1\n****\n\n[21:03:01] ERROR: Element '6 H' not found\n[21:03:01] ERROR: moving to the beginning of the next molecule\n[21:03:02] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:03:04] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:03:10] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:03:14] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:03:22] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:30] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:36] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:36] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:36] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:36] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:36] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:36] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:36] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:45] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:54] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:03:55] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:55] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:59] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:04:05] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:04:09] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:04:09] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:04:09] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:04:10] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:04:49] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:05:04] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:05:21] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:05:22] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:05:22] Conflicting single bond directions around double bond at index 5.\n[21:05:22]   BondStereo set to STEREONONE and single bond directions set to NONE.\n[21:05:23] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:05:29] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:05:39] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:05:40] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:05:41] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:05:44] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:05:47] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:05:55] \n\n****\nPost-condition Violation\nElement '6 H' not found\nViolation occurred on line 93 in file /Users/runner/miniforge3/conda-bld/rdkit_1678104751770/work/Code/GraphMol/PeriodicTable.h\nFailed Expression: anum &gt; -1\n****\n\n[21:05:55] ERROR: Element '6 H' not found\n[21:05:55] ERROR: moving to the beginning of the next molecule\n[21:05:55] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:05:58] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:06:04] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:06:09] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:06:17] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:27] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:34] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:34] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:34] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:34] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:34] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:34] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:34] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:44] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:54] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:06:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:59] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:07:06] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:07:10] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:07:10] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:07:10] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:07:11] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:07:55] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:08:14] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:08:34] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:08:35] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:08:35] Conflicting single bond directions around double bond at index 5.\n[21:08:35]   BondStereo set to STEREONONE and single bond directions set to NONE.\n[21:08:37] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:08:43] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:08:56] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:08:57] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:08:58] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:09:02] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:09:05] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:09:14] \n\n****\nPost-condition Violation\nElement '6 H' not found\nViolation occurred on line 93 in file /Users/runner/miniforge3/conda-bld/rdkit_1678104751770/work/Code/GraphMol/PeriodicTable.h\nFailed Expression: anum &gt; -1\n****\n\n[21:09:14] ERROR: Element '6 H' not found\n[21:09:14] ERROR: moving to the beginning of the next molecule\n[21:09:15] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:09:17] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:09:25] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:09:32] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:09:42] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:09:52] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:01] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:01] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:01] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:01] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:01] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:01] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:01] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:12] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:23] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:23] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:23] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:24] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:10:24] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:24] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:29] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:36] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:41] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:41] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:41] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:42] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:11:30] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:11:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:12:11] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:12:12] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:12:12] Conflicting single bond directions around double bond at index 5.\n[21:12:12]   BondStereo set to STEREONONE and single bond directions set to NONE.\n[21:12:14] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:12:21] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:12:33] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:12:34] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:12:36] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:12:40] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:12:43] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:12:54] \n\n****\nPost-condition Violation\nElement '6 H' not found\nViolation occurred on line 93 in file /Users/runner/miniforge3/conda-bld/rdkit_1678104751770/work/Code/GraphMol/PeriodicTable.h\nFailed Expression: anum &gt; -1\n****\n\n[21:12:54] ERROR: Element '6 H' not found\n[21:12:54] ERROR: moving to the beginning of the next molecule\n[21:12:55] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:12:58] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:13:07] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:13:14] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:13:27] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:13:37] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:13:47] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:13:47] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:13:47] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:13:47] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:13:47] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:13:47] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:13:47] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:13:59] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:14:11] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:14:11] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:14:11] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:14:11] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:14:12] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:14:12] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:14:17] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:14:25] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:14:30] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:14:30] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:14:31] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:14:32] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:15:26] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:15:49] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:16:14] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:16:14] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:16:14] Conflicting single bond directions around double bond at index 5.\n[21:16:14]   BondStereo set to STEREONONE and single bond directions set to NONE.\n[21:16:17] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:16:24] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n\n\nThis runs again for quite some time…so patience is needed. Once this is done, you should see something like that:\n\n#lets convert that to numbers we show in the line-plot together with the previous results\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nangles=range(-180,182,2)\nintervals=pd.interval_range(start=-180, end=180,periods=181)\nbinangles=pd.cut(angles, bins=intervals).value_counts()\n\ndfall = pd.DataFrame({'angle':angles, 'xtb':xtbenergy,'MMFF':dfrdkit[\"energy\"],'cod':np.array(binangles)})\n\nfig, ax = plt.subplots()\nsns.histplot(codangles)\nax.set(xlabel='Angle',ylabel= 'Count')\nax2 = ax.twinx()\nsns.lineplot(x=\"angle\",y=\"xtb\",data=dfall, color=\"g\")\n\n&lt;Axes: xlabel='angle', ylabel='xtb'&gt;\n\n\n\n\n\nSo here we have in blue the results from the COD, in green xtb. Good news is that the positions of the wells seem to be estimated rather well with xtb. MMFF seems slightly off for the preference on 280°. Analysing relative energy differences between local minima, xtb doesn’t follow the trend observed using MMFF & results from the COD here."
  },
  {
    "objectID": "posts/post-with-code/2021-02-16-torsion-angle-scans-xtb/2021-02-16-torsion-angle-scans-xtb.html#conclusion",
    "href": "posts/post-with-code/2021-02-16-torsion-angle-scans-xtb/2021-02-16-torsion-angle-scans-xtb.html#conclusion",
    "title": "Torsion angle scan with rdkit & xtb",
    "section": "Conclusion",
    "text": "Conclusion\nInitially I wanted to run this on a larger set of molecules, but as usual things turn out to be much less robust than anticipated. So more to come in an upcoming post, on other torsion angles - especially the challenging ones.\nThe encouraging aspect here is, that despite all difficulties, one could potentially use this on a larger set of molecules. The instability of xtb on the integrated dihedral scan should be investigated a bit further as well … essentially to make sure that this is not only due to my totally “noob” use of the toolkit - which is very likely."
  },
  {
    "objectID": "posts/post-with-code/2021-01-23-grafting-fragments/2021-01-23-grafting-fragments.html",
    "href": "posts/post-with-code/2021-01-23-grafting-fragments/2021-01-23-grafting-fragments.html",
    "title": "Grafting fragments onto molecules in rdkit - babysteps",
    "section": "",
    "text": "In this quick walkthrough I describe the first steps to attach fragments from a fragment library onto a molecule of interest. The main idea here is to prepare code snippets for the integration of all of this into the web-based 3d-editor project I started with Daniel Alvarez some time ago. As I’m learning a lot of new things about rdkit I prefer to write it up here, as I found most of the relevant information in the mailing list & the rdkit documentation.\n\n\nI’ll go for the same molecule as the one used for now in our BRD4 structure of the 3d editor project - that just comes from one of the official openforcefield examples here.\n\n\n\nI wanted to go for something easy for now … so let’s start with a methyl group ;) I made a quick shoutout on twitter on current available 3D fragments that could be helpful to write such a sketcher. Geoff Hutchison (Mr Avogadro) gave me a great hint to this library here. It contains way more fragments than I’d initially considered for this project and the coordinates seem reasonable & compatible with the systems we’ll manage in the 3d-editor.\nSo I just took the methane from there (for now), ran it through Marvinsketch to replace one of the protons with an R group and then exported the whole thing as mol file (to the best of my knowledge rdkit doesn’t support the chemistry markup language yet).\n\n\n\n\n\nCode\n# https://sourceforge.net/p/rdkit/mailman/message/34922663/ procedure extracted from this support request\nimport rdkit\nfrom rdkit import Chem\nfrom rdkit.Chem.Draw import IPythonConsole\nfrom rdkit.Chem import Draw\nIPythonConsole.ipython_useSVG=True \nfrom rdkit.Chem import AllChem\nimport copy\nfrom rdkit.Chem.rdMolAlign import AlignMol\n\n\nBelow, the molecule we want to add the methyl group to. We’ll attach it on the triazole ring.\n\n\nCode\n// Create drawing area\ndiv_mol = html`&lt;div style=\"width:400px;height:400px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\n\n\n\nCode\nNGL = require(\"ngl@next\");\n\n   molBlock = await FileAttachment(\"ligand.sdf\").blob();\n\nstage = new NGL.Stage(div_mol, { backgroundColor: \"black\",cameraType: \"orthographic\"});\nstructure = await stage.loadFile(molBlock, {ext: \"sdf\", asTrajectory: false})\nstructure.addRepresentation(\"licorice\",{ \"sele\": \"all\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nstructure.autoView();\n\n\n\n\n\n\n\n\n\nAs the aim is to integrate that into the 3D-editor, the user ultimately will be able to click on the proton where he wants to place the fragment. Thus, we know which exact atom we want to attach it to. Below I’m determining this showing plain atom indices in the rdkit molecule\n\nsuppl = Chem.SDMolSupplier('ligand.sdf',removeHs=False)\nfor mol in suppl:\n    mblock = Chem.MolToMolBlock(mol)\n\nfor atom in mol.GetAtoms():\n        atom.SetAtomMapNum(atom.GetIdx())\nmol2d=copy.deepcopy(mol)\nAllChem.Compute2DCoords(mol2d)    #do this on a copy here\n\nDraw.MolToImage(mol2d, includeAtomNumbers=True)\n\n\n\n\nNext I’m loading the fragment and extract the position of the R-group and the connected atom as atom indices (I’ll need that later). I know this is very limited and ugly for now, but it serves the purpose here & now ;)\n\ndef getAttachmentVector(mol):\n    \"\"\" for a fragment to add, search for the position of the attachment point and extract the atom id's of the attachment point and the connected atom (currently only single bond supported)\n    mol: fragment passed as rdkit molecule\n    return: tuple (atom indices)\n    \"\"\"\n\n    rindex=-1\n    rindexNeighbor=-1\n    for atom in mol.GetAtoms():\n        if(atom.GetAtomicNum()==0):\n            rindex=atom.GetIdx()\n            neighbours=atom.GetNeighbors()\n            if(len(neighbours)==1):\n                rindexNeighbor=neighbours[0].GetIdx()\n            else: \n                print(\"two attachment points not supported yet\")\n                return None\n    return((rindex,rindexNeighbor))\n\n\n\nfragment=Chem.MolFromMolFile('methyl.mol',removeHs=False)\nret=getAttachmentVector(fragment)\n\nfor atom in mol.GetAtoms():\n        atom.SetAtomMapNum(atom.GetIdx())\nif(ret):\n    fragIndex1,fragIndex2=ret\n\nprint(fragIndex1, fragIndex2)\nChem.MolToMolFile(fragment,\"molblock.mol\")\n\n4 1\n\n\n\n\nCode\n// Create drawing area\ndiv_mol_2 = html`&lt;div style=\"width:400px;height:400px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\n\n\n\nCode\nmolBlock2 = await FileAttachment(\"molblock.mol\").blob();\nstage2 = new NGL.Stage(div_mol_2, { backgroundColor: \"black\",cameraType: \"orthographic\"});\nstructure2 = await stage2.loadFile(molBlock2, {ext: \"sdf\", asTrajectory: false})\nstructure2.addRepresentation(\"licorice\",{ \"sele\": \"all\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nstructure2.autoView();\n\n\n\n\n\n\n\n\n\nNow let’s extract also the atom index of the proton, and also the carbon the proton is attached to on the molecule.\n\nqueryAtomIndex=20 #defined by clicking on an atom in the sketcher -&gt; needs to be a proton right now for grafting\n\natom=mol.GetAtomWithIdx(queryAtomIndex)\nneighbours=atom.GetNeighbors()\nif(len(neighbours)==1):\n    rindexNeighbor=neighbours[0].GetIdx()\nelse: \n    print(\"two attachment points not supported yet\")\n    \nmolIndex1=queryAtomIndex\nmolIndex2=rindexNeighbor\nprint(molIndex1,molIndex2)\n\n20 9\n\n\n\n\n\nNow I have the bond of the carbon to proton selected in the molecule and the carbon to R-group in my fragment. These bonds can be aligned onto each other to position the 3D-fragment correctly versus the molecule. This can be conveniently done using the AlignMol function available in rdkit.\n\nAlignMol(fragment,mol,atomMap=((fragIndex2,molIndex1),(fragIndex1,molIndex2))) #important to specify the atomMap here, this aligns only the bonds\n\n0.02749767976054038\n\n\n\n\nCode\n#the rest is just to display things here\nChem.MolToMolFile(mol,\"molblock3.mol\")\nChem.MolToMolFile(fragment,\"fragblock3.mol\")\n\n\n\n\nCode\n// Create drawing area\ndiv_mol_3 = html`&lt;div style=\"width:400px;height:400px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\n\n\n\nCode\nmolBlock3 = await FileAttachment(\"molblock3.mol\").blob();\nfragBlock3 = await FileAttachment(\"fragblock3.mol\").blob();\nstage3 = new NGL.Stage(div_mol_3, { backgroundColor: \"black\",cameraType: \"orthographic\"});\nsmol3=await stage3.loadFile(molBlock3, {ext: \"sdf\", asTrajectory: false});\nsmol3.addRepresentation(\"licorice\",{ \"sele\": \"all\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nsfrag3=await stage3.loadFile(fragBlock3, {ext: \"sdf\", asTrajectory: false});\nsfrag3.addRepresentation(\"licorice\",{ \"sele\": \"all\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nsfrag3.autoView();\n\n\n\n\n\n\n\n\n\nAs you can see, the fragment gets placed correctly on top of the proton. Now we have however a few overlapping atoms in place. We can use the rdkit edition functions to address this and combine both overlapping molecules now into a final single molecule.\n\ndef connectMols(mol1, mol2, atom1, atom2):\n        \"\"\"function copied from here https://github.com/molecularsets/moses/blob/master/moses/baselines/combinatorial.py\"\"\"\n        combined = Chem.CombineMols(mol1, mol2)\n        emol = Chem.EditableMol(combined)\n        neighbor1_idx = atom1.GetNeighbors()[0].GetIdx()\n        neighbor2_idx = atom2.GetNeighbors()[0].GetIdx()\n        atom1_idx = atom1.GetIdx()\n        atom2_idx = atom2.GetIdx()\n        bond_order = atom2.GetBonds()[0].GetBondType()\n        emol.AddBond(neighbor1_idx,\n                     neighbor2_idx + mol1.GetNumAtoms(),\n                     order=bond_order)\n        emol.RemoveAtom(atom2_idx + mol1.GetNumAtoms())\n        emol.RemoveAtom(atom1_idx)\n        mol = emol.GetMol()\n        return mol \n\nfinalMol=connectMols(mol,fragment,mol.GetAtomWithIdx(molIndex1),fragment.GetAtomWithIdx(fragIndex1))\nChem.SanitizeMol(finalMol)\n\nrdkit.Chem.rdmolops.SanitizeFlags.SANITIZE_NONE\n\n\n\n\nCode\n#the rest is just to display things here\nChem.MolToMolFile(finalMol,\"finalmol.mol\")\n\n\n\n\nCode\n// Create drawing area\ndiv_mol_4 = html`&lt;div style=\"width:400px;height:400px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\n\n\n\nCode\nmolBlock4 = await FileAttachment(\"finalmol.mol\").blob();\nstage4 = new NGL.Stage(div_mol_4, { backgroundColor: \"black\",cameraType: \"orthographic\"});\nfinalmol=await stage4.loadFile(molBlock4, {ext: \"sdf\", asTrajectory: false});\nfinalmol.addRepresentation(\"licorice\",{ \"sele\": \"all\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nfinalmol.autoView();\n\n\n\n\n\n\n\n\n\nAnd voilà. Our methyl is nicely placed and oriented. That’s one of the easiest cases and we’ll have to consider torsion angles & protein environment at a later stage as well, but this should provide first basic steps for simple additions like the one done here."
  },
  {
    "objectID": "posts/post-with-code/2021-01-23-grafting-fragments/2021-01-23-grafting-fragments.html#context",
    "href": "posts/post-with-code/2021-01-23-grafting-fragments/2021-01-23-grafting-fragments.html#context",
    "title": "Grafting fragments onto molecules in rdkit - babysteps",
    "section": "",
    "text": "In this quick walkthrough I describe the first steps to attach fragments from a fragment library onto a molecule of interest. The main idea here is to prepare code snippets for the integration of all of this into the web-based 3d-editor project I started with Daniel Alvarez some time ago. As I’m learning a lot of new things about rdkit I prefer to write it up here, as I found most of the relevant information in the mailing list & the rdkit documentation.\n\n\nI’ll go for the same molecule as the one used for now in our BRD4 structure of the 3d editor project - that just comes from one of the official openforcefield examples here.\n\n\n\nI wanted to go for something easy for now … so let’s start with a methyl group ;) I made a quick shoutout on twitter on current available 3D fragments that could be helpful to write such a sketcher. Geoff Hutchison (Mr Avogadro) gave me a great hint to this library here. It contains way more fragments than I’d initially considered for this project and the coordinates seem reasonable & compatible with the systems we’ll manage in the 3d-editor.\nSo I just took the methane from there (for now), ran it through Marvinsketch to replace one of the protons with an R group and then exported the whole thing as mol file (to the best of my knowledge rdkit doesn’t support the chemistry markup language yet).\n\n\n\n\n\nCode\n# https://sourceforge.net/p/rdkit/mailman/message/34922663/ procedure extracted from this support request\nimport rdkit\nfrom rdkit import Chem\nfrom rdkit.Chem.Draw import IPythonConsole\nfrom rdkit.Chem import Draw\nIPythonConsole.ipython_useSVG=True \nfrom rdkit.Chem import AllChem\nimport copy\nfrom rdkit.Chem.rdMolAlign import AlignMol\n\n\nBelow, the molecule we want to add the methyl group to. We’ll attach it on the triazole ring.\n\n\nCode\n// Create drawing area\ndiv_mol = html`&lt;div style=\"width:400px;height:400px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\n\n\n\nCode\nNGL = require(\"ngl@next\");\n\n   molBlock = await FileAttachment(\"ligand.sdf\").blob();\n\nstage = new NGL.Stage(div_mol, { backgroundColor: \"black\",cameraType: \"orthographic\"});\nstructure = await stage.loadFile(molBlock, {ext: \"sdf\", asTrajectory: false})\nstructure.addRepresentation(\"licorice\",{ \"sele\": \"all\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nstructure.autoView();\n\n\n\n\n\n\n\n\n\nAs the aim is to integrate that into the 3D-editor, the user ultimately will be able to click on the proton where he wants to place the fragment. Thus, we know which exact atom we want to attach it to. Below I’m determining this showing plain atom indices in the rdkit molecule\n\nsuppl = Chem.SDMolSupplier('ligand.sdf',removeHs=False)\nfor mol in suppl:\n    mblock = Chem.MolToMolBlock(mol)\n\nfor atom in mol.GetAtoms():\n        atom.SetAtomMapNum(atom.GetIdx())\nmol2d=copy.deepcopy(mol)\nAllChem.Compute2DCoords(mol2d)    #do this on a copy here\n\nDraw.MolToImage(mol2d, includeAtomNumbers=True)\n\n\n\n\nNext I’m loading the fragment and extract the position of the R-group and the connected atom as atom indices (I’ll need that later). I know this is very limited and ugly for now, but it serves the purpose here & now ;)\n\ndef getAttachmentVector(mol):\n    \"\"\" for a fragment to add, search for the position of the attachment point and extract the atom id's of the attachment point and the connected atom (currently only single bond supported)\n    mol: fragment passed as rdkit molecule\n    return: tuple (atom indices)\n    \"\"\"\n\n    rindex=-1\n    rindexNeighbor=-1\n    for atom in mol.GetAtoms():\n        if(atom.GetAtomicNum()==0):\n            rindex=atom.GetIdx()\n            neighbours=atom.GetNeighbors()\n            if(len(neighbours)==1):\n                rindexNeighbor=neighbours[0].GetIdx()\n            else: \n                print(\"two attachment points not supported yet\")\n                return None\n    return((rindex,rindexNeighbor))\n\n\n\nfragment=Chem.MolFromMolFile('methyl.mol',removeHs=False)\nret=getAttachmentVector(fragment)\n\nfor atom in mol.GetAtoms():\n        atom.SetAtomMapNum(atom.GetIdx())\nif(ret):\n    fragIndex1,fragIndex2=ret\n\nprint(fragIndex1, fragIndex2)\nChem.MolToMolFile(fragment,\"molblock.mol\")\n\n4 1\n\n\n\n\nCode\n// Create drawing area\ndiv_mol_2 = html`&lt;div style=\"width:400px;height:400px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\n\n\n\nCode\nmolBlock2 = await FileAttachment(\"molblock.mol\").blob();\nstage2 = new NGL.Stage(div_mol_2, { backgroundColor: \"black\",cameraType: \"orthographic\"});\nstructure2 = await stage2.loadFile(molBlock2, {ext: \"sdf\", asTrajectory: false})\nstructure2.addRepresentation(\"licorice\",{ \"sele\": \"all\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nstructure2.autoView();\n\n\n\n\n\n\n\n\n\nNow let’s extract also the atom index of the proton, and also the carbon the proton is attached to on the molecule.\n\nqueryAtomIndex=20 #defined by clicking on an atom in the sketcher -&gt; needs to be a proton right now for grafting\n\natom=mol.GetAtomWithIdx(queryAtomIndex)\nneighbours=atom.GetNeighbors()\nif(len(neighbours)==1):\n    rindexNeighbor=neighbours[0].GetIdx()\nelse: \n    print(\"two attachment points not supported yet\")\n    \nmolIndex1=queryAtomIndex\nmolIndex2=rindexNeighbor\nprint(molIndex1,molIndex2)\n\n20 9\n\n\n\n\n\nNow I have the bond of the carbon to proton selected in the molecule and the carbon to R-group in my fragment. These bonds can be aligned onto each other to position the 3D-fragment correctly versus the molecule. This can be conveniently done using the AlignMol function available in rdkit.\n\nAlignMol(fragment,mol,atomMap=((fragIndex2,molIndex1),(fragIndex1,molIndex2))) #important to specify the atomMap here, this aligns only the bonds\n\n0.02749767976054038\n\n\n\n\nCode\n#the rest is just to display things here\nChem.MolToMolFile(mol,\"molblock3.mol\")\nChem.MolToMolFile(fragment,\"fragblock3.mol\")\n\n\n\n\nCode\n// Create drawing area\ndiv_mol_3 = html`&lt;div style=\"width:400px;height:400px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\n\n\n\nCode\nmolBlock3 = await FileAttachment(\"molblock3.mol\").blob();\nfragBlock3 = await FileAttachment(\"fragblock3.mol\").blob();\nstage3 = new NGL.Stage(div_mol_3, { backgroundColor: \"black\",cameraType: \"orthographic\"});\nsmol3=await stage3.loadFile(molBlock3, {ext: \"sdf\", asTrajectory: false});\nsmol3.addRepresentation(\"licorice\",{ \"sele\": \"all\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nsfrag3=await stage3.loadFile(fragBlock3, {ext: \"sdf\", asTrajectory: false});\nsfrag3.addRepresentation(\"licorice\",{ \"sele\": \"all\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nsfrag3.autoView();\n\n\n\n\n\n\n\n\n\nAs you can see, the fragment gets placed correctly on top of the proton. Now we have however a few overlapping atoms in place. We can use the rdkit edition functions to address this and combine both overlapping molecules now into a final single molecule.\n\ndef connectMols(mol1, mol2, atom1, atom2):\n        \"\"\"function copied from here https://github.com/molecularsets/moses/blob/master/moses/baselines/combinatorial.py\"\"\"\n        combined = Chem.CombineMols(mol1, mol2)\n        emol = Chem.EditableMol(combined)\n        neighbor1_idx = atom1.GetNeighbors()[0].GetIdx()\n        neighbor2_idx = atom2.GetNeighbors()[0].GetIdx()\n        atom1_idx = atom1.GetIdx()\n        atom2_idx = atom2.GetIdx()\n        bond_order = atom2.GetBonds()[0].GetBondType()\n        emol.AddBond(neighbor1_idx,\n                     neighbor2_idx + mol1.GetNumAtoms(),\n                     order=bond_order)\n        emol.RemoveAtom(atom2_idx + mol1.GetNumAtoms())\n        emol.RemoveAtom(atom1_idx)\n        mol = emol.GetMol()\n        return mol \n\nfinalMol=connectMols(mol,fragment,mol.GetAtomWithIdx(molIndex1),fragment.GetAtomWithIdx(fragIndex1))\nChem.SanitizeMol(finalMol)\n\nrdkit.Chem.rdmolops.SanitizeFlags.SANITIZE_NONE\n\n\n\n\nCode\n#the rest is just to display things here\nChem.MolToMolFile(finalMol,\"finalmol.mol\")\n\n\n\n\nCode\n// Create drawing area\ndiv_mol_4 = html`&lt;div style=\"width:400px;height:400px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\n\n\n\nCode\nmolBlock4 = await FileAttachment(\"finalmol.mol\").blob();\nstage4 = new NGL.Stage(div_mol_4, { backgroundColor: \"black\",cameraType: \"orthographic\"});\nfinalmol=await stage4.loadFile(molBlock4, {ext: \"sdf\", asTrajectory: false});\nfinalmol.addRepresentation(\"licorice\",{ \"sele\": \"all\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nfinalmol.autoView();\n\n\n\n\n\n\n\n\n\nAnd voilà. Our methyl is nicely placed and oriented. That’s one of the easiest cases and we’ll have to consider torsion angles & protein environment at a later stage as well, but this should provide first basic steps for simple additions like the one done here."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spinning coral",
    "section": "",
    "text": "Forced revamp ongoing\n\n\n\nnews\n\n\n\n\n\n\n\nPeter Schmidtke\n\n\nApr 8, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBinding Site Comparison Benchmarks - I - Binding sites on the same protein\n\n\n\nbinding site\n\n\npocket\n\n\ncavity\n\n\npocket comparison\n\n\nstructure-based drug design\n\n\n\nFirst post in a row on setting up a proper benchmark dataset for binding site comparison algorithm evaluation.\n\n\n\nPeter Schmidtke\n\n\nApr 3, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBinding site comparison - current benchmark issues\n\n\n\nbinding site\n\n\npocket\n\n\ncavity\n\n\npocket comparison\n\n\nstructure-based drug design\n\n\n\nA (long) comment on current pitfalls on binding site comparison papers & their benchmarking\n\n\n\n\n\n\nNov 7, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTorsion angle scan with rdkit & xtb\n\n\n\ntorsion\n\n\ndihedral\n\n\noss\n\n\nopensource\n\n\nrdkit\n\n\nxtb\n\n\nenergy\n\n\n\nLog of the hassle doing torsion angle scans with rdkit & xtb - ultimately comparing results to the crystallography open database\n\n\n\nPeter Schmidtke\n\n\nFeb 16, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfpocket 4.0 - Towards biologics\n\n\n\nfpocket\n\n\npockets\n\n\ncavity\n\n\nPPI\n\n\nprotein\n\n\nepitope\n\n\nDNA\n\n\nRNA\n\n\nantibody\n\n\n\nA quick demo of all the new fpocket features with special focus on protein-peptide interfaces\n\n\n\nPeter Schmidtke\n\n\nFeb 2, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCrystallography Open Database and torsion angle statistics with rdkit\n\n\n\nrdkit\n\n\ncrystallography\n\n\nsmall molecule xray\n\n\nxray\n\n\ndatabase\n\n\n\nFirst steps to check how easy / feasible it is to extract torsion angle statistics from the COD\n\n\n\nPeter Schmidtke\n\n\nJan 25, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGrafting fragments onto molecules in rdkit - babysteps\n\n\n\nrdkit\n\n\n3d-editor\n\n\n\nThis is a quick set-up for attaching a fragment to a molecule on a particular location.\n\n\n\nPeter Schmidtke\n\n\nJan 23, 2021\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog\nDuring my everyday work I’m in contact with a lot of people supporting early stage drug discovery. During this work I use proprietary tools, but also several open source tools. Usually you face several issues a lot of other people faced before or will face in the future. One aim of this blog is to share these quirks and allow others to gain some time, trigger discussions, get feedback and improve the field as openly as possible.\nI’ll likely write about whatever crosses my mind here, but it’ll surely focus on topics around cheminformatics, bioinformatics, binding sites, maybe a few papers. Let’s see where this goes."
  },
  {
    "objectID": "about.html#about-myself",
    "href": "about.html#about-myself",
    "title": "About",
    "section": "About myself",
    "text": "About myself\nI’m a European citizen, dad of two beautiful girls and I am currently stranded in France. I did my PhD in Xavier Barril’s excellent group at the University of Barcelona, then a post-doc in molecular modelling within a French pharma company. However, I spent most of my “professional career” at Discngine based in Paris, France. A great place to work, even though we tend not to apply for these fancy marketing labels ;)\nTogether with Vincent Le Guilloux (also at Discngine now) we developed fpocket while we were still finishing our Bioinformatics Masters degree. After that I wrote a bunch of papers (during my PhD) mainly on binding site characterisation, druggability assessment, structure kinetic relationships and a couple of other things more.\nTogether with a great team at Discngine, I also started 3decision a subscription-based structure repo & analytics platform a few years back now."
  },
  {
    "objectID": "about.html#spinning-coral",
    "href": "about.html#spinning-coral",
    "title": "About",
    "section": "Spinning coral",
    "text": "Spinning coral\nThe name of the blog was inspired by my 7 years old daughter, Anna. She always wants to play with 3D molecular viewers on my screen. She started to do that when she was around 5, having no idea what a protein is and looks like she basically asks me: “Daddy, may I spin the coral again?”."
  },
  {
    "objectID": "about.html#inspirations",
    "href": "about.html#inspirations",
    "title": "About",
    "section": "Inspirations",
    "text": "Inspirations\nHaving a blog on cheminformatics etc is not the brightest and newest idea. I’ve had a lot of good reads thanks to all of these excellent & very well known blogs:\n\nhttps://iwatobipen.wordpress.com/\nhttp://practicalcheminformatics.blogspot.com/\nhttps://greglandrum.github.io/rdkit-blog/"
  },
  {
    "objectID": "wip/2023-05-10-binding-site-comparison-benchmark-II/2023-05-10-binding-site-comparison-benchmark-ii.html",
    "href": "wip/2023-05-10-binding-site-comparison-benchmark-II/2023-05-10-binding-site-comparison-benchmark-ii.html",
    "title": "Binding Site Comparison Benchmarks - II - Binding sites on the similar proteins",
    "section": "",
    "text": "The previous post of this series established a first protocol on how to identify & cluster (conformationally) the ATP binding site of the N-terminal domain of human HSP90 alpha. It can be generalized to other proteins as well but to keep it simple (it’s that simple) I’ll stick to a single protein for now and generalize at a later stage.\nIn this second post we’ll gradually extend the dataset with ATP binding sites of proteins that are very similar to the human HSP90 alpha.\n\n\nOne can adopt several ways to assess similarity between proteins. Here I’ll use a commonly understood and accepted sequence local similarity on the N-terminal domain. I’ll further assess the binding site residue conservation in detail. So at this stage of the dataset creation I’ll focus on things I’d expect to be found as very very similar to the human HSP90 alpha N-terminal domain when doing a pocket comparison. The Rognan lab discussed this topic in more than one paper. Feel free to check out Kellenberger, Schalon, and Rognan (2008) and Eguida and Rognan (2022) for more details.\n\n\n\nAgain I’ll track all things that I left aside or important approximations I made. They’ll be tracked as side-note and depending on the outcome of the whole exercise I’ll come back to them at a later stage.\n\n\nThings to keep in mind\n\nlisting goes here"
  },
  {
    "objectID": "wip/2023-05-10-binding-site-comparison-benchmark-II/2023-05-10-binding-site-comparison-benchmark-ii.html#identify-similar-sequences",
    "href": "wip/2023-05-10-binding-site-comparison-benchmark-II/2023-05-10-binding-site-comparison-benchmark-ii.html#identify-similar-sequences",
    "title": "Binding Site Comparison Benchmarks - II - Binding sites on the similar proteins",
    "section": "Identify similar sequences",
    "text": "Identify similar sequences\nUsually one what do just a simple blast! Unfortunately, things are a bit trickier. First of all, we are currently looking only at the N-terminal domain of HSP90 (around 230 amino acids). The full human HSP90 alpha protein has 732 amino acids. So, shall we search for globally similar sequences? or smaller regions?\nThe N-terminal part is considered to be a domain, so structured on itself. There are numerous structure resolution papers that show that, Sreeramulu et al. (2009) is just one of them, as an example here, where only the N-terminal domain of HSP90 is amplified, produced & resolved.\nWe could even go further and use only the range of amino acids that are involved in the ATP binding site. In the case of a small domain like this one here that might not be required, but for large domains it might be of interest to focus on the binding site only. In this example this would mean start at the glutamate 47 and go up to the valine 186 (+ maybe a few flanking residues)\nFor the sake of simplicity I’ll take the whole N-terminal domain (amino acids 9-236), corresponding to the first region of HS90A_HUMAN in the UniProt database.\n\nThe blast mess\nHere we need to find PDB structures containing a resolved portion of the domain of interest (or similar). There are unfortunately thousands of services allowing to do that, and as usual they don’t give the same results … it would be too easy otherwise. One important factor is to search against an up to date version of the RCSB PDB. The only service I found that clearly states what release of the PDB is being used is NCBI blastp page.\nI don’t want to reinvent the wheel or install blast locally etc, so here I’ll use the biotite (Kunzmann and Hamacher (2018)) integration of the NCBI blast service.\n\nimport biotite.sequence.io.fasta as fasta\nimport biotite.application.blast as blast\nfrom biotite.sequence import ProteinSequence\nimport urllib\nimport io \nimport pickle\n\nuniprotcode=\"P07900\"\nstart=9\nend=236\nurl=\"https://rest.uniprot.org/uniprotkb/\"+uniprotcode+\".fasta\"\n\nwith urllib.request.urlopen(url) as file_handle:\n  file_object = io.TextIOWrapper(file_handle)\n  fasta_file = fasta.FastaFile.read(file_object)\n  for header, seq_str in fasta_file.items():\n    seq = ProteinSequence(seq_str)\n    selected_sequence = str(seq[start:end])\n\napp = blast.BlastWebApp(\"blastp\", selected_sequence, database=\"pdb\",obey_rules=True)\napp.set_max_results(5000)\napp.set_max_expect_value(1e-30)\napp.start()\napp.join(timeout=1000)\nalignments = app.get_alignments()\nxml=app.get_xml_response()\n\n# open a file, where you ant to store the data\nfile = open('data/blasthits.pkl', 'wb')\n\n# dump information to that file\npickle.dump(xml, file)\n\n# close the file\nfile.close()\n\nHere we get all blast hits with an e-value above 1e-30 (arbitrary choice) and store the xml response in a pickled file, not to spam the NCBI service too much during writing this post 😉. It’s also very slow to run, so I’ll just load the pickled file in the next step.\n\nParse the blast results\nWe can now load the pickled results & parse them to make them a bit more workable\n\n#! eval: false\nimport pickle\nimport xml.etree.ElementTree as ET\n\n\nfile = open('data/blasthits.pkl', 'rb')\n\n# dump information to that file\nxml = pickle.load(file)\nfile.close()\n# print(xml)\nroot = ET.fromstring(xml)\nidentifiers = []\nevalues = []\nfor alignment in root.iter('Hit'):\n    identifier = alignment.find('Hit_id').text\n    # Extract the coverage\n    hsp = alignment.find('Hit_hsps/Hsp')\n    coverage = int(hsp.find('Hsp_query-to').text) / int(hsp.find('Hsp_query-from').text)\n    # Extract the percentage of identity\n    identity = float(hsp.find('Hsp_identity').text) / float(hsp.find('Hsp_align-len').text)\n\n    # Extract the e-value\n    evalue = float(hsp.find('Hsp_evalue').text)\n    identifiers.append(identifier)\n    evalues.append(evalue)\nprint(identifiers)\n\n['pdb|7LSZ|A', 'pdb|4YKQ|A', 'pdb|1UY6|A', 'pdb|2YE2|A', 'pdb|3B24|A', 'pdb|3QDD|A', 'pdb|3INW|A', 'pdb|3R4M|A', 'pdb|6TN4|AAA', 'pdb|4AWO|A', 'pdb|4EGH|A', 'pdb|2BSM|A', 'pdb|4NH7|A', 'pdb|4EEH|A', 'pdb|2XAB|A', 'pdb|2CCS|A', 'pdb|6U99|A', 'pdb|4B7P|A', 'pdb|2FWY|A', 'pdb|6LR9|A', 'pdb|1BYQ|A', 'pdb|2YE7|A', 'pdb|2XHX|A', 'pdb|6GQS|A', 'pdb|3K97|A', 'pdb|6U98|A', 'pdb|5J6L|A', 'pdb|1UYI|A', 'pdb|6OLX|A', 'pdb|8B7I|A', 'pdb|6GP4|A', 'pdb|2XJJ|A', 'pdb|1YC1|A', 'pdb|2YEE|A', 'pdb|5J82|A', 'pdb|5J6M|A', 'pdb|3BM9|A', 'pdb|3D0B|A', 'pdb|5J80|A', 'pdb|2YI0|A', 'pdb|7KRJ|A', 'pdb|5NYI|A', 'pdb|3K98|A', 'pdb|3EKO|A', 'pdb|3HHU|A', 'pdb|1OSF|A', 'pdb|5H22|A', 'pdb|2XDU|A', 'pdb|2JJC|A', 'pdb|2K5B|A', 'pdb|3TUH|A', 'pdb|6EI5|A', 'pdb|5J2X|A', 'pdb|5GGZ|A', 'pdb|4LWE|A', 'pdb|5J20|A', 'pdb|2QFO|A', 'pdb|5LR1|A', 'pdb|5LQ9|A', 'pdb|2QF6|A', 'pdb|2YJW|A', 'pdb|6N8W|A', 'pdb|3NMQ|A', 'pdb|1UYM|A', 'pdb|6N8Y|A', 'pdb|7ULJ|A', 'pdb|5UC4|A', 'pdb|7ZUB|A', 'pdb|8GAE|A', 'pdb|5FWK|A', 'pdb|7Z37|AP1', 'pdb|7ZR0|A', 'pdb|7Y04|A', 'pdb|8EOA|A', 'pdb|2JKI|A', 'pdb|4GQT|A', 'pdb|2XCM|A', 'pdb|4X9L|A', 'pdb|7K9U|A', 'pdb|7K9R|A', 'pdb|3K60|A', 'pdb|3H80|A', 'pdb|4XC0|A', 'pdb|6CJI|A', 'pdb|3O6O|A', 'pdb|3OMU|A', 'pdb|2BRE|A', 'pdb|1A4H|A', 'pdb|1AH6|A', 'pdb|2WEP|A', 'pdb|1ZW9|A', 'pdb|2YGE|A', 'pdb|2YGF|A', 'pdb|2CGF|A', 'pdb|1AMW|A', 'pdb|1AM1|A', 'pdb|2XX2|A', 'pdb|3C0E|A', 'pdb|1BGQ|A', 'pdb|2YGA|A', 'pdb|2CG9|A', 'pdb|6XLB|A', 'pdb|2AKP|A', 'pdb|3PEH|A', 'pdb|1TBW|A', 'pdb|4NH9|A', 'pdb|5IN9|A', 'pdb|1YT2|A', 'pdb|7ULL|A', 'pdb|1QY8|A', 'pdb|2ESA|A', 'pdb|2O1W|A', 'pdb|5ULS|A', 'pdb|2O1U|A', 'pdb|2IOR|A', 'pdb|1Y4S|A', 'pdb|2IOP|A', 'pdb|3IED|A', 'pdb|7C04|A', 'pdb|5F3K|A', 'pdb|5HPH|A', 'pdb|7ULK|A', 'pdb|4Z1F|A', 'pdb|6D14|A', 'pdb|4IVG|A', 'pdb|4J0B|A', 'pdb|5TVU|A', 'pdb|5TTH|B', 'pdb|4IPE|A', 'pdb|5TTH|A', 'pdb|7KCK|A', 'pdb|6XG6|A', 'pdb|7KLU|B', 'pdb|7U4C|A']\n\n\nWe end up here with 139 hits. As a reminder, when gathering all structures of the same protein we identified over 300 structures. I’m expecting them to be part of the hitlist found here. I tried to find any indication on the PDB subset used by the NCBI, but couldn’t identify whether they use the full RCSB PDB or a subset only. Anyway, this isn’t useable as such. So I optimistically tried the blast on uniprot and got even less hits. Digging into the detail I noticed that the ebi is just running an ncbi blast behind the scenes as well.\nWell that’s a bummer. I have two options here, either I expand the hitlist, by identifying all other structures encompassing the same protein as the hits I got here. But the hits aren’t unique as well per biomolecule, not sure what this corresponds to in the end. Or I’d need to basically build my own blast database locally & do everything by hand. Let me roughly outline the steps here:\nFor each PDB structure & chain:\n\nextract the expressed sequence\nadd it to a blast db file with an identifier corresponding to the pdb code + chain code\nrun the blast locally\n\n\n\nFall back to the RCSB PDB search\nThe RCSB PDB seems to offer a protein sequence search as API now. Let’s try that option instead:\n\nimport json\nimport requests\nquery=\"\"\"{\n  \"query\": {\n    \"type\": \"terminal\",\n    \"service\": \"sequence\",\n    \"parameters\": {\n      \"evalue_cutoff\": 1e-30,\n      \"identity_cutoff\": 0.1,\n      \"sequence_type\": \"protein\",\n      \"value\": \"QPMEEEEVETFAFQAEIAQLMSLIINTFYSNKEIFLRELISNSSDALDKIRYESLTDPSKLDSGKELHINLIPNKQDRTLTIVDTGIGMTKADLINNLGTIAKSGTKAFMEALQAGADISMIGQFGVGFYSAYLVAEKVTVITKHNDDEQYAWESSAGGSFTVRTDTGEPMGRGTKVILHLKEDQTEYLEERRIKEIVKKHSQFIGYPITLFVEKERDKEVSDDEAE\"\n    }\n  },\n  \"request_options\": {\n    \"results_verbosity\": \"verbose\",\n    \"scoring_strategy\": \"sequence\",\n    \"return_all_hits\": true\n  },\n  \"return_type\": \"polymer_entity\"\n}\"\"\"\n\n\nurl=\"https://search.rcsb.org/rcsbsearch/v2/query?json=\"+query\nresponse=requests.get(url)\nhits=json.loads(response.text)[\"result_set\"]\nprint(hits[0])\n\nHere we get all structures (510 hits by the time I’m writing this) & even a bit more information which portion of the input sequence hit where on the structure. Now let’s start meddling with the sequence mess and integrate already all the clustering bits we did in the previous post.\n\n\n\nClustering the similar binding sites\n\n\nCode\nimport gemmi\nfrom gemmi import cif\nimport urllib\nimport numpy as np\nfrom scipy.spatial.distance import cdist\nimport scipy.spatial.distance as ssd\nimport scipy\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport blosum\nsubst_matrix = blosum.BLOSUM(62)\n\n\n\n\nCode\n#get all polymer identifiers from previous results\npolymer_identifiers=[hit[\"identifier\"] for hit in hits]\n\n#now let's build another graphql query against the rcsb to get the author defined chain names of the structures that correspond to the polymer identified. \nquery=\"\"\"\n{\n  polymer_entities(entity_ids: \"\"\"+str(polymer_identifiers).replace(\"'\",\"\\\"\")+\"\"\")\n  {\n    rcsb_id\n    rcsb_polymer_entity_container_identifiers {\n      auth_asym_ids\n    }\n    rcsb_polymer_entity_align{\n      reference_database_name\n            aligned_regions{\n              entity_beg_seq_id\n              length\n              ref_beg_seq_id\n            }\n    }\n  }\n}\n\"\"\"\nurl=f\"https://data.rcsb.org/graphql?query={query}\"\nresponse=requests.get(url)\nchains_tmp=response.json()[\"data\"][\"polymer_entities\"]\n\n#here we know what polymer id corresponds to what chain name\nchain_polymer_mapping={chain[\"rcsb_id\"]:chain[\"rcsb_polymer_entity_container_identifiers\"][\"auth_asym_ids\"] for chain in chains_tmp}\n\n#From our blast hits, let's keep only the sequence matching bits to simplify the object a bit:\nclean_hits={hit[\"identifier\"]:hit[\"services\"][0][\"nodes\"][0][\"match_context\"][0] for hit in hits}\n\n#Let's get our ATP binding site residue list mapping from our initial sequence: \nresidue_list=np.array([47,48,51,52,54,55,58,93,95,96,97,98,106,107,112,131,132,133,134,135,136,137,138,139,152,183,184,186])-9\n\n#As we searched only for a chunk of the original sequences, the indices are now off by 9 amino acids. Let's adapt that: \n# residue_list=np.array(residue_list)-9\n\ndef transformResidueNumbers(residue_numbers, rcsbpolymerhit):\n  df = pd.DataFrame(columns = [\"aa_query\", \"aa_subject\", \"query_residue_number\",\"subject_residue_number\"])\n\n  currentindex=0\n  subject_aligned_seq_list=list(rcsbpolymerhit[\"subject_aligned_seq\"])\n  query_current_residue_number=rcsbpolymerhit[\"query_beg\"]\n  subject_current_residue_number=rcsbpolymerhit[\"subject_beg\"]\n  for idx,queryaa in enumerate(list(rcsbpolymerhit[\"query_aligned_seq\"])):\n    if(queryaa!='-'):\n      query_residue_number=query_current_residue_number\n      query_current_residue_number+=1\n    else: \n      query_residue_number=-1\n    if(subject_aligned_seq_list[idx]!='-'):\n      subject_residue_number=subject_current_residue_number\n      subject_current_residue_number+=1\n    else:\n      subject_residue_number=-1\n    new_row=pd.DataFrame({\"aa_query\":queryaa,\"aa_subject\":subject_aligned_seq_list[idx],\"query_residue_number\":query_residue_number,\"subject_residue_number\":subject_residue_number}, index=[0])\n    df=pd.concat([df.loc[:],new_row]).reset_index(drop=True)\n  \n  subject_residue_list=[df.loc[df['query_residue_number'] == residue_number, 'aa_subject'].values[0] for residue_number in residue_numbers]\n  return((df.loc[df['query_residue_number'].isin(residue_numbers),\"subject_residue_number\"].tolist(),subject_residue_list))\n\n\ndef getContactMatrix(pdbCode, chainCode, residueSelection, debug=False):\n  content= urllib.request.urlopen(\"https://files.rcsb.org/view/\"+pdbCode+\".cif\").read()\n\n  block=cif.read_string(content)[0]\n  structure=gemmi.make_structure_from_block(block)\n  positions=[]\n  for model in structure:\n    if model.name==\"1\":\n      for chain in model:\n        if chain.name == chainCode:\n          for residue in chain:\n            if residue.label_seq in residueSelection:\n              if debug:\n                print(residue.seqid)\n                print(residue)\n              for atom in residue:\n                if atom.name==\"CA\":\n                  if debug: print(\"ok\")\n                  positions.append(atom.pos.tolist())\n                  break #we need that for multiple occurences\n\n  if(len(positions)!=len(residueSelection)):\n    print(\"Not all positions found for \"+pdbCode+\" discarding structure\")\n    return None\n\n  positions_np=np.array(positions)\n  return cdist(positions_np, positions_np, 'euclidean')\n\n\n# create the contact matrices (CA based for now)\ncontactMatrices=[]\nresultResidueNames=[]\nselectedResidues=[]\n\n# for pdbid in ['1UYF_1']:\nfor pdbid in list(chain_polymer_mapping.keys()):\n  print(pdbid)\n  chain=chain_polymer_mapping[pdbid][0] #take only the first chain\n  pdbcode=pdbid.split(\"_\")[0]\n  tmp_result=transformResidueNumbers(residue_list,clean_hits[pdbid])\n  mapped_residues=tmp_result[0]\n  contactMatrices.append(getContactMatrix(pdbcode,chain,mapped_residues))\n  resultResidueNames.append(tmp_result[1])\n  selectedResidues.append([chain+\":\"+str(res) for res in mapped_residues])\n\n\n\nnone_indices = [ic for ic, matrix in enumerate(contactMatrices) if matrix is None]\n\nlabels=[structure.split(\"_\")[0] for structure in list(chain_polymer_mapping.keys())]\nchainCodes=[chain_polymer_mapping[structure][0] for structure in list(chain_polymer_mapping.keys())]\nfilteredContactMatrices = [matrix for i, matrix in enumerate(contactMatrices) if i not in none_indices]\nfilteredresultResidueNames = [bl for i, bl in enumerate(resultResidueNames) if i not in none_indices]\nfilteredSelectedResidues = [bl for i, bl in enumerate(selectedResidues) if i not in none_indices]\n\n\n\nfilteredLabels = [label for idx, label in enumerate(labels) if idx not in none_indices]\nfilteredChainCodes= [code for idx, code in enumerate(chainCodes) if idx not in none_indices]\nfinalList=pd.DataFrame(({\"pdbid\":filteredLabels,\"chain\":filteredChainCodes,\"residues\":filteredSelectedResidues}))\nfinalList.to_csv(\"data/finalList.tsv\",sep=\"\\t\",index=False)\n#final clustering of contact matrices\n\n\nfile = open('data/contactMatrices.pkl', 'wb')\n\n# dump information to that file\npickle.dump({\"contactMatrices\":filteredContactMatrices,\"fileredResidueNames\":filteredresultResidueNames,\"filteredLabels\":filteredLabels,\"filteredChainCodes\":filteredChainCodes,\"finalList\":finalList}, file)\n\n# close the file\nfile.close()\n\n\n\nimport numpy as np \n\ndef clusterMatrices(matrixList,selectedResidueList,blosumWeight=1.0):  \n  nMatrices=len(matrixList)\n  result=np.zeros((nMatrices,nMatrices))\n  for i in range(nMatrices):\n    for j in range(nMatrices):\n      if i==j:\n        result[i][j]=0.0\n      elif i&lt;j:\n        r1=selectedResidueList[i]\n        r2=selectedResidueList[j]\n        blosum_score=(np.array([subst_matrix[r1[idx]][r2[idx]] for idx in range(len(r1))])&lt;0.0).sum()\n        result[i][j]=np.mean(np.abs(matrixList[i]-matrixList[j]))+blosumWeight*blosum_score\n        result[j][i]=result[i][j]\n\n  distArray = ssd.squareform(result)\n  clusters=scipy.cluster.hierarchy.linkage(result, method='single', metric='euclidean')\n  return(clusters)\n\n\n\nfile = open('data/contactMatrices.pkl', 'rb')\ncontactMatrices = pickle.load(file)\nfile.close()\n\nclusters=clusterMatrices(contactMatrices[\"contactMatrices\"],contactMatrices[\"fileredResidueNames\"])\n\n\n\nplt.figure(figsize=(9, 100))\n\nscipy.cluster.hierarchy.dendrogram(clusters,labels=contactMatrices[\"filteredLabels\"],orientation='right',leaf_font_size=9,color_threshold=2.0)\nplt.show()\nFigure 1: ?(caption)\n\n\nWell that was a bit painful to set up. As usual it’s a bit tricky to get the sequence numberings right, especially when aligning structures with gaps in the underlying aligned sequences. However in the figure above now we should have a good hierarchical tree for a pure backbone geometry based comparison. The pocket comparison method we’d might want to evaluate later might make use of particular amino acids or side chain positions. Thus, I already integrated a bit of code to account for a penalty in the distance between two binding sites if unfavourable permutations were found (blosum62 score&lt;0). Feel free to adapt to whatever you need. In the current code, an unfavourable substitution of an amino acid, even if the positionn of the alpha carbon is the same is equivalent to a 1A distance.\nIn the end we get a full set of structures, HSP90 alpha human ones, and similars. Let’s check how much of our dataset established in the previous post. In theory we should be able to gather 100% of it through the approach outlined here as well.\n\n\nCode\nimport pickle\n\nfile = open('data/identicallist.pkl', 'rb')\nidentical_list = pickle.load(file)\nfile.close()\n\nsimilar_list = [contactMatrices[\"filteredLabels\"][idx]+\":\"+code for idx, code in enumerate(contactMatrices[\"filteredChainCodes\"])]\n\nintersection = np.intersect1d(identical_list, similar_list)\n\nprint(f\"{len(intersection)} common structures vs {len(similar_list)} in the similar list and {len(identical_list)} in the identical list\")\n\n\nThat’s a nice and expected outcome here. All structures identified from our previous post are found through the approach used here as well. But instead of only 295 structures, we now have a total of 477 structures with different levels of similarity between all structures."
  },
  {
    "objectID": "wip/2023-05-10-binding-site-comparison-benchmark-II/2023-05-10-binding-site-comparison-benchmark-ii.html#results",
    "href": "wip/2023-05-10-binding-site-comparison-benchmark-II/2023-05-10-binding-site-comparison-benchmark-ii.html#results",
    "title": "Binding Site Comparison Benchmarks - II - Binding sites on the similar proteins",
    "section": "Results",
    "text": "Results\nI won’t put all the raw results in a table format in HTML here, but you can get the final list of structures, chain codes & residue selections as download from here. The tsv file is structured like this:\n\nHow can this be used as benchmark dataset?\nLet’s come back to our initial problem. How can this dataset now be used to evaluate the performance of a pocket comparison method? The dataset contains information about:\n\nwhat binding site is similar to another\nto what extent the binding sites are similar (more or less similar)\n\nSo we already have a set of structures that we can in theory compare to one another an see if the binding site comparison similarity metric correlates with the similarity we considered here. We can also use the dataset to compare to structures outside of the set, a decoy set. This is in theory easy to set up but has important implications on how to evaluate a performance of a method.\nFirst let’s clean up a bit and define a function that allows us to get the most similar binding sites from our set versus a chosen query structure:\n\n\nCode\nimport itertools\n\ndef getDistanceMatrix(matrixList,selectedResidueList,blosumWeight=1.0):  \n  nMatrices=len(matrixList)\n  result=np.zeros((nMatrices,nMatrices))\n  for i in range(nMatrices):\n    for j in range(nMatrices):\n      if i==j:\n        result[i][j]=0.0\n      elif i&lt;j:\n        r1=selectedResidueList[i]\n        r2=selectedResidueList[j]\n        blosum_score=(np.array([subst_matrix[r1[idx]][r2[idx]] for idx in range(len(r1))])&lt;0.0).sum()\n        result[i][j]=np.mean(np.abs(matrixList[i]-matrixList[j]))+blosumWeight*blosum_score\n        result[j][i]=result[i][j]\n\n  return(result)\n\ndistanceMatrix=getDistanceMatrix(contactMatrices[\"contactMatrices\"],contactMatrices[\"fileredResidueNames\"])\n\nnp_similar_list=np.array(similar_list)\nsortedMatrix=[]\nfor rowid in range(0,distanceMatrix.shape[0]):\n  o=np.argsort(distanceMatrix[rowid,:])\n  np_similar_list[o]\n  sortedMatrix.append([np_similar_list[rowid],list(np.char.add(np.char.add(np_similar_list[o],\": \"),distanceMatrix[rowid,o].astype('&lt;U7')))])\n\n\nsortedMatrixDF=pd.DataFrame(sortedMatrix,columns=[\"pdbid\",\"similar structures\"])\nsortedMatrixDF.to_csv(\"data/similarityList.tsv\",sep=\"\\t\",index=False)\n\ntruncatedMatrix=[[element[0],element[1][:10]] for element in sortedMatrix[:10]]\nMarkdown(tabulate(\n  truncatedMatrix[:10],\n  headers=[\"pdbid\",\"similar structures\"]\n))\n\n\nTable ?@tbl-similarity-sample shows only the first 10 most similar structures and underlying binding sites to the binding site corresponding to the pdbid on the leftmost column.\nYou can retrieve the full list through the downloadable tsv file here: similarityList.tsv\nThis file can be used for various purposes. You can decide to reduce the dataset to reduce structural reduncany. You can also use it to train a method, parameters, scores on how similarity is defined etc.\n\nDecoys?\nIn all benchmark datasets I’ve seen so far in the litterature there’s a distinction between binding sites one should find (actives) and binding sites one shouldn’t find (decoys). I fully understand that this is rather standard procedure for similarity metric performance measurements & evaluation studies. However, in the context of binding site comparison there are on a large variety of structures (like against the PDB) things get a little bit trickier."
  },
  {
    "objectID": "wip/2023-05-10-binding-site-comparison-benchmark-II/2023-05-10-binding-site-comparison-benchmark-ii.html#assessing-ligand-similarity-in-similar-binding-sites",
    "href": "wip/2023-05-10-binding-site-comparison-benchmark-II/2023-05-10-binding-site-comparison-benchmark-ii.html#assessing-ligand-similarity-in-similar-binding-sites",
    "title": "Binding Site Comparison Benchmarks - II - Binding sites on the similar proteins",
    "section": "Assessing ligand similarity in similar binding sites",
    "text": "Assessing ligand similarity in similar binding sites\nOne interesting aspect about HSP90 is that there are a lot of structures in the RCSB. A lot of these structures have soaked or cocrystallized ligands from similar or congeneric chemical series. One other analysis (just out of curiosity) one can add here is to assess how similar the ligands binding to the very similar binding site conformations really are.\nIn order to try integrate that we first need to gather the ligands contained in the binding site encompassed by the residues selected, which aren’t ions or surfactants or water. I didn’t find a clear & easy way to get ligands contained within a given set of residues using RCSB resources, so I’ll calculate the center of mass of the binding site residues here and check against the center of mass of all ligands in the structure. Very cumbersome but should do the trick here.\n\n\nCode\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem\nfrom rdkit.Chem import rdFMCS\nfrom rdkit import DataStructs\nfrom rdkit.Chem import rdMolDescriptors\nimport seaborn as sns\nimport io\n\n\ndef getLigandHetCodeInBindingSite(pdbCode, chainCode, residueSelection, debug=False):\n  content= urllib.request.urlopen(\"https://files.rcsb.org/view/\"+pdbCode+\".cif\").read()\n  block=cif.read_string(content)[0]\n  structure=gemmi.make_structure_from_block(block)\n  positions=[]\n  hetDict={}\n  for model in structure:\n    if model.name==\"1\":\n      for chain in model:\n        if chain.name == chainCode:\n          for residue in chain:\n            if residue.label_seq in residueSelection:\n              if debug:\n                print(residue.seqid)\n                print(residue)\n              for atom in residue:\n                if atom.name==\"CA\":\n                  if debug: print(\"ok\")\n                  positions.append(atom.pos.tolist())\n                  break #we need that for multiple occurences\n            elif(str(residue.entity_type)==\"EntityType.NonPolymer\" and (str(residue.name) !=\"HOH\" or str(residue.name)!=\"WAT\")):\n              dname=residue.name+\":\"+chain.name+\":\"+str(residue.seqid.num)\n              hetDict[dname]=[]\n              for atom in residue:\n                  hetDict[dname].append(atom.pos.tolist())\n\n  if(len(positions)!=len(residueSelection)):\n    print(\"Not all positions found for \"+pdbCode+\" discarding structure\")\n    return None\n  binding_site_com=np.mean(np.array(positions))\n  results=[]\n  if(len(hetDict.keys())&gt;0):\n    for ligand in hetDict.keys():\n      ligand_com=np.mean(np.array(hetDict[ligand]))\n      ligand_distance=np.linalg.norm(binding_site_com-ligand_com)\n      results.append([ligand,ligand_distance])\n  return results\n  \n\n\nhetatms=[]\nfor index,row in contactMatrices[\"finalList\"].iterrows():\n  hetatms.append(getLigandHetCodeInBindingSite(row[\"pdbid\"],row[\"chain\"],[int(el.split(\":\")[1]) for el in row[\"residues\"]]))\n\nretainedhetatmcodes=[]\nthreshold=3.0\nfor index,row in contactMatrices[\"finalList\"].iterrows():\n  tmp=[hetatm[0].split(\":\")[0] for hetatm in hetatms[index]if hetatm[1]&lt;threshold]\n  if(len(tmp)&gt;0):\n    \n    retainedhetatmcodes+=[tmp]\n  else:\n    retainedhetatmcodes+=[['']]\n\ncontactMatrices[\"finalList\"][\"ligands\"]=retainedhetatmcodes\nflatretainedhetatmcodes = list(itertools.chain(*retainedhetatmcodes))\n\n\nquery=\"\"\"\n{\n  chem_comps(comp_ids: \"\"\"+str(flatretainedhetatmcodes).replace(\"'\",\"\\\"\")+\"\"\") {\n    rcsb_id\n    chem_comp {\n      \n      formula_weight\n    }\n    rcsb_chem_comp_descriptor{\n      SMILES\n    }\n  }\n}\n\"\"\"\n\nmoleculedict={}\nurl=f\"https://data.rcsb.org/graphql?query={query}\"\nresponse=requests.get(url)\ndataRCSB=response.json()[\"data\"][\"chem_comps\"]\n\nfor compound in dataRCSB:\n  if compound[\"chem_comp\"][\"formula_weight\"]&gt;180.0:\n    moleculedict[compound[\"rcsb_id\"]]={\"molecule\":Chem.MolFromSmiles(compound[\"rcsb_chem_comp_descriptor\"][\"SMILES\"])}\n\n\n\nimport base64\nplots=[]\nrefmolecules=[]\nhetcodes=[]\npdbcodes=[]\nfor index,row in contactMatrices[\"finalList\"].iterrows():\n  if index&lt;10:\n    print(index,retainedhetatmcodes[index])\n    t=sortedMatrixDF.iloc[[index]][\"similar structures\"].values[0]\n    sortedpdbcodes=[line.split(\" \")[0].rstrip(\":\") for line in t]\n    sortedpocketsimilarityscores=[float(line.split(\" \")[1].rstrip(\":\")) for line in t]\n    rowmolecules=[]\n    fps=[]\n    for pdbcode in sortedpdbcodes:\n      tableindex=sortedMatrixDF.loc[sortedMatrixDF[\"pdbid\"]==pdbcode].index[0]\n      ligands=contactMatrices[\"finalList\"].iloc[[tableindex]][\"ligands\"].values[0]\n      for ligand in ligands:\n        if ligand in moleculedict:\n          rowmolecules.append(moleculedict[ligand][\"molecule\"])\n          fps.append(rdMolDescriptors.GetMorganFingerprint(moleculedict[ligand][\"molecule\"],radius=2))\n    reffp=fps[0]\n    fpscores = DataStructs.BulkTanimotoSimilarity(reffp, fps)\n    plotdata=pd.DataFrame(zip(sortedpocketsimilarityscores,fpscores),columns=[\"pocket dissimilarity\",\"fp similarity\"])\n    g = sns.pairplot(plotdata)\n    buf = io.BytesIO()\n    g.fig.savefig(buf, format='png')\n    buf.seek(0)\n    image = base64.b64encode(buf.read())\n    plots.append(image)\n    refmolecules.append(rowmolecules[0])\n    pdbcodes.append(row[\"pdbid\"])\n    hetcodes.append(retainedhetatmcodes[index])\n\n\n# Draw.MolsToGridImage(rowmolecules[:20],molsPerRow=5,subImgSize=(300,200),legends=[\"Tanimoto: \"+str(round(score,2)) for score in scores[:20]])\n\n    # mcs = rdFMCS.FindMCS(rowmolecules,threshold=0.8,completeRingsOnly=True,ringMatchesRingOnly=True)\n    # patt = Chem.MolFromSmarts(mcs.smartsString)\n    # refMol = rowmolecules[0]\n    # AllChem.Compute2DCoords(refMol)\n    # refMatch = refMol.GetSubstructMatch(patt)\n    # for probeMol in rowmolecules[1:]:\n    #   AllChem.GenerateDepictionMatching2DStructure(query , refMatch)\n\n\n\nCode\ntableplotdata=pd.DataFrame(zip(pdbcodes,refmolecules,plots,hetcodes),columns=[\"pdb\",\"molecule\",\"similarity plot\",\"ligand name\"])\n\nwith open(\"data/similarityplots.pkl\",\"wb\") as f:\n  pickle.dump(tableplotdata,f)\n\n\n# Markdown(tabulate(\n#   tableplotdata[:10],\n#   headers=[\"pdbid\",\"molecule\",\"similarity\"]\n# ))\n\n\n\n\nCode\nfrom rdkit import Chem\nfrom rdkit.Chem import PandasTools\nimport urllib\n\nwith open(\"data/similarityplots.pkl\",\"rb\") as f:\n  tableplotdata=pickle.load(f)\n  tableplotdata[\"smiles\"]=[Chem.MolToSmiles(mol) for mol in tableplotdata[\"molecule\"]]\n  PandasTools.AddMoleculeColumnToFrame(tableplotdata,'smiles','molecule')\n  for index, row in tableplotdata.iterrows():\n    uri = 'data:image/png;base64,' + urllib.parse.quote(row[\"similarity plot\"])\n    html = '&lt;img width=\"300px\" src = \"%s\"/&gt;' % uri\n    row[\"similarity plot\"]=html\n\ntableplotdata.to_html(escape=False)\n\n\n\n\n\n\n\n\n\n\n\n\n\npdb\n\n\n\nmolecule\n\n\n\nsimilarity plot\n\n\n\nligand name\n\n\n\nsmiles\n\n\n\n\n\n\n\n\n\n\n\n0\n\n\n\n2BYI\n\n\n\n\n\n\n\n\n\n\n\n\n\n[2DD]\n\n\n\nNS(=O)(=O)c1ccc(CNC(=O)c2cn[nH]c2-c2cc(Cl)c(O)cc2O)cc1\n\n\n\n\n\n\n\n1\n\n\n\n2H55\n\n\n\n\n\n\n\n\n\n\n\n\n\n[DZ8]\n\n\n\nCC(C)NCCCn1c(Cc2cc3c(cc2I)OCO3)nc2c(N)nc(F)nc21\n\n\n\n\n\n\n\n2\n\n\n\n2XJX\n\n\n\n\n\n\n\n\n\n\n\n\n\n[XJX]\n\n\n\nCC(C)c1cc(C(=O)N2Cc3ccc(CN4CCN(C)CC4)cc3C2)c(O)cc1O\n\n\n\n\n\n\n\n3\n\n\n\n2YEB\n\n\n\n\n\n\n\n\n\n\n\n\n\n[2K4]\n\n\n\nOc1ccc2c(-c3cc(Br)c(O)cc3O)noc2c1\n\n\n\n\n\n\n\n4\n\n\n\n3FT5\n\n\n\n\n\n\n\n\n\n\n\n\n\n[MO8]\n\n\n\nCc1nc(N)nc2c1CSCC2\n\n\n\n\n\n\n\n5\n\n\n\n3QDD\n\n\n\n\n\n\n\n\n\n\n\n\n\n[94M]\n\n\n\nCOc1c(C)cnc(Cn2cnc3c(Cl)nc(N)nc32)c1C\n\n\n\n\n\n\n\n6\n\n\n\n4AWQ\n\n\n\n\n\n\n\n\n\n\n\n\n\n[592]\n\n\n\nCOc1cccc(C(=O)NC2CC3CCC(C2)N3c2ccc(C(=O)NCc3ccccc3)cn2)c1C\n\n\n\n\n\n\n\n7\n\n\n\n4EGI\n\n\n\n\n\n\n\n\n\n\n\n\n\n[B2J]\n\n\n\nCSc1nc(N)nc(-c2ccccc2Cl)n1\n\n\n\n\n\n\n\n8\n\n\n\n4O0B\n\n\n\n\n\n\n\n\n\n\n\n\n\n[2QA]\n\n\n\nCc1cn(-c2cc3c(c(C4CCCC4)c2)C(=O)NCC3)c2c1C(=O)CC(C)(C)C2\n\n\n\n\n\n\n\n9\n\n\n\n6B9A\n\n\n\n\n\n\n\n\n\n\n\n\n\n[PA7]\n\n\n\nCCCNC(=O)C1OC(n2cnc3c(N)ncnc32)C(O)C1O\n\n\n\n\n\n\n\n\n\n\nThe table above summarizes for 10 out of over 400 structures the similarity of the binding sites versus the Tanimoto similarity of the ligands located in the binding sites. I used a Morgan fingerprint (radius) 2 and according to a blogpost by Greg Landrum, the random threshold is situated at around 0.2 - 0.3.\nFeel free to adapt the code to display the plots for all structures.\nWhen looking through the first few plots we can see that even though sometimes there might be some correlation between the two similarity metrics, for the large bulk there doesn’t seem to be. Both similarity metrics can be discussed, refined, rendered more fuzzy or precise, one can also replace the ligand similarity by an MCS approach. Again, you can adapt the code quite easily to get there, but still the current results give a lot of examples where rather different ligands can bind to very similar binding sites. Also in several cases ligands above the significance threshold can be found in very similar pockets (compound series), but the opposite is also true.\nLet’s discuss in more detail a typical compound series found in the dataset. In the ?@tbl-similarity-fp structure 2h55 resulted in the following distribution:\n\n\n\nFigure 2: Distribution of ligand similarity vs pocket similarity values when using 2h55 ligand DZ8 as reference\n\n\nIn the orange box on Figure 2 several ligands with some similarity to DZ8 are identified in very similar binding sites (pocket dissimilarity close to 0). More dissimilar binding sites do not seem to bind this class of ligands. This points into the direction that this series of compounds binds clearly to a particular conformation (or induces it, or both). It is also interesting to note that the majority of other compounds in the set are significantly dissimilar to the query ligand.\n\n\n\nFigure 3: Distribution of ligand similarity vs pocket similarity values when using 6b9a ligand PA7 as reference\n\n\nOn figure Figure 3 we can see a very different distribution. Here we have an ATP analog as query ligand & the corresponding binding site. It is very interesting to observe the skewness to more dissimilar binding sites compared to 6b9a. Despite the dissimilarity on binding sites we can see a large cluster of ligands with around 0.5 Tanimoto similarity to PA7. This cluster encompasses ATP & all the closer analogs. This example is a very good one to illustrate the complexity behind the theory of similar ligands bind to similar binding sites. ATP analogs clearly accomodate for a larger variety of binding site conformations & mutations than the compound series around DZ8 does. We could then even imagine that DZ8 is conformation selective & has a few hallmarks of a more specific inhibitor. That’s a bit far fetched for a comparison with a plain ATP analog here, but it appears to go into that direction nevertheless."
  }
]
[
  {
    "objectID": "posts/post-with-code/2023-24-04-forced-revamp/2023-24-04-forced-revamp.html",
    "href": "posts/post-with-code/2023-24-04-forced-revamp/2023-24-04-forced-revamp.html",
    "title": "Forced revamp ongoing",
    "section": "",
    "text": "This blog is under migration to quarto.\n\nInitially I used fastai’s fastpages framework to run & expose jupyter notebooks as blog posts here. Unfortunately fastpages was discontinued a while ago and I got a bit fed up investigating & fixing github actions etc everytime I want to post an article. As suggested by the fastpages author, I’m thus discovering & migrating to quarto. which looks indeed very nice.\nDuring this migration process I had to redo most of the graphing & interactive display bits, switching from altair & 3dmoljs’s python bindings to ngl & ojs (observable js) supported by quarto. If you are interested in seeing in more detail how I integrated that, feel free to check out the source code of the blog posts of interest (look out for qmd files).\nQuarto brings a bunch of nice improvements over fastpages for me, notably proper citation management & reference lists at the end of posts, which is great.\nFurthermore, quarto allows me to locally preview what I write. For markdown that’s not really important, but for the coding bits & interactive viz things that should work it’s really nice to have that possibility.\nDuring the rewrite of some of the posts, obviously some things weren’t reproducible anymore or I found mistakes I made on my own. I tried to correct everything & adapt even the old posts, notably the torsion angle scan part with xtb. I also had to rerun the COD to sdf transformation, so I have a fresh COD version locally now with that as well :tada:\nAnyway, I really hope that quarto will stick around a bit longer & will be less tedious to maintain, but I’m mildly optimistic!"
  },
  {
    "objectID": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html",
    "href": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html",
    "title": "Binding site comparison - current benchmark issues",
    "section": "",
    "text": "First of all, what is written here is my personal viewpoint on the matter. It is conceivable that other people might have different opinions on this topic ;)\nThere has been a lot of interest on the comparison (in 3D) of binding sites since initiating work in that scope by Jambon et al. Today several methods exist, some of them freely available and some of them … not. I also got sucked into the field by the end of my PhD but never ended writing up papers about the whole topic. There are several reasons for that. The main one is likely laziness and total frustration with the scientific publishing & reviewing process. So now I decided to write things up gradually here and maybe one day I’ll spend some time shaping that into a paper ;) This post is mainly about the shortcomings in the way these algorithms are generally validated & intends to challenge currently accepted benchmark datasets in the field. NB: my focus here is to validate at some point my own algorithms, but given the state of the art, a bit of work on the datasets themselves is in order! Also, I’m focusing on how can such binding site methods be applied in the context of drug-discovery when sieving through all structural information available within resources like the RCSB PDB or a model database, like Alphafold or derivatives.\n\n\nIn its simplest form, the fact to be able to compare two pockets from two structures and assess to what extent they are similar. I guess you can already see the various pitfalls in this definition. Binding site comparison could have some rather nice applications when applied on a larger scale (compare one or multiple binding sites to millions of others) in order to identify potential off-targets (or promiscuity prediction) or chemical matter that might bind in such an environment (drug repurposing or bioisosteric replacements, fragment based designs etc …). Comparing binding sites is not a trivial task and the perception on how this should be done can vary significantly depending on the use-case or mind-set at hand. Here are some potential use cases that require dedicated datasets & validation: - idea generation in drug discovery (hit id & lead opt) - polypharmacology prediction (toxicology) - protein function prediction\n\n\n\nToday there are a lot of papers published on that topic. As usual with method development papers in science, with them a ton of ways proving that the authors’ method is for sure always the best one compared to a small selected set of the other existing ones … The field of binding site comparison lacked for a very long time a throuroughly built & commonly accepted benchmark dataset and this for various reasons. But in the end, we end up with the typical mess with a ton of methods each better than the other but not really comparable nor compared to one another.\n\n\nA recent (well now not so recent anymore …) review article by Christiane Ehrt, Tobias Brinkhorst & Oliver Koch tries to address some of the historical shortcomings in the field. They summarize some approaches known today (not extensive, but representative). You can find them in table 1 of the paper by Ehrt, Brinkjost, and Koch (2018). I fully understand that benchmarking a posteriori tens of different methods & developers must be daunting task & am really grateful the team tackled such an effort.\nThe paper reuses / discusses some of the older datasets in the litterature, and I’ll cover mainly two of the ones used by the authors.\nEhrt et al also touch upon a different topic in that paper: a dataset to benchmark a method depends on the scope of capabilities you want to test your method on. That’s a reality that was simply absent from validations before. If you want to prove that your method is capable of detecting remote relationships between binding sites on very different proteins known to bind similar ligands (or not), you have to actually validate that on a relevant dataset.\n\n\n\nOriginal paper from Govindaraj and Brylinski (2018). This dataset was introduced by Govindaraj & Brylinski the same year as the publication of prospeccts. It is an interesting one, because it focuses on one of the “dreams” in the binding site comparison community: “Two very different binding sites known to bind a similar ligand, must be to some extent similar”. I’ll come to that statement a bit later. Basically their viewpoint is that some of the previous studies had performances published that were too good, because the underlying protein structures used in the binding site comparison evaluation were too similar.\nSo they set up a process to generate a more challenging (“tough”) dataset for such methods as described in figure 1 of that paper from Govindaraj and Brylinski (2018)\nI’m currently still trying to wrap my head around the actual procedure and its potential advantages & drawbacks but have to admit that the process is as so often not reproducible as is. So one has to live with the dataset established in 2018, which itself also difficult to reproduce for reasons I won’t elaborate further - but a few lines of code from a paper about deeplytough from benevolent actually helped to get to the actual dataset at least.\n\n\n\nPaper by Kahraman et al. (2009). That’s historically the most used & cited one in the field and it was developed for a totally different purpose. To highlight that, find here the abstract from that paper: &gt; Most function prediction methods that identify cognate ligands from binding site analyses work on the assumption of molecular complementarity. These approaches build on the conjectured complementarity of geometrical and physicochemical properties between ligands and binding sites so that similar binding sites will bind similar ligands. We found that this assumption does not generally hold for protein–ligand interactions and observed that it is not the chemical composition of ligand molecules that dictates the complementarity between protein and ligand molecules, but that the ligand’s share within the functional mechanism of a protein determines the degree of complementarity. Here, we present for a set of cognate ligands a descriptive analysis and comparison of the physicochemical properties that each ligand experiences in various nonhomologous binding pockets. The comparisons in each ligand set reveal large variations in their experienced physicochemical properties, suggesting that the same ligand can bind to distinct physicochemical environments. In some protein ligand complexes, the variation was found to correlate with the electrochemical characteristic of ligand molecules, whereas in others it was disclosed as a prerequisite for the biochemical function of the protein. To achieve binding, proteins were observed to engage in subtle balancing acts between electrostatic and hydrophobic interactions to generate stabilizing free energies of binding. For the presented analysis, a new method for scoring hydrophobicity from molecular environments was developed showing high correlations with experimental determined desolvation energies. The presented results highlight the complexities of molecular recognition and underline the challenges of computational structural biology in developing methods to detect these important subtleties.\nHow on earth did this end up as benchmark dataset for binding site comparison? The conclusions of that paper are a very interesting read and if you have the chance to have access to the paper I invite you to read them."
  },
  {
    "objectID": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#what-is-binding-site-comparison",
    "href": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#what-is-binding-site-comparison",
    "title": "Binding site comparison - current benchmark issues",
    "section": "",
    "text": "In its simplest form, the fact to be able to compare two pockets from two structures and assess to what extent they are similar. I guess you can already see the various pitfalls in this definition. Binding site comparison could have some rather nice applications when applied on a larger scale (compare one or multiple binding sites to millions of others) in order to identify potential off-targets (or promiscuity prediction) or chemical matter that might bind in such an environment (drug repurposing or bioisosteric replacements, fragment based designs etc …). Comparing binding sites is not a trivial task and the perception on how this should be done can vary significantly depending on the use-case or mind-set at hand. Here are some potential use cases that require dedicated datasets & validation: - idea generation in drug discovery (hit id & lead opt) - polypharmacology prediction (toxicology) - protein function prediction"
  },
  {
    "objectID": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#existing-literature",
    "href": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#existing-literature",
    "title": "Binding site comparison - current benchmark issues",
    "section": "",
    "text": "Today there are a lot of papers published on that topic. As usual with method development papers in science, with them a ton of ways proving that the authors’ method is for sure always the best one compared to a small selected set of the other existing ones … The field of binding site comparison lacked for a very long time a throuroughly built & commonly accepted benchmark dataset and this for various reasons. But in the end, we end up with the typical mess with a ton of methods each better than the other but not really comparable nor compared to one another.\n\n\nA recent (well now not so recent anymore …) review article by Christiane Ehrt, Tobias Brinkhorst & Oliver Koch tries to address some of the historical shortcomings in the field. They summarize some approaches known today (not extensive, but representative). You can find them in table 1 of the paper by Ehrt, Brinkjost, and Koch (2018). I fully understand that benchmarking a posteriori tens of different methods & developers must be daunting task & am really grateful the team tackled such an effort.\nThe paper reuses / discusses some of the older datasets in the litterature, and I’ll cover mainly two of the ones used by the authors.\nEhrt et al also touch upon a different topic in that paper: a dataset to benchmark a method depends on the scope of capabilities you want to test your method on. That’s a reality that was simply absent from validations before. If you want to prove that your method is capable of detecting remote relationships between binding sites on very different proteins known to bind similar ligands (or not), you have to actually validate that on a relevant dataset.\n\n\n\nOriginal paper from Govindaraj and Brylinski (2018). This dataset was introduced by Govindaraj & Brylinski the same year as the publication of prospeccts. It is an interesting one, because it focuses on one of the “dreams” in the binding site comparison community: “Two very different binding sites known to bind a similar ligand, must be to some extent similar”. I’ll come to that statement a bit later. Basically their viewpoint is that some of the previous studies had performances published that were too good, because the underlying protein structures used in the binding site comparison evaluation were too similar.\nSo they set up a process to generate a more challenging (“tough”) dataset for such methods as described in figure 1 of that paper from Govindaraj and Brylinski (2018)\nI’m currently still trying to wrap my head around the actual procedure and its potential advantages & drawbacks but have to admit that the process is as so often not reproducible as is. So one has to live with the dataset established in 2018, which itself also difficult to reproduce for reasons I won’t elaborate further - but a few lines of code from a paper about deeplytough from benevolent actually helped to get to the actual dataset at least.\n\n\n\nPaper by Kahraman et al. (2009). That’s historically the most used & cited one in the field and it was developed for a totally different purpose. To highlight that, find here the abstract from that paper: &gt; Most function prediction methods that identify cognate ligands from binding site analyses work on the assumption of molecular complementarity. These approaches build on the conjectured complementarity of geometrical and physicochemical properties between ligands and binding sites so that similar binding sites will bind similar ligands. We found that this assumption does not generally hold for protein–ligand interactions and observed that it is not the chemical composition of ligand molecules that dictates the complementarity between protein and ligand molecules, but that the ligand’s share within the functional mechanism of a protein determines the degree of complementarity. Here, we present for a set of cognate ligands a descriptive analysis and comparison of the physicochemical properties that each ligand experiences in various nonhomologous binding pockets. The comparisons in each ligand set reveal large variations in their experienced physicochemical properties, suggesting that the same ligand can bind to distinct physicochemical environments. In some protein ligand complexes, the variation was found to correlate with the electrochemical characteristic of ligand molecules, whereas in others it was disclosed as a prerequisite for the biochemical function of the protein. To achieve binding, proteins were observed to engage in subtle balancing acts between electrostatic and hydrophobic interactions to generate stabilizing free energies of binding. For the presented analysis, a new method for scoring hydrophobicity from molecular environments was developed showing high correlations with experimental determined desolvation energies. The presented results highlight the complexities of molecular recognition and underline the challenges of computational structural biology in developing methods to detect these important subtleties.\nHow on earth did this end up as benchmark dataset for binding site comparison? The conclusions of that paper are a very interesting read and if you have the chance to have access to the paper I invite you to read them."
  },
  {
    "objectID": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#a-quick-peek-into-the-tough-m1-dataset",
    "href": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#a-quick-peek-into-the-tough-m1-dataset",
    "title": "Binding site comparison - current benchmark issues",
    "section": "A quick peek into the TOUGH-M1 dataset",
    "text": "A quick peek into the TOUGH-M1 dataset\nThe paper introducing the TOUGH dataset didn’t include a single figure showing what types of binding sites & thus ligands were selected to establish the benchmark dataset. So to get a glimpse of that here I’ll show a set of the most common clusters of molecules in their “positive” dataset, so a set of binding sites to be compared to others binding similar ligands.\n\nA bit of code\nLet’s read in the positive list from the TOUGH-M1 dataset and read all sd files available in the distributed version of the dataset.\n\n\nCode\n# prerequisit: get the zip file and unzip to a folder of your choice: wget https://dataverse.harvard.edu/api/access/datafile/:persistentId?persistentId=doi:10.7910/DVN/L7H7JJ/UFO5CB \n# get the positive list from the TOUGH-M1 set from the SI of the paper itself\n\nimport pandas as pd\nfrom pathlib import Path\nfrom rdkit import Chem\nfrom rdkit import RDLogger\nlg = RDLogger.logger()\nlg.setLevel(RDLogger.CRITICAL)\n\npositiveList=pd.read_csv(\"/Users/peter/Downloads/TOUGH-M1_positive.list\",delim_whitespace=True)\nuniquePdbCodes=positiveList.iloc[:, 0].unique()\nprint(\"Number of distinct PDB structures: {}\".format(len(uniquePdbCodes)))\nmolecules=[]\nfor pdbCode in uniquePdbCodes:\n    sdFilePath='/Users/peter/Downloads/TOUGH-M1_dataset/'+pdbCode+'/'+pdbCode+'00.sdf'\n    for mol in Chem.SDMolSupplier(sdFilePath,removeHs=False,sanitize=True):\n        if mol:\n            mol.RemoveAllConformers()\n            molecules.append(mol)\n\nprint(\"Read {} molecules\".format(len(molecules)))\n\n\nNumber of distinct PDB structures: 5965\nRead 5917 molecules\n\n\nFirst of all you notice that a few molecules cannot be read. I won’t go too much into detail, but feel free to peek in here which ones these are & how this could happen. Now let’s do a very basic clustering just to get a rough idea on what the dataset looks like.\n\n\nCode\nfrom rdkit.Chem import AllChem\nimport numpy as np\n\n#Define clustering setup\ndef ClusterFps(fps,cutoff=0.2):\n    from rdkit import DataStructs\n    from rdkit.ML.Cluster import Butina\n\n    # first generate the distance matrix:\n    dists = []\n    nfps = len(fps)\n    for i in range(1,nfps):\n        sims = DataStructs.BulkTanimotoSimilarity(fps[i],fps[:i])\n        dists.extend([1-x for x in sims])\n    cs = Butina.ClusterData(dists,nfps,cutoff,isDistData=True)\n    return cs\n\nfps = [AllChem.GetMorganFingerprintAsBitVect(mol,2,1024) for mol in molecules if mol]\nclusters=ClusterFps(fps,cutoff=0.4)\nclusterSizes=np.array([len(cluster) for cluster in clusters])\nsortedClusterIndices=np.argsort(clusterSizes)[::-1]\nselectedSizes=clusterSizes[sortedClusterIndices]\nfrom rdkit.Chem import Draw\nfrom rdkit.Chem.Draw import IPythonConsole\nmols=[molecules[clusters[sortedClusterIndices[idx]][0]] for idx in range(0,50)]\nlegend=[\"Cluster \"+str(sortedClusterIndices[idx])+\" - \"+str(s) for idx,s in enumerate(selectedSizes[:50])]\nDraw.MolsToGridImage(mols,molsPerRow=5,legends=legend)\n\n\n\n\n\n\n\nCode\n# Here is a bit of code if you want ot get a peek into each cluster, did that but won't show the results. Overall they look fairly clean: \n#mols=[molecules[clusters[sortedClusterIndices[0]][idx]] for idx in range(0,50)]\n#Draw.MolsToGridImage(mols,molsPerRow=5)\n\n\n\n\nResults\nThe majority of the dataset is composed of nucleotides /-sides, sugars & derivatives … ah and hemes. We can also find what we usually would consider as crystallographic surfactants, very small fragments, and a few lipids as well. In other words, the overall composition of the dataset appears to be somehow close to the Kahraman dataset despite being on a different scale (5000 structures versus 40 roughly). Here again I’d argue that such a dataset is useful in the scope of protein function prediction, but I doubt it’s the best suited for drug discovery."
  },
  {
    "objectID": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#how-about-prospeccts",
    "href": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#how-about-prospeccts",
    "title": "Binding site comparison - current benchmark issues",
    "section": "How about Prospeccts",
    "text": "How about Prospeccts\nDuring my binding site comparison tests, I also played a bit more in detail with the Prospeccts dataset 1 & 7.\n\nDataset 1\nIt tries to give indicators on how sensitive a comparison method is towards the binding site definition itself. It’s composed of 12 different protein binding sites that can be identified relatively easily with the table S9 from supporting information. Several structures are available for each binding site and a binding site comparison algorithm should ideally be able to identify binding sites of the same protein with higher similarities than binding sites of the other proteins of the dataset (used as decoy here). The authors state, that “It was generated to evaluate the sensitivity of binding site comparison tools with respect to the binding site definition. A tool which is not able to enrich similar binding sites accommodating different ligands should not be applied for drug repurposing projects or the prediction of putative off-targets”. The second sentence, does not really apply for this dataset in my opinion. I used this kind of approach though to test if naturally a binding site comparison method is able to enrich results (from a huge heterogeneous set of pockets) with binding sites from the same protein (same location) or protein family, or orthologs. Ehrt et al argue that the benchmark set depend on the purpose of the binding site comparison sofware and that’s true. Datasets like the dataset 1 from the Prospeccts paper allow first of all to check if there is some reasonable signal in identifying similar binding sites. I’m saying binding sites, not interaction patterns (!!!). As such, dataset 1 & thoroughly built extensions of these can be used to evaluate if a binding site comparison method could be used also as idea generator and for validation of off-target identification scenarios (but there aren’t any in dataset 1 as for now).\n\n\nDataset 7\nThis dataset from the prospeccts paper from Ehrt, Brinkjost, and Koch (2018) is one of these examples where you say, on paper that looks great and about what we need. But once looking into the details, it’s again rather small and there are a few very worrying errors in it as well (i.e. two PIM kinase ATP binding sites as decoy pair, a lot of NAD / FAD binding sites etc).\n\n\nHow about the Barelier dataset\nLet’s check out Barelier et al. (2015) dataset, which again is supposed to give us a few examples where the same or similar ligands bind to very different proteins. Again this is used throughout the binding site comparison community as valid benchmark dataset. The set is rather small, so I’ll just display the chemical matter that has been used here. The Barelier set is also used within the prospeccts paper. The molecules were extracted from the residue codes available in table1 SI - class A (ligands make similar interactions in related residues in both binding sites), table 2 SI - class B (same ligand groups interact with dissimilar residues & environments)), table 3 SI - class C (different parts of the ligand interacts).\n\n\nCode\nfrom rdkit.Chem import AllChem\nfrom rdkit import Chem\nimport numpy as np\nimport requests\nimport json\n\n#I love copying codes from PDF's, ACS, you cannot imagine how painful this is\nclassA=[\"2AN\",\"3IP\",\"ACD\",\"AEF\",\"AGI\",\"AMZ\",\"BRN\",\"CAU\",\"DAO\",\"CXX\",\"EIC\",\"FLN\",\"GNT\",\"HXA\",\"IBP\",\"NTZ\",\"VCA\",\"X8Z\"]\nclassB=[\"0YN\",\"IGP\",\"1QK\",\"4AX\",\"4HP\",\"4NP\",\"ALE\",\"BIO\",\"C2R\",\"CEL\",\"CFF\",\"CPB\",\"CSN\",\"DHF\",\"XDE\",\"EMO\",\"ES1\",\"FUN\",\"H2B\",\"IAC\",\"LOC\",\"LVA\",\"MTE\",\"MYC\",\"NAR\",\"OCA\",\"PDN\",\"PT1\"]\nclassC=[\"16A\",\"2AL\",\"2TN\",\"3PO\",\"AIN\",\"AZM\",\"BER\",\"CLM\",\"EMU\",\"FLF\",\"IAC\",\"LUM\",\"PHN\"]\n\n\ndef getMoleculesFromRcsb(residueCode):\n    response=requests.get(\"https://data.rcsb.org/rest/v1/core/chemcomp/\"+residueCode)\n    if(response.status_code==requests.codes.ok):\n        d=json.loads((response.text))\n        smiles=d[\"rcsb_chem_comp_descriptor\"][\"smiles\"]\n        return(Chem.MolFromSmiles(smiles))\n    return None\n\n\nclassAmolecules=[getMoleculesFromRcsb(residue) for residue in classA]\nclassBmolecules=[getMoleculesFromRcsb(residue) for residue in classB]\nclassCmolecules=[getMoleculesFromRcsb(residue) for residue in classC]\n\n\n\n\nClass A molecules\n\n\nCode\nDraw.MolsToGridImage(classAmolecules,molsPerRow=5)\n\n\n\n\n\n\n\nClass B molecules\n\n\nCode\nDraw.MolsToGridImage(classBmolecules,molsPerRow=5)\n\n\n\n\n\n\n\nClass C molecules\n\n\nCode\nDraw.MolsToGridImage(classCmolecules,molsPerRow=5)\n\n\n\n\n\nAn overall observation is that several molecules in all three classes are rather fragments than actual specific drug-like molecules. This is usually a warning sign on the reliability of the structure & the positioning of the fragment itself. There are several examples underlinging these limitations, but one of the more recent ones can be found here - Mehlman et al. (2022). The dataset also contains saturated & unsaturated alkyl chains or fatty acids. Obtaining any sort of specificity in purely hydrophobic binding sites is not straightforward to say the least. We find yet again several nucleosides or derivatives. Last, some molecules wouldn’t even pass filters like PAINS or such."
  },
  {
    "objectID": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#what-is-obviously-similar-should-be-retrieved-first",
    "href": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#what-is-obviously-similar-should-be-retrieved-first",
    "title": "Binding site comparison - current benchmark issues",
    "section": "What is obviously similar should be retrieved first",
    "text": "What is obviously similar should be retrieved first\nWhen searching large collections of structures having a single or a set of binding sites as query, I’d expect to find the structures of the same protein containing the same binding site with no or few changes (mutations, flexibility) before any other hits (proteins / binding sites), unless these other hits are locally as similar as the query protein structures themselves. This can / should happen for close homologs in common protein families."
  },
  {
    "objectID": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#what-is-objectively-similar",
    "href": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#what-is-objectively-similar",
    "title": "Binding site comparison - current benchmark issues",
    "section": "What is objectively similar",
    "text": "What is objectively similar\nThat’s a principle that is easy to say, but not as easy to verify & implement. While the previous point was scoped on the same or similar sequence space (protein families, homologs), this one should check known obvious similarities, like same fold & minor mutations / flexibility in the binding site."
  },
  {
    "objectID": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#totally-unrelated-proteins",
    "href": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#totally-unrelated-proteins",
    "title": "Binding site comparison - current benchmark issues",
    "section": "Totally unrelated proteins",
    "text": "Totally unrelated proteins\nTricky, but that’s what a lot of academics seem to focus on."
  },
  {
    "objectID": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#no-explicit-definition-of-decoys",
    "href": "posts/post-with-code/2022-11-07-binding-site-comparison-benchmark/2022-11-07-binding-site-comparison-benchmark.html#no-explicit-definition-of-decoys",
    "title": "Binding site comparison - current benchmark issues",
    "section": "No explicit definition of decoys",
    "text": "No explicit definition of decoys\nThat’s another not so trivial thing, but typically in the prospeccts paper (and others) decoys are usually defined as pairs of binding sites that shouldn’t match. For similar reasons as with decoys in virtual screening experiments, when there is no actual experimental proof that a decoy is a decoy one shouldn’t use it as a decoy. Not to mention biases this introduces intrinsically as well. If no decoys are available, we won’t be able however to compare against ROC curves vs the litterature, if that was to be our aim. Rather than following that path, I’d set up binding site similarity searches against all known & putative pockets and evaluate how much of what I should get out from a similarity search, I actually get out."
  },
  {
    "objectID": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html",
    "href": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html",
    "title": "Crystallography Open Database and torsion angle statistics with rdkit",
    "section": "",
    "text": "When designing compounds in 3D, especially within the binding site, it is often very complicated to assess if what you’ve just designed actually makes sense. Is the molecule strained? Does it make ok or favourable interactions? Does it bump into the binding site somewhere? Especially when talking to medicinal chemists, they usually want to know whether their design passes all potential physical hurdles … and while we’re at it a prediction of the binding affinity would be nice and this in 1 second.\nAmong all of these things to evaluate on a compound in 3D, the strain is something that can be either calculated (quantum mecanics, or force-field if you trust that) or compared to a set of reference compounds we know the structures of.\nA very popular reference database for small molecule conformations is the CCDC CSD. It contains more than a million small molecule crystal structures. It is widely used in pharma industry to assess various things … among them: ligand strain. I won’t enter the debate here whether the conformations observed in small molecule crystal structures are relevant and all the other debates on the use of such a database.\nThe thing is, the CSD is not freely available. However, there’s a free alternative available … I guess the poor man’s CSD and it’s called COD for Crystallography Open Database. It contains less structures than the CSD (466 000 by the time I’m writing this), that’s for sure, but it’s still maintained and people are depositing structures in there. The quality appears to be OK as well according to what I read so far, no tests done yet.\nHere I’ll outline a few steps on how to get the COD and use rdkit to extract all torsion angles of all molecules - a long and bumpy ride. Here we go."
  },
  {
    "objectID": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#context",
    "href": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#context",
    "title": "Crystallography Open Database and torsion angle statistics with rdkit",
    "section": "",
    "text": "When designing compounds in 3D, especially within the binding site, it is often very complicated to assess if what you’ve just designed actually makes sense. Is the molecule strained? Does it make ok or favourable interactions? Does it bump into the binding site somewhere? Especially when talking to medicinal chemists, they usually want to know whether their design passes all potential physical hurdles … and while we’re at it a prediction of the binding affinity would be nice and this in 1 second.\nAmong all of these things to evaluate on a compound in 3D, the strain is something that can be either calculated (quantum mecanics, or force-field if you trust that) or compared to a set of reference compounds we know the structures of.\nA very popular reference database for small molecule conformations is the CCDC CSD. It contains more than a million small molecule crystal structures. It is widely used in pharma industry to assess various things … among them: ligand strain. I won’t enter the debate here whether the conformations observed in small molecule crystal structures are relevant and all the other debates on the use of such a database.\nThe thing is, the CSD is not freely available. However, there’s a free alternative available … I guess the poor man’s CSD and it’s called COD for Crystallography Open Database. It contains less structures than the CSD (466 000 by the time I’m writing this), that’s for sure, but it’s still maintained and people are depositing structures in there. The quality appears to be OK as well according to what I read so far, no tests done yet.\nHere I’ll outline a few steps on how to get the COD and use rdkit to extract all torsion angles of all molecules - a long and bumpy ride. Here we go."
  },
  {
    "objectID": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#get-the-cod",
    "href": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#get-the-cod",
    "title": "Crystallography Open Database and torsion angle statistics with rdkit",
    "section": "Get the COD",
    "text": "Get the COD\nThat’s rather easy. You can simply retrieve cif or hkl files from their server using this here:\nmkdir -p cif; rsync -av --delete rsync://www.crystallography.net/cif/ cif/\nThis should run for a bit."
  },
  {
    "objectID": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#parsing-cif-in-rdkit",
    "href": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#parsing-cif-in-rdkit",
    "title": "Crystallography Open Database and torsion angle statistics with rdkit",
    "section": "Parsing CIF in rdkit",
    "text": "Parsing CIF in rdkit\nThe first hurdle is as usual linked to molecular formats. To the best of my knowledge no cif parser was ported yet to rdkit. I tried a few parsers (gemmi - no mol or other useable output yet, pdbccdutils -&gt; only macromolecular cif files, I think) before ending up again with openbabel in the end. Let’s stick with that for now.\nLet’s try to see what this looks like for a single cif file from the COD:\n```{python}\nfrom rdkit import Chem\nfrom openbabel import pybel\nimport dask\nmol = next(pybel.readfile(\"cif\", \"/Users/peter/Downloads/cod/cif/1/00/00/1000007.cif\")) \n\nmolblock=mol.write(\"mol\")    #write out as a molfile string and ship that now into rdkit\n\nm = Chem.MolFromMolBlock(molblock,removeHs=False)\nChem.MolToMolFile(m,\"samplemolecule.mol\")\nm\n```\nWell, that looks rather nasty. Let’s check in 3D:\n\n\nCode\n// Create drawing area\ndiv_mol = html`&lt;div style=\"width:400px;height:400px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\n\n\n\nCode\nNGL = require(\"ngl@next\");\n\n   molBlock = await FileAttachment(\"samplemolecule.mol\").blob();\n\nstage = new NGL.Stage(div_mol, { backgroundColor: \"black\",cameraType: \"orthographic\"});\nstructure = await stage.loadFile(molBlock, {ext: \"sdf\", asTrajectory: false})\nstructure.addRepresentation(\"licorice\",{ \"sele\": \"all\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nstructure.autoView();\n\n\n\n\n\n\n\n\n\nSo good news, cif parsing seems to work (at least on this particular example). The bad news, how can I get to relevant molecules in the COD?"
  },
  {
    "objectID": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#extracting-relevant-molecules-from-the-cod",
    "href": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#extracting-relevant-molecules-from-the-cod",
    "title": "Crystallography Open Database and torsion angle statistics with rdkit",
    "section": "Extracting relevant molecules from the COD",
    "text": "Extracting relevant molecules from the COD\nThanks to researchgate I came across this page where they provide a datawarrior file of the content of the cod (at least a curated subpart of that). You can see that the COD contains organic, inorganic and metalorganic structures.\n\n\n\ndatawarrior screenshot\n\n\nAs you might already observe on the screenshot above, there’s a lot of noise (for drug discovery) in there.\nSo how can we filter out only the organic ones? I checked the individual cif files, and no easy way to get to this classification … would have been too easy. So two solutions - either take the prepared datawarrior file (which I would not prefer, because I’m dependent on somebody else doing this nice work during his free-time, Thomas Sander), or trial and error and identify organic compounds with a set of rules. Good thing is, I can use Thomas Sanders work (the datawarrior file) to check if the filter works or not (+ visual inspection).\nThe COD dump you can download via rsync is structured a bit like the PDB: with two levels of subfolders, numbered and 100 files max per subfolder. Basically I’ll have to loop over all of this -&gt; let’s blow up the notebook ;) I’ll loop over all molecules and try to run through sanitize. All failing molecules should not be added. Next I’m checking as well if there’s at least a carbon atom in the structure (for a lot of them there isn’t). I filter out metalorganics as well. Last I keep only molecules with more than 6 atoms.\nAs this is a bit slow and can be easily put on several cpu’s I’m doing that right here as well. I wanted to test how dask behaves on such a task. It’s total overkill for what I’m doing here, but I want to see how the scheduling behaves on short living and often failing jobs (difficult to orchestrate, unless you handle it yourself in the code).\nBelow you have a standalone python script (was not optimal in the notebook) to run all of this quick and dirty preparation. There are tons of rdkit & openbabel warnings popping out of that, as expected:\n```{python}\n#| tags: []\n#| eval: false\nfrom rdkit import Chem\nfrom openbabel import pybel\nimport glob\nimport pandas as pd\nimport os\nimport multiprocessing as mp\n# from wrapt_timeout_decorator import *\nfrom rdkit import rdBase\nrdBase.DisableLog('rdApp.error')\nrdBase.DisableLog('rdApp.warning')\n\nob_log_handler = pybel.ob.OBMessageHandler()\nob_log_handler.SetOutputLevel(0)\n\ncarbon = Chem.MolFromSmarts(\"[#6]\")\n\n\n\ndef is_transition_metal(at):\n    n = at.GetAtomicNum()\n    return (n&gt;=22 and n&lt;=29) or (n&gt;=40 and n&lt;=47) or (n&gt;=72 and n&lt;=79)\n\n\ndef write_output(filenames,outputname=\"out.sdf\"):\n    w = Chem.SDWriter(outputname)\n    for filename in filenames:\n        try:\n            if os.stat(filename).st_size / (1024 * 1024)&lt;2.0:\n                mol = next(pybel.readfile(\"cif\",str(filename))) \n                molblock=mol.write(\"mol\")    #write out as a molfile string and ship that now into rdkit\n                m = Chem.MolFromMolBlock(molblock,removeHs=False,sanitize=True)\n                m.SetProp('COD',os.path.basename(filename).split(\".\")[0])\n                w.write(m)\n        except Exception:\n            pass\n    w.close()\n\ndef select_molecule(filename):\n\n    blacklist=[\"/Users/peter/Downloads/cod/cif/2/31/17/2311717.cif\",\"/Users/peter/Downloads/cod/cif/2/10/46/2104629.cif\",\"/Users/peter/Downloads/cod/cif/2/10/59/2105953.cif\"]\n    if(filename not in blacklist):\n        try:\n            mol = next(pybel.readfile(\"cif\",str(filename))) \n            molblock=mol.write(\"mol\")    #write out as a molfile string and ship that now into rdkit\n            m = Chem.MolFromMolBlock(molblock,removeHs=False,sanitize=True)\n            \n            if m is not None and len(m.GetSubstructMatches(carbon))&gt;0 and m.GetNumAtoms()&gt; 6  :\n                \n                if(True not in [is_transition_metal(atom) for atom in m.GetAtoms()]):\n                    return filename\n        except Exception:\n            return None\n        return None\n    return None\n\n\nif __name__ == '__main__':\n    files=glob.glob('/Users/peter/Downloads/cod/cif/**/*.cif', recursive=True)\n    n=0\n\n    pool = mp.Pool(mp.cpu_count())\n    results = pool.map(select_molecule, files)\n    \n    validresults=[el for el in results if el is not None]\n    codids=[int(os.path.basename(filename).split(\".\")[0]) for filename in validresults]\n    write_output(validresults)\n    # df = pd.read_table('/Users/peter/Downloads/COD_2020jun13.txt',  header=0)\n\n    # dwr=df[\"COD Number\"]\n\n    # common=list(set(dwr) & set(codids))\n\n    \n    # print(\"common molecules\")\n    # print(len(common))\n\n    # import numpy as np\n    # print(\"in mine, not in datawarrior\")\n    # intersect1=np.setdiff1d(codids,dwr)\n    # np.savetxt(\"out_intersect1.csv\",intersect1.astype(int),delimiter=\",\",fmt='%i')\n    # print(len(intersect1))\n\n    # print(\"in datawarrior, not in mine\")\n    # intersect2=np.setdiff1d(dwr,codids)\n    # np.savetxt(\"out_intersect2.csv\",intersect2.astype(int),delimiter=\",\",fmt='%i')\n    # print(len(intersect2))\n```\nI finally decided to strip out the dask code and run it through multiprocessing. Anyhow, easy to set up and a quick discussion on that below as well!"
  },
  {
    "objectID": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#dask-multiprocessing-interlude",
    "href": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#dask-multiprocessing-interlude",
    "title": "Crystallography Open Database and torsion angle statistics with rdkit",
    "section": "Dask & multiprocessing interlude",
    "text": "Dask & multiprocessing interlude\nBefore analyzing the results, let’s briefly assess how dask performs here. Dask enables us to run the code in a classical threaded, but also distributed mode, even on a local machine. As I have 12 cores’s hanging in my MacPro I tested a distributed calculation. That is rather easy to set up. A bit like a multiprocessing Pool, but with the advantage that the functions are not 100% isolated (advantage or disadvantage, I let you decide ;)).\nThe other nice thing (I didn’t know about) is that dask (if installed through conda at least) comes with bokeh, a tool allowing you to do some monitoring of your jobs. It’s not super advanced, but gives you an overview of the worker loads, the job queue and the overall advancement. So that’s quite cool compared to being completely blind on what’s happening in your queue.\n\n\n\ndask screenshot\n\n\nI tested quite a range of combinations and ways to run this in dask (bag, compute, map …. ) and combinations of number of worker nodes vs threads. In the end, parallelization still isn’t optimally spread over all cpu’s, but I guess that’s likely due to the fact that every calculation can range from immediate failure to runnning for a very long time. I guess, that on longer living and more stable jobs this is far more efficient.\nThe most frustrating thing was that the script completely froze on a single job during the last 10% of the molecules. I narrowed down the issue to 3 molecules that openbabel naturally had issues with. When I say naturally, have a look at these:\n\n\n\nissues with these cod’s\n\n\nThe nasty thing here is that I even tried to kill these freezing jobs with timeout decorators and such. Without success. Even a ctrl+c in a shell didn’t kill the job … only a kill -9 did. So in the end I kept the multiprocessing version here in the code and filtered out the three incriminating molecules ( by hand, but would be really interested to know how this can be handled in a more geeky way)."
  },
  {
    "objectID": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#final-filtered-cod",
    "href": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#final-filtered-cod",
    "title": "Crystallography Open Database and torsion angle statistics with rdkit",
    "section": "Final filtered COD",
    "text": "Final filtered COD\nLet’s come back to the actual aim of this post. Extract torsion angle statistics from small molecule crystal structures. First let’s have a look what molecules I have in common now with Datawarrior and which ones are different and whether the filter should / could be refined a bit.\n\n\n\n\nobabel & rdkit\nDatawarrior\n\n\n\n\nobabel & rdkit\n78643\n117674\n\n\nDatawarrior\n117674\n18344\n\n\n\nThe majority of retained molecules are in common with datawarrior, but I am, I guess still a bit permissive for now. I don’t want to go too much into the analysis of differences here and now. Quickly checking the sd file (above 1Gb) with datawarrior gives a few ideas on what to filter out. I guess I can also use some of the published usual filters on top of that.\n\n\n\nquick overview\n\n\nNB: the results above are from the initial post. I had to repeat the whole thing when I moved the blog to quarto. During this redo I published the output sd file on zenodo so you can use it. It’s the state of the COD of April 2023."
  },
  {
    "objectID": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#towards-torsion-angles",
    "href": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#towards-torsion-angles",
    "title": "Crystallography Open Database and torsion angle statistics with rdkit",
    "section": "Towards torsion angles",
    "text": "Towards torsion angles\nNow the next step is to identify whether there’s enough data to gather some statistics on some typical torsion angles that you can encounter in druglike molecules. Fortunately Sereina Riniker & Greg Landrum already did something a bit similar in the past with data from the CSD and the PDB to write the ETKDG (I hope I got that right) conformer generator for rdkit.\nThe SI of that paper lists a bunch of smarts patterns describing such torsion angles. I’ll blindly use these here to sieve through all molecules from the COD to see what I can get out of that. The smarts patterns are available here - freely available … unlike the paper behind it :(\n\nimport pandas as pd\nfrom rdkit.Chem import rdMolTransforms\n\nimport matplotlib.pyplot as plt \nimport matplotlib.image as mpimg\nimport numpy as np\nimport urllib.parse\n\ntorsions=pd.read_table(\"data/list_torsion_patterns.txt\",header=None,usecols=[1])\nsuppl = Chem.SDMolSupplier('out.sdf',removeHs=False)\npatterns=torsions[1][:3]\n\nfor torsionSmarts in patterns:\n    print(torsionSmarts)\n    angles=[]\n    torsionQuery = Chem.MolFromSmarts(torsionSmarts)\n    i=0\n    #suppl.reset()\n    for mol in suppl:\n        i+=1\n        if mol is None: continue\n        conf=mol.GetConformer(0)\n        matches = mol.GetSubstructMatches(torsionQuery)\n        if(len(matches)&gt;0):\n            for match in matches:\n                angle=rdMolTransforms.GetDihedralDeg(conf, match[0],match[1],match[2],match[3])\n                angles.append(angle)\n\n\n    if(len(angles)):\n        smarts=urllib.parse.quote(torsionSmarts)\n        img = mpimg.imread(\"https://smarts.plus/smartsview/download_rest?smarts=\"+smarts,format=\"png\")\n\n        fig = plt.figure(figsize=(10, 5))\n        fig.add_subplot(121)\n        plt.title('smarts pattern')\n        plt.axis('off')\n        plt.imshow(img)\n\n        fig.add_subplot(122)\n        plt.title('torsion angle histogram')\n        \n        #df = pd.DataFrame(angles,columns = [torsionSmarts])  \n        \n        plt.hist(np.array(angles),bins=36,range=[-180, 180])\n\n  \nI’m only showing 3 smarts patterns here, but the code is written to run on all of the smarts patterns from the Riniker & Landrum paper. So feel free to adjust it to get the full results on your machine (to big for the notebook here ;).\nAs you can see, there is still a lot of errors when re-reading the molecules from the SD file … so still a lot of curation to be done. Also, on fullerenes or graphene or other larger structures (that are still in there), we’ll likely get a repeated overrepresentation of several torsion angles. So something to think about when normalizing all of this data in the end.\nIn theory, the order of the smarts patterns in the file I used here should be comparable to torsion angles provided in the S1.zip by both authors (fingers crossed). These histograms were generated on a filtered / curated CCDC CSD dataset (unlike my hairy monster dataset here).\n\n\n\ntorsions\n\n\nThe first thing to notice is that they calculated a dihedral between 0 and 360, I just took the angles popping out of rdkit (between -180 and 180). So a bit of a mindgame to compare both. On smarts patterns 1 and 3 we have peaks around 0, which coincides with the CSD results. It is interesting to see that there’s a bit of data for smarts pattern 1 suggesting angles around 180° might be possible, though not favourable (again, more filtering and quality checks needed to confirm/discard that).\nSmarts pattern 2 doesn’t coincide at all with results from the CSD however, which makes me worried … a bit ;)"
  },
  {
    "objectID": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#debugging-smarts-pattern-2",
    "href": "posts/post-with-code/2021-01-25-cod-and-torsion-angles/2021-01-25-cod-and-torsion-angles.html#debugging-smarts-pattern-2",
    "title": "Crystallography Open Database and torsion angle statistics with rdkit",
    "section": "Debugging smarts pattern 2",
    "text": "Debugging smarts pattern 2\n\npattern=\"[O:1]=[C:2]([N])!@;-[O:3]~[C:4]\"\ni=0\ntorsionQuery = Chem.MolFromSmarts(pattern)\nfor mol in suppl:\n    i+=1\n    if mol is None: continue\n    conf=mol.GetConformer(0)\n    matches = mol.GetSubstructMatches(torsionQuery)\n    if(len(matches)):\n        for match in matches:\n                angle=rdMolTransforms.GetDihedralDeg(conf, match[0],match[1],match[2],match[3])\n                #break\n                print(angle)\n                print(mol.GetProp(\"COD\"))\n    if(i&gt;5000):\n        break\n\nHere are 4 compounds where we calculate in theory wrong angles. Let’s visualize the last one and check what dihedral angle we are actually calculating here\n\nfor mol in suppl:\n    if str(mol.GetProp(\"COD\"))==str(7039689):\n        mol.GetSubstructMatches(torsionQuery)\n        break\n\nmatches=mol.GetSubstructMatches(torsionQuery)\nprint(matches)\nflat_list = [item for sublist in matches for item in sublist]\nmolblock=Chem.MolToMolBlock(mol)\nviewer = py3Dmol.view(width=300, height=300)\nviewer.addModel(molblock, 'mol')\nviewer.setStyle({\"stick\":{}})\n#viewer.setStyle({'serial':flat_list},{'stick':{'color': 'pink'}})\nviewer.setStyle({'serial':flat_list},{'stick':{'color': 'pink'}})\n\nviewer.zoomTo()\n\nThe matching atoms are coloured in pink here.\nFrom the substructure matches above, we can see that the smarts pattern matches 5 atoms, instead of 4. Including the nitrogen (the third atom matching here). In the end, this doesn’t describe the bond or the torsion angle we want at all, thus the discrepancies in the results."
  },
  {
    "objectID": "posts/post-with-code/2021-02-02-fpocket-towards-biologics/2021-02-02-fpocket-towards-biologics.html",
    "href": "posts/post-with-code/2021-02-02-fpocket-towards-biologics/2021-02-02-fpocket-towards-biologics.html",
    "title": "fpocket 4.0 - Towards biologics",
    "section": "",
    "text": "I just released the last version of fpocket (4.0) which contains quite a few new features. Most of the work was done by Mael Shorkar, an eager summer intern we took in at Discngine during last year’s COVID-mess summer. He did a great job under these circumstances (remote work in a new company etc). So kudos to him for these new additions."
  },
  {
    "objectID": "posts/post-with-code/2021-02-02-fpocket-towards-biologics/2021-02-02-fpocket-towards-biologics.html#mmcif-support",
    "href": "posts/post-with-code/2021-02-02-fpocket-towards-biologics/2021-02-02-fpocket-towards-biologics.html#mmcif-support",
    "title": "fpocket 4.0 - Towards biologics",
    "section": "MMCIF support",
    "text": "MMCIF support\nFirst of all, fpocket now supports mmCIF. Yay … yet another very painful task to integrate for yet another painfully crappy molecular file format (I admire the openbabel folks … ;) ). Same as for the PDB format we forked essentially an integration from the VMD molfile plugin and extended that a bit further. Mael also integrated mmCIF writers so all output files can be written in this new crappy format as well. Essentially you now have the choice to write either only pdb or cif or both. So everybody should be happy (nah … that’s never going to be case anyway)."
  },
  {
    "objectID": "posts/post-with-code/2021-02-02-fpocket-towards-biologics/2021-02-02-fpocket-towards-biologics.html#new-command-line-flags",
    "href": "posts/post-with-code/2021-02-02-fpocket-towards-biologics/2021-02-02-fpocket-towards-biologics.html#new-command-line-flags",
    "title": "fpocket 4.0 - Towards biologics",
    "section": "New command line flags",
    "text": "New command line flags\nThe most interesting part (for me) of this release are additional command line flags and behind these several use cases that can be addressed now. These command line arguments enable mainly to work in a more controlled way with multi chain protein structures. This can be particularly useful if: 1. you want to study only one domain of one of these novel gigantic cryoEM structures 2. you want to study in detail a protein - biomolecule binding site (so other than small molecule) 3. you want to learn key characteristics of peptide/protein binding sites vs RNA/DNA binding sites vs drug binding sites\n    -c char : (Default is none): Use this flag to choose which chains you want to delete before running fpocket. The selected chains can be specified with ',' or ':' delimiters, for example you can use it '-c B,D' or '-c B:D'. You can delete up to 20 different chains.\nThis flag essentially allows you to explicitly delete particular chain(s) before doing the fpocket run. This allows you to identify (without any bias) clefts that might occur on the PPI that were inaccessible before for pocket prediction.\n    -k char : (Default is none): Use this flag to choose which chains you want to keep before running fpocket. The selected chains can be specified with ',' or ':' delimiters, for example you can use it '-k A,B,E' or '-k A:B:E'. You can keep up to 20 different chains.\nThis is essentially the inverse operator of the previous flag. If you do not want to list n chains, you can decide to keep only the relevant ones here.\n    -a char : (Default is none): With this flag you can select a chain you want to be considered as a ligand. Works the same way as the \"-r\" flag but with a whole chain. Only a single chain can be chosen, for example '-a D'.\nThis flag essentially allows you to target for only one particular binding epitope. If you want to extract descriptors for only that binding site where the select chain is located then you can use the -a flag. Fpocket will hide the chain specified via the flag. Run vertice detection and then will choose all vertices overlapping with the chain you specified in -a. These will then be clustered together into a final “pocket”. This is rather generic and can be applied on protein chains, RNA, DNA … whatever you like given that it is defined in a seperate chain. It is so generic, that in theory you can do even very nasty stuff, but let’s see if you can find that out yourselves.\nThis argument is particularly interesting when you want to extract examples (3D patches) or numerical descriptors (polar/apolar ASA, curvature, buriedness …) for other binding sites than classical small molecule binding sites. It essentially lies out the basics for training & learning what such other binding epitopes look like. You can use that for a fancy model, or to characterize binding epitopes ultimately."
  },
  {
    "objectID": "posts/post-with-code/2021-02-02-fpocket-towards-biologics/2021-02-02-fpocket-towards-biologics.html#miscellaneous",
    "href": "posts/post-with-code/2021-02-02-fpocket-towards-biologics/2021-02-02-fpocket-towards-biologics.html#miscellaneous",
    "title": "fpocket 4.0 - Towards biologics",
    "section": "Miscellaneous",
    "text": "Miscellaneous\nSeperately, several things were added to the github repo of fpocket, namely the old documentation was ported to markdown (that was painful). There’s also a tiny testing environment, CI/CD pipes finally set up to check compilation and unit tests upon PR’s.\nLast, an official fpocket docker image is also available on dockerhub."
  },
  {
    "objectID": "posts/post-with-code/2021-02-02-fpocket-towards-biologics/2021-02-02-fpocket-towards-biologics.html#extracting-descriptors-with-fpocket",
    "href": "posts/post-with-code/2021-02-02-fpocket-towards-biologics/2021-02-02-fpocket-towards-biologics.html#extracting-descriptors-with-fpocket",
    "title": "fpocket 4.0 - Towards biologics",
    "section": "Extracting descriptors with fpocket",
    "text": "Extracting descriptors with fpocket\nOk running these things on individual examples is nice. You can automate things with fpocket quite easily and extract descriptors on a larger scale using the fancy -d flag (oh yes, yet another flag) if the only thing you’re after is descriptor extraction.\n\nWhy would I ever want to extract descriptors?\nCalculating descriptors on binding epitopes is generating the basis for using these to derive several potential applications afterwards. For instance, to derive the druggability prediction in fpocket, first we extracted descriptors of known druggable and supposed non-druggable (no religious debate here) pockets, second we determined the most relevant descriptors and last we trained a scoring function based on these descriptors.\nYou can very well imagine to do the same on other types of binding epitopes (there are a few papers out there on that already I guess), like protein protein interfaces, antibody / antigene interfaces more specifically, crystal contacts, protein DNA/RNA interfaces etc…\nUltimately these characterisations will allow you to train functions or super fancy deep learning models (if you really need that).\nIn order to do that on a larger scale you could use dpocket (a less well-known sibling of fpocket), but it currently still doesn’t fully integrate the logic with selecting chains as ligands (still a bit of work needed here). So let’s stick to fpocket on a larger scale example for descriptor extraction which will work just fine:\ndata/peptide_data/3uqp.pdb B\ndata/peptide_data/3uri.pdb B\ndata/peptide_data/4rcp.pdb B\ndata/peptide_data/4tpg.pdb E\ndata/peptide_data/5jxh.pdb H\nLet’s suppose we have a csv file like this one above. It defines a set of PDB files and the chain we want to consider as a ligand explicitly during the fpocket run to assess the binding epitope this chain is making with the “receptor”. You could run this in a very geeky way using this here:\nawk '{ print \"fpocket -f \" $1 \" -a \"$2 \" -d\"}' list.txt | sh\nThis will output a messy thing like this:\ncav_id drug_score volume nb_asph inter_chain apol_asph_proportion mean_asph_radius as_density mean_asph_solv_acc mean_loc_hyd_dens flex hydrophobicity_score volume_score charge_score polarity_score a0_apol a0_pol af_apol af_pol n_abpa ala cys asp glu phe gly his ile lys leu met asn pro gln arg ser thr val trp tyr chain_1_type chain_2_type num_res_chain_1 num_res_chain_2 lig_het_tag name_chain_1 name_chain_2\n1 0.0021 4091.2471 213 0 0.1831 4.3624 10.8343 0.5065 10.3590 0.0000 17.6957 4.1304 3 31 176.3137 207.7781 91.7446 196.2307 21 1 4 2 3 0 3 1 4 0 4 1 3 0 1 1 6 4 2 3 3 0 0 457 457 PSA A A\ncav_id drug_score volume nb_asph inter_chain apol_asph_proportion mean_asph_radius as_density mean_asph_solv_acc mean_loc_hyd_dens flex hydrophobicity_score volume_score charge_score polarity_score a0_apol a0_pol af_apol af_pol n_abpa ala cys asp glu phe gly his ile lys leu met asn pro gln arg ser thr val trp tyr chain_1_type chain_2_type num_res_chain_1 num_res_chain_2 lig_het_tag name_chain_1 name_chain_2\n1 0.1847 4801.9624 204 0 0.3529 4.4814 10.8531 0.5450 22.0000 0.0000 27.5882 3.4706 -8 26 183.5595 226.1442 124.2374 226.0680 11 1 0 0 7 0 2 1 7 0 8 4 0 0 4 0 9 5 0 2 1 0 0 328 328 NULL A A\ncav_id drug_score volume nb_asph inter_chain apol_asph_proportion mean_asph_radius as_density mean_asph_solv_acc mean_loc_hyd_dens flex hydrophobicity_score volume_score charge_score polarity_score a0_apol a0_pol af_apol af_pol n_abpa ala cys asp glu phe gly his ile lys leu met asn pro gln arg ser thr val trp tyr chain_1_type chain_2_type num_res_chain_1 num_res_chain_2 lig_het_tag name_chain_1 name_chain_2\n1 1.0000 2998.7053 187 0 0.5241 4.3207 11.5341 0.5341 48.6735 0.0000 34.3462 5.0769 3 16 107.4789 84.2598 47.7836 96.3200 8 1 2 1 2 0 0 1 1 1 1 3 3 0 3 0 1 0 1 4 1 0 0 238 238 NULL A A\ncav_id drug_score volume nb_asph inter_chain apol_asph_proportion mean_asph_radius as_density mean_asph_solv_acc mean_loc_hyd_dens flex hydrophobicity_score volume_score charge_score polarity_score a0_apol a0_pol af_apol af_pol n_abpa ala cys asp glu phe gly his ile lys leu met asn pro gln arg ser thr val trp tyr chain_1_type chain_2_type num_res_chain_1 num_res_chain_2 lig_het_tag name_chain_1 name_chain_2\n1 0.9998 1552.9973 110 0 0.4182 4.5201 6.7627 0.4934 36.8261 0.0000 34.2593 4.8519 0 17 105.0637 48.2599 82.1878 27.8238 12 1 1 2 0 0 3 2 0 0 2 1 1 0 3 1 2 0 0 6 2 0 0 594 594 NULL A A\ncav_id drug_score volume nb_asph inter_chain apol_asph_proportion mean_asph_radius as_density mean_asph_solv_acc mean_loc_hyd_dens flex hydrophobicity_score volume_score charge_score polarity_score a0_apol a0_pol af_apol af_pol n_abpa ala cys asp glu phe gly his ile lys leu met asn pro gln arg ser thr val trp tyr chain_1_type chain_2_type num_res_chain_1 num_res_chain_2 lig_het_tag name_chain_1 name_chain_2\n1 0.0044 3875.7029 152 0 0.1513 4.4958 9.8519 0.5972 9.5652 0.0000 -7.5946 3.4865 -7 27 114.7247 187.8280 70.7198 141.5900 15 2 3 2 8 0 0 4 4 2 0 1 0 0 0 2 2 4 1 1 1 0 0 499 499 NULL A A\n\n\nLet’s clean this up the geeky way:\nawk '{ print \"fpocket -f \" $1 \" -a \"$2 \" -d\"}' list.txt | sh | awk '{if(NR%2==0)print}'\nThis should only give the descriptors:\n1 0.0021 3972.3301 213 0 0.1831 4.3624 10.8343 0.5065 10.3590 0.0000 17.6957 4.1304 3 31 176.3137 207.7781 91.7446 196.2307 21 1 4 2 3 0 3 1 4 0 4 1 3 0 1 1 6 4 2 3 3 0 0 457 457 PSA A A\n1 0.1847 4604.5068 204 0 0.3529 4.4814 10.8531 0.5450 22.0000 0.0000 27.5882 3.4706 -8 26 183.5595 226.1442 124.2374 226.0680 11 1 0 0 7 0 2 1 7 0 8 4 0 0 4 0 9 5 0 2 1 0 0 328 328 NULL A A\n1 1.0000 2895.7646 187 0 0.5241 4.3207 11.5341 0.5341 48.6735 0.0000 34.3462 5.0769 3 16 107.4789 84.2598 47.7836 96.3200 8 1 2 1 2 0 0 1 1 1 1 3 3 0 3 0 1 0 1 4 1 0 0 238 238 NULL A A\n1 0.9998 1574.4559 110 0 0.4182 4.5201 6.7627 0.4934 36.8261 0.0000 34.2593 4.8519 0 17 105.0637 48.2599 82.1878 27.8238 12 1 1 2 0 0 3 2 0 0 2 1 1 0 3 1 2 0 0 6 2 0 0 594 594 NULL A A\n1 0.0044 3794.7029 152 0 0.1513 4.4958 9.8519 0.5972 9.5652 0.0000 -7.5946 3.4865 -7 27 114.7247 187.8280 70.7198 141.5900 15 2 3 2 8 0 0 4 4 2 0 1 0 0 0 2 2 4 1 1 1 0 0 499 499 NULL A A\nI did this on a larger list of peptide binding structures and this is typically a good way to start studying some of the properties of these epitopes compared to drug binding sites or others.\n\nimport seaborn as sns\nimport pandas as pd\nimport matplotlib.pyplot as plt\nsns.set_context('notebook')\nsns.set_style('dark')\n\n\ndf=pd.read_table('peptide_out.txt',delim_whitespace=True,header=None,names=[\"cav_id\",\"drug_score\",\"volume\",\"nb_asph\",\"inter_chain\",\"apol_asph_proportion\",\"mean_asph_radius\",\"as_density\",\"mean_asph_solv_acc\",\"mean_loc_hyd_dens\",\"flex\",\"hydrophobicity_score\",\"volume_score\",\"charge_score\",\"polarity_score\",\"a0_apol\",\"a0_pol\",\"af_apol\",\"af_pol\",\"n_abpa\",\"ala\",\"cys\",\"asp\",\"glu\",\"phe\",\"gly\",\"his\",\"ile\",\"lys\",\"leu\",\"met\",\"asn\",\"pro\",\"gln\",\"arg\",\"ser\",\"thr\",\"val\",\"trp\",\"tyr\",\"chain_1_type\",\"chain_2_type\",\"num_res_chain_1\",\"num_res_chain_2\",\"lig_het_tag\",\"name_chain_1\",\"name_chain_2\"])\n# d=as.data.frame(read.table(\"peptide_out.txt\",sep=\" \", header=TRUE, col.names=c(\"cav_id\",\"drug_score\",\"volume\",\"nb_asph\",\"inter_chain\",\"apol_asph_proportion\",\"mean_asph_radius\",\"as_density\",\"mean_asph_solv_acc\",\"mean_loc_hyd_dens\",\"flex\",\"hydrophobicity_score\",\"volume_score\",\"charge_score\",\"polarity_score\",\"a0_apol\",\"a0_pol\",\"af_apol\",\"af_pol\",\"n_abpa\",\"ala\",\"cys\",\"asp\",\"glu\",\"phe\",\"gly\",\"his\",\"ile\",\"lys\",\"leu\",\"met\",\"asn\",\"pro\",\"gln\",\"arg\",\"ser\",\"thr\",\"val\",\"trp\",\"tyr\",\"chain_1_type\",\"chain_2_type\",\"num_res_chain_1\",\"num_res_chain_2\",\"lig_het_tag\",\"name_chain_1\",\"name_chain_2\")))\np=sns.histplot(data=df, x=\"a0_apol\", color=\"skyblue\",bins=20, label=\"apolar surface area\", kde=True)\np.set(xlabel='Surface in A^2', ylabel='Count')\n\np=sns.histplot(data=df, bins=20,x=\"a0_pol\", color=\"red\", label=\"polar surface area\", kde=True)\np.set(xlabel='Surface in A^2', ylabel='Count')\n\np.legend() \n\n&lt;matplotlib.legend.Legend at 0x7fb9ebf9ee80&gt;\n\n\n\n\n\n\nsns.scatterplot(data=df, x=\"n_abpa\", y=\"a0_apol\")\n\n&lt;AxesSubplot:xlabel='n_abpa', ylabel='a0_apol'&gt;\n\n\n\n\n\nThe plot above shows the relationship between the number of ABPA’s (almost burried polar atoms - if you don’t know what these are, you should read this paper on shielded hydrogen bonds and the apolar surface area. Coloring done is by volume of the “pocket”."
  },
  {
    "objectID": "posts/post-with-code/2021-02-02-fpocket-towards-biologics/2021-02-02-fpocket-towards-biologics.html#perspectives",
    "href": "posts/post-with-code/2021-02-02-fpocket-towards-biologics/2021-02-02-fpocket-towards-biologics.html#perspectives",
    "title": "fpocket 4.0 - Towards biologics",
    "section": "Perspectives",
    "text": "Perspectives\nAll of these new functionalities (a part from the support of yet another “useless” file format) set the grounds for characterization of various types of binding epitopes using fpocket. This can terefore be used for functional characterization of protein structures, ultimately indicating where might bind what on a protein structure.\nBut still a few sleepless nights to go until we can achieve that. Fortunately everything is opensource, so you can do that before!!! ;)"
  },
  {
    "objectID": "posts/post-with-code/2021-02-16-torsion-angle-scans-xtb/2021-02-16-torsion-angle-scans-xtb.html",
    "href": "posts/post-with-code/2021-02-16-torsion-angle-scans-xtb/2021-02-16-torsion-angle-scans-xtb.html",
    "title": "Torsion angle scan with rdkit & xtb",
    "section": "",
    "text": "Post #4 will be along the lines of dihedral / torsion angle analysis again. The aim is to log some of the hurdles I had to overcome to run a torsion angle analysis with xtb and / or rdkit.\nWhat I’m trying to accomplish here is mainly to see how torsion angle scans can be performed - easily and robustly - using open source tools available. This is in preparation of a larger work track on analysing the data from the COD, where first steps have already been set here."
  },
  {
    "objectID": "posts/post-with-code/2021-02-16-torsion-angle-scans-xtb/2021-02-16-torsion-angle-scans-xtb.html#aim",
    "href": "posts/post-with-code/2021-02-16-torsion-angle-scans-xtb/2021-02-16-torsion-angle-scans-xtb.html#aim",
    "title": "Torsion angle scan with rdkit & xtb",
    "section": "Aim",
    "text": "Aim\nGiven an input molecule and a particular torsion angle I’d like to see what the energy langscape of the molecule looks like when rotating around that torsion angle. I’d like to know how easy/complicated this is using two different tools:\n\nrdkit with the integrated MMFF\nxtb from the Grimme lab\n\nThe post is also inspired by an older post done by iwatobipen analyzing openforcefield with Ani2 on some torsion energy predictions using the torsion drive dataset from the openforcefield initiative\nAll code used for this post is available on this separate repo, as it uses a slightly different environment (you’ll see why)."
  },
  {
    "objectID": "posts/post-with-code/2021-02-16-torsion-angle-scans-xtb/2021-02-16-torsion-angle-scans-xtb.html#dihedral-scan-with-rdkit",
    "href": "posts/post-with-code/2021-02-16-torsion-angle-scans-xtb/2021-02-16-torsion-angle-scans-xtb.html#dihedral-scan-with-rdkit",
    "title": "Torsion angle scan with rdkit & xtb",
    "section": "Dihedral scan with rdkit",
    "text": "Dihedral scan with rdkit\nI don’t really know why, but I started out with this molecule here:\n\n\nCode\nfrom rdkit import Chem\nfrom rdkit.Chem import AllChem\nfrom rdkit.Chem import Draw\nmol=Chem.AddHs(Chem.MolFromSmiles('CCCOC1=CC=C(Cl)C(C)=C1'))\nfor i, a in enumerate(mol.GetAtoms()):\n        a.SetAtomMapNum(i)\nAllChem.EmbedMolecule(mol,randomSeed=10)    #generate an initial random conformation (randomSeed is fixed to have something reproducible)\n#mol\nDraw.MolToFile(mol,\"mol.png\",includeAtomNumbers=True,highlightAtoms=(1,2,3,4))        #sorry - rdkit 2019.03 issues with newer python versions (I guess)\n\n\n\nThe torsion angle I’m interested in is highlighted in red and situated between carbons 1,2,3 & 4. Now let’s try to set up a torsion angle scan in rdkit using MMFF (UFF should be similar procedure … )\n\nfrom rdkit.Chem import rdMolTransforms\nimport copy\nimport pandas as pd\nfrom rdkit.Chem import rdForceFieldHelpers\nfrom rdkit.Chem import ChemicalForceFields\nfrom rdkit.Chem import rdMolTransforms\n\n\nconformer=mol.GetConformer(0)\n\nm2=copy.deepcopy(mol)\nmp2 = AllChem.MMFFGetMoleculeProperties(m2)\n\nenergy=[]\nconfid=0\nangles=range(-180,182,2)\n\nprint(\"Initial angle:\")\nprint(rdMolTransforms.GetDihedralDeg(conformer,1,2,3,4))\nfor angle in angles:\n    confid+=1\n    ff2 = AllChem.MMFFGetMoleculeForceField(m2, mp2)\n    ff2.MMFFAddTorsionConstraint(1,2,3,4, False, angle - .2, angle + .2, 1000.0)\n    ff2.Minimize()\n    energy.append(ff2.CalcEnergy())\n\n    xyz=ff2.Positions()\n    new_conf = Chem.Conformer(mol.GetNumAtoms())\n    for i in range(mol.GetNumAtoms()):\n        new_conf.SetAtomPosition(i, (m2.GetConformer(-1).GetAtomPosition(i)))\n    new_conf.SetId(confid)\n    mol.AddConformer(new_conf)\n\n\ndfrdkit = pd.DataFrame({'angle':angles, 'energy':energy})\n\nInitial angle:\n179.99983170835984\n\n\n\n\nCode\n#! echo: false\nimport seaborn as sns\n\nsns.lineplot(\n    data=dfrdkit,\n    x=\"angle\", y=\"energy\",\n    markers=True, dashes=False\n)\n\n\n&lt;Axes: xlabel='angle', ylabel='energy'&gt;\n\n\n\n\n\n\nI’m printing the angle of the initial conformation here as well & start the scan from around that angle. Before I didn’t and obviously it created a lot of issues with the minimization of the subsequent conformers. Here is the plot from iwatobipen’s post on the same molecule & same torsion scan:\n\nLet’s first have a look at the minimized conformers. Here’s a bit of code to browse through them. I collected all conformations generated with the torsion scan before.\n\n\nCode\npatt = Chem.MolFromSmarts('c1ccccc1');patt\nmatch = mol.GetSubstructMatch(patt)\n\nAllChem.AlignMolConformers(mol,atomIds=match)\n\nconformerIds=[conf.GetId() for conf in mol.GetConformers()]\nw = Chem.SDWriter(\"conformers.sdf\")\nfor cid in range(mol.GetNumConformers()):\n    w.write(mol, confId=cid)\nw.close()\n\nojs_define(conformerIds=list(conformerIds))\n\n\n\n\n\n\n\nCode\nNGL=require(\"ngl@next\")\nviewof trajInput = Inputs.range([1, conformerIds.length], {value: 1, step: 1, label: \"Conformer ID\"});\nmd`Conformer ID: ${conformerIds[trajInput - 1]}`\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\n// Create drawing area\ndivNGLConf = html`&lt;div style=\"width:500px;height:400px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\n\n\n\nCode\ntrajPDB = {\n  let stage = new NGL.Stage(divNGLConf, {clipDist: 0.0, backgroundColor: \"black\"});\n  let pdbString = await FileAttachment(\"conformers.sdf\").blob();\n  let structure = await stage.loadFile(pdbString, {ext: \"sdf\", asTrajectory: true})\n  let traj = structure.addTrajectory().trajectory\n  structure.addRepresentation(\"licorice\");\n  structure.autoView();\n  return traj;\n};\n\n// Create function to update trajectory\nupdate_traj = function(traj, id){\n  traj.setFrame(id)\n};\n\n// Update trajectory based on slider\nupdate_traj(trajPDB, trajInput - 1);\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nYou can use the slider above to browse through the first conformers. They look fairly reasonable to me so far.\nEven though we can observe a peak around 0° that is common between what I have here & iwatobipens post. The wells around -75° and 75° are not that easily distinguishible unfortunately."
  },
  {
    "objectID": "posts/post-with-code/2021-02-16-torsion-angle-scans-xtb/2021-02-16-torsion-angle-scans-xtb.html#dihedral-scan-with-xtb",
    "href": "posts/post-with-code/2021-02-16-torsion-angle-scans-xtb/2021-02-16-torsion-angle-scans-xtb.html#dihedral-scan-with-xtb",
    "title": "Torsion angle scan with rdkit & xtb",
    "section": "Dihedral scan with xtb",
    "text": "Dihedral scan with xtb\nXTB is a toolkit implementing semiempirical quantum mechanics and you can do quite a lot of things. Among these: energy optimization, dihedral scans, constrained optimizations, metadynamics etc…It’s conda packaged, so easy to deploy anywhere. In contrary to things like Gaussian, Jaguar etc, it’s:\n\nfree\nopensource\nactually quite fast\n\nRunning an energy optimization with xtb is rather straightforward and would work like this:\nxtb mol.sdf --opt --charge 0\nThis will write the optimized molecule in an SD file, together with the energy (in hartree).\nXTB also supports dihedral scans as described in the documentation and the examples work well on ethane. The thing is, as usual … we are not working with ethane or 1-Bromo-2-chloroethane (the other example).\nLong story short, I tried to integrate a dihedral scan as described in the documentation, but on my molecule above (which still remains rather simple)\nThis resulted in a ton of segmentation faults (fond memories of Gaussian came back to me) after a few dihedral scan cycles. My suspicion is that the xtb optimizer is not robust enough to allow to resolve really ugly clashes generated during the scan (I’m just guessing here).\nSo here’s the workaround I came up with: preparing “good enough” starting conformations with rdkit and constrained optimizing with xtb and last, gathering the final energy values.\n\n\nCode\nimport os\n# angles=range(-180,180,5)\nxtbenergy=[]\nw = Chem.SDWriter('mol.sdf')\nw.write(mol,confId=1)\nw.close()\n#loop over the previous conformations we obtained with rdkit\nfor idx,deg in enumerate(angles):\n#   Chem.MolToMolFile(mol,'molecule.mol')\n  atoms = '2,3,4,5' #set atoms to define the dihedral - NB: xtb indexes start at 1, rdkit at 0\n  # Now write the xtb input file:\n  fh = open(\"dihedral_constraint.inp\",\"w\")\n  fh.write(\"\"\"$constrain\n    force constant=1.0\n    dihedral: {},{}\n  $end\"\"\".format(atoms,float(deg)))\n  fh.close()\n  # run xtb\n  if idx==1: \n    inputfilename=\"mol.sdf\"\n  else:\n    inputfilename=\"xtbopt.sdf\"\n  os.popen(\"obabel -isdf \"+inputfilename+\" -osdf -Oobabelmol.sdf && export OMP_STACKSIZE=48G && export OMP_NUM_THREADS=12 && xtb obabelmol.sdf --opt vtight --charge 0 --input dihedral_constraint.inp\").read()\n  with open('xtbopt.sdf') as f:\n    first_line = f.readline()\n    xtbenergy.append(float(first_line.split(\"gnorm\")[0].split(\":\")[1]))\n\nprint(xtbenergy)\nprint(angles)\nprint(dfrdkit[\"energy\"])\n\nsns.lineplot(\n    data=dfrdkit,\n    x=\"angle\", y=\"energy\",\n    markers=True, dashes=False\n)\n\n\n[-36.667513607102, -36.667309140177, -36.667281342484, -36.667239620489, -36.667184526773, -36.667117066126, -36.667037048311, -36.666945068211, -36.666842035773, -36.666727935772, -36.666604060224, -36.666472299839, -36.666331713852, -36.666184708292, -36.666031740213, -36.665874503518, -36.665713626478, -36.665550482059, -36.66538825599, -36.665225539683, -36.665065448331, -36.664908207787, -36.664756200554, -36.664609973167, -36.664471049714, -36.664340711715, -36.664220117532, -36.664110543681, -36.664013292087, -36.663929734669, -36.663861827436, -36.663811930617, -36.663785358953, -36.663798737338, -36.664979277748, -36.66520794, -36.665435059634, -36.665662744478, -36.665885124937, -36.666103090883, -36.66631293046, -36.666513718719, -36.666703584448, -36.666881133011, -36.66704466986, -36.667193605558, -36.667326090946, -36.667441655993, -36.667539140451, -36.667617824736, -36.667676838596, -36.667715513415, -36.667733191444, -36.667729259909, -36.667703174391, -36.667654498956, -36.667582681905, -36.667487621575, -36.667369122472, -36.667227133502, -36.667061760273, -36.666873378488, -36.666662375664, -36.666429356721, -36.666175209343, -36.665900780799, -36.665607020687, -36.665295092731, -36.664966346322, -36.664622108195, -36.664264015668, -36.663893894368, -36.663513617705, -36.663125457688, -36.662731505843, -36.662334108898, -36.661935609452, -36.661538373839, -36.661144767473, -36.660757102954, -36.660377606895, -36.660008348515, -36.659651419864, -36.659308746758, -36.658982148344, -36.65867330741, -36.658383810707, -36.658115108876, -36.657868511125, -36.657644953523, -36.657446596701, -36.657273573907, -36.65712674186, -36.657007487457, -36.656916139656, -36.656853449108, -36.656820030572, -36.65681652035, -36.656843563867, -36.656901487252, -36.656991065908, -36.657113141754, -36.657268773622, -36.657460253667, -36.657691643264, -36.657995009871, -36.658377284791, -36.658734779587, -36.659101032723, -36.65947082494, -36.65983907601, -36.660205762865, -36.660568445789, -36.660925547559, -36.661276290406, -36.661622045455, -36.661961151255, -36.662293542142, -36.662618617756, -36.662935539654, -36.663243196539, -36.663539682536, -36.663825629787, -36.664097088781, -36.66435469442, -36.664595178208, -36.664818301433, -36.66502278909, -36.665207515844, -36.66537160691, -36.665514564786, -36.665636254032, -36.665736540925, -36.66581574069, -36.665874412542, -36.665913153582, -36.665933064251, -36.665933964303, -36.665917822483, -36.665884812253, -36.665836013797, -36.665772163003, -36.665693615985, -36.665604836221, -36.665503223322, -36.665391578063, -36.665270323778, -36.665142434253, -36.665007952167, -36.664869075563, -36.664728209023, -36.664586960773, -36.664449514058, -36.664316973593, -36.664201080863, -36.664966618261, -36.665079218636, -36.665198049586, -36.665324534034, -36.665457378424, -36.665594877696, -36.665735947942, -36.665879336208, -36.666023480717, -36.666167690138, -36.666309918055, -36.666449518595, -36.666584866403, -36.666714785838, -36.666838170524, -36.666953893713, -36.667061007153, -36.667158583164, -36.667245753906, -36.667321770371, -36.667385989984, -36.667437794223, -36.667476728724, -36.667502584037, -36.667514883009, -36.667513577254]\nrange(-180, 182, 2)\n0      19.936138\n1      19.942480\n2      19.958324\n3      19.989942\n4      20.018098\n         ...    \n176    19.900734\n177    19.870128\n178    19.849113\n179    19.837853\n180    19.835944\nName: energy, Length: 181, dtype: float64\n\n\n&lt;Axes: xlabel='angle', ylabel='energy'&gt;\n\n\n\n\n\nThis runs for a while, but it’s still reasonably fast. Also, you might have noticed that I specified an argument to the --opt flag. This argument allows you to tweak how loose or precise the optimisation should be. More information on that can be found in the xtb documentation here. In this example I specified a rather precise method. Feel free to play around with them and check the outcome (rather interesting as well).\n\nimport numpy as np\n# angle=np.array(range(180,-180,-1))\n\ndfxtb = pd.DataFrame({'angle':angles, 'xtb':xtbenergy,'MMFF':dfrdkit[\"energy\"]})\n# dfxtb = pd.DataFrame({'angle':angles, 'xtb':xtbenergy})\n\nimport matplotlib.pyplot as plt\nsns.lineplot(x=\"angle\",y=\"xtb\",data=dfxtb, color=\"g\")\nax2 = plt.twinx()\nsns.lineplot(x=\"angle\",y=\"MMFF\",data=dfxtb, color=\"b\", ax=ax2)\n\n&lt;Axes: xlabel='angle', ylabel='MMFF'&gt;\n\n\n\n\n\nOn this plot we can see both results, from rdkit’s MMFF implementation and xtb. Good news…at least they agree on the maximum around 0°. Other than that there are quite important discrepancies on the location of the global minimum and the importance & extent of the energy barriers between them. Interestingly, openFF and ani2 also predict 180° as a global minimum."
  },
  {
    "objectID": "posts/post-with-code/2021-02-16-torsion-angle-scans-xtb/2021-02-16-torsion-angle-scans-xtb.html#comparing-vs-cod",
    "href": "posts/post-with-code/2021-02-16-torsion-angle-scans-xtb/2021-02-16-torsion-angle-scans-xtb.html#comparing-vs-cod",
    "title": "Torsion angle scan with rdkit & xtb",
    "section": "Comparing vs COD",
    "text": "Comparing vs COD\nLet’s double check these results now with the initial work done on the COD (not yet cleaned and curated - so there will be some noise in here still). This is for sure not the only experimental data-source one should use, but I’ll define it as my golden source of truth here within the scope of this post. First I’ll try to identify the smarts patterns from the torsion library that match the dihedral under investigation here:\n\npatterns=pd.read_table(\"list_torsion_patterns.txt\",header=None,usecols=[1])\nselectedPatterns=[]\nfor torsionSmarts in patterns[1]:\n    torsionQuery = Chem.MolFromSmarts(torsionSmarts)\n    matches = mol.GetSubstructMatches(torsionQuery)\n    if(len(matches)&gt;0):\n        if (matches==((1,2,3,4),)):\n            selectedPatterns.append(torsionQuery)\n            print(\"selected: \",torsionSmarts)\n\nselected:  [C:1][CX4H2:2]!@;-[OX2:3][c:4]\nselected:  [!#1:1][CX4H2:2]!@;-[OX2:3][c:4]\nselected:  [C:1][CX4H2:2]!@;-[OX2:3][!#1:4]\nselected:  [!#1:1][CX4H2:2]!@;-[OX2:3][!#1:4]\nselected:  [!#1:1][CX4:2]!@;-[OX2:3][!#1:4]\n\n\nNow we have the selected patterns, let’s run these through the prepared COD molecules (a huge local sd file right now) and gather statistics on angles. NB: the smart patterns used here might be redundant and map the same molecules. So here I’m keeping track of which molecule was previously selected and don’t include it in a subsequent calculation anymore:\n\n\n[C:1][C&X4&H2:2]!@&-[O&X2:3][c:4]\n[!#1:1][C&X4&H2:2]!@&-[O&X2:3][c:4]\n[C:1][C&X4&H2:2]!@&-[O&X2:3][!#1:4]\n[!#1:1][C&X4&H2:2]!@&-[O&X2:3][!#1:4]\n[!#1:1][C&X4:2]!@&-[O&X2:3][!#1:4]\n\n\n[21:00:06] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:00:06] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:07] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:10] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:12] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:19] \n\n****\nPost-condition Violation\nElement '6 H' not found\nViolation occurred on line 93 in file /Users/runner/miniforge3/conda-bld/rdkit_1678104751770/work/Code/GraphMol/PeriodicTable.h\nFailed Expression: anum &gt; -1\n****\n\n[21:00:19] ERROR: Element '6 H' not found\n[21:00:19] ERROR: moving to the beginning of the next molecule\n[21:00:19] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:00:21] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:00:26] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:00:31] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:00:37] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:44] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:00:58] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:01:06] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:01:06] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:01:06] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:01:07] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:01:07] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:01:07] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:01:11] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:01:16] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:01:20] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:01:20] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:01:20] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:01:21] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:01:57] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:02:13] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:02:29] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:02:29] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:02:29] Conflicting single bond directions around double bond at index 5.\n[21:02:29]   BondStereo set to STEREONONE and single bond directions set to NONE.\n[21:02:31] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:02:36] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:02:46] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:02:47] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:02:48] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:02:51] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:02:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:01] \n\n****\nPost-condition Violation\nElement '6 H' not found\nViolation occurred on line 93 in file /Users/runner/miniforge3/conda-bld/rdkit_1678104751770/work/Code/GraphMol/PeriodicTable.h\nFailed Expression: anum &gt; -1\n****\n\n[21:03:01] ERROR: Element '6 H' not found\n[21:03:01] ERROR: moving to the beginning of the next molecule\n[21:03:02] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:03:04] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:03:10] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:03:14] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:03:22] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:30] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:36] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:36] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:36] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:36] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:36] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:36] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:36] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:45] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:54] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:03:55] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:55] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:03:59] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:04:05] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:04:09] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:04:09] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:04:09] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:04:10] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:04:49] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:05:04] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:05:21] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:05:22] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:05:22] Conflicting single bond directions around double bond at index 5.\n[21:05:22]   BondStereo set to STEREONONE and single bond directions set to NONE.\n[21:05:23] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:05:29] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:05:39] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:05:40] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:05:41] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:05:44] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:05:47] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:05:55] \n\n****\nPost-condition Violation\nElement '6 H' not found\nViolation occurred on line 93 in file /Users/runner/miniforge3/conda-bld/rdkit_1678104751770/work/Code/GraphMol/PeriodicTable.h\nFailed Expression: anum &gt; -1\n****\n\n[21:05:55] ERROR: Element '6 H' not found\n[21:05:55] ERROR: moving to the beginning of the next molecule\n[21:05:55] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:05:58] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:06:04] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:06:09] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:06:17] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:27] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:34] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:34] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:34] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:34] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:34] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:34] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:34] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:44] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:54] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:06:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:06:59] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:07:06] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:07:10] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:07:10] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:07:10] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:07:11] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:07:55] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:08:14] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:08:34] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:08:35] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:08:35] Conflicting single bond directions around double bond at index 5.\n[21:08:35]   BondStereo set to STEREONONE and single bond directions set to NONE.\n[21:08:37] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:08:43] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:08:56] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:08:57] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:08:58] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:09:02] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:09:05] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:09:14] \n\n****\nPost-condition Violation\nElement '6 H' not found\nViolation occurred on line 93 in file /Users/runner/miniforge3/conda-bld/rdkit_1678104751770/work/Code/GraphMol/PeriodicTable.h\nFailed Expression: anum &gt; -1\n****\n\n[21:09:14] ERROR: Element '6 H' not found\n[21:09:14] ERROR: moving to the beginning of the next molecule\n[21:09:15] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:09:17] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:09:25] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:09:32] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:09:42] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:09:52] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:01] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:01] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:01] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:01] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:01] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:01] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:01] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:12] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:23] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:23] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:23] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:24] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:10:24] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:24] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:29] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:36] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:41] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:41] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:41] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:10:42] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:11:30] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:11:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:12:11] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:12:12] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:12:12] Conflicting single bond directions around double bond at index 5.\n[21:12:12]   BondStereo set to STEREONONE and single bond directions set to NONE.\n[21:12:14] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:12:21] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:12:33] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:12:34] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:12:36] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:12:40] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:12:43] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:12:54] \n\n****\nPost-condition Violation\nElement '6 H' not found\nViolation occurred on line 93 in file /Users/runner/miniforge3/conda-bld/rdkit_1678104751770/work/Code/GraphMol/PeriodicTable.h\nFailed Expression: anum &gt; -1\n****\n\n[21:12:54] ERROR: Element '6 H' not found\n[21:12:54] ERROR: moving to the beginning of the next molecule\n[21:12:55] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:12:58] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:13:07] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:13:14] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:13:27] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:13:37] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:13:47] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:13:47] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:13:47] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:13:47] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:13:47] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:13:47] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:13:47] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:13:59] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:14:11] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:14:11] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:14:11] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:14:11] Warning: molecule is tagged as 3D, but all Z coords are zero\n[21:14:12] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:14:12] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:14:17] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:14:25] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:14:30] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:14:30] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:14:31] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:14:32] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:15:26] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:15:49] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:16:14] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:16:14] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:16:14] Conflicting single bond directions around double bond at index 5.\n[21:16:14]   BondStereo set to STEREONONE and single bond directions set to NONE.\n[21:16:17] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n[21:16:24] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm.\n\n\nThis runs again for quite some time…so patience is needed. Once this is done, you should see something like that:\n\n#lets convert that to numbers we show in the line-plot together with the previous results\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nangles=range(-180,182,2)\nintervals=pd.interval_range(start=-180, end=180,periods=181)\nbinangles=pd.cut(angles, bins=intervals).value_counts()\n\ndfall = pd.DataFrame({'angle':angles, 'xtb':xtbenergy,'MMFF':dfrdkit[\"energy\"],'cod':np.array(binangles)})\n\nfig, ax = plt.subplots()\nsns.histplot(codangles)\nax.set(xlabel='Angle',ylabel= 'Count')\nax2 = ax.twinx()\nsns.lineplot(x=\"angle\",y=\"xtb\",data=dfall, color=\"g\")\n\n&lt;Axes: xlabel='angle', ylabel='xtb'&gt;\n\n\n\n\n\nSo here we have in blue the results from the COD, in green xtb. Good news is that the positions of the wells seem to be estimated rather well with xtb. MMFF seems slightly off for the preference on 280°. Analysing relative energy differences between local minima, xtb doesn’t follow the trend observed using MMFF & results from the COD here."
  },
  {
    "objectID": "posts/post-with-code/2021-02-16-torsion-angle-scans-xtb/2021-02-16-torsion-angle-scans-xtb.html#conclusion",
    "href": "posts/post-with-code/2021-02-16-torsion-angle-scans-xtb/2021-02-16-torsion-angle-scans-xtb.html#conclusion",
    "title": "Torsion angle scan with rdkit & xtb",
    "section": "Conclusion",
    "text": "Conclusion\nInitially I wanted to run this on a larger set of molecules, but as usual things turn out to be much less robust than anticipated. So more to come in an upcoming post, on other torsion angles - especially the challenging ones.\nThe encouraging aspect here is, that despite all difficulties, one could potentially use this on a larger set of molecules. The instability of xtb on the integrated dihedral scan should be investigated a bit further as well … essentially to make sure that this is not only due to my totally “noob” use of the toolkit - which is very likely."
  },
  {
    "objectID": "posts/post-with-code/2021-01-23-grafting-fragments/2021-01-23-grafting-fragments.html",
    "href": "posts/post-with-code/2021-01-23-grafting-fragments/2021-01-23-grafting-fragments.html",
    "title": "Grafting fragments onto molecules in rdkit - babysteps",
    "section": "",
    "text": "In this quick walkthrough I describe the first steps to attach fragments from a fragment library onto a molecule of interest. The main idea here is to prepare code snippets for the integration of all of this into the web-based 3d-editor project I started with Daniel Alvarez some time ago. As I’m learning a lot of new things about rdkit I prefer to write it up here, as I found most of the relevant information in the mailing list & the rdkit documentation.\n\n\nI’ll go for the same molecule as the one used for now in our BRD4 structure of the 3d editor project - that just comes from one of the official openforcefield examples here.\n\n\n\nI wanted to go for something easy for now … so let’s start with a methyl group ;) I made a quick shoutout on twitter on current available 3D fragments that could be helpful to write such a sketcher. Geoff Hutchison (Mr Avogadro) gave me a great hint to this library here. It contains way more fragments than I’d initially considered for this project and the coordinates seem reasonable & compatible with the systems we’ll manage in the 3d-editor.\nSo I just took the methane from there (for now), ran it through Marvinsketch to replace one of the protons with an R group and then exported the whole thing as mol file (to the best of my knowledge rdkit doesn’t support the chemistry markup language yet).\n\n\n\n\n\nCode\n# https://sourceforge.net/p/rdkit/mailman/message/34922663/ procedure extracted from this support request\nimport rdkit\nfrom rdkit import Chem\nfrom rdkit.Chem.Draw import IPythonConsole\nfrom rdkit.Chem import Draw\nIPythonConsole.ipython_useSVG=True \nimport py3Dmol\nfrom rdkit.Chem import AllChem\nimport copy\nfrom rdkit.Chem.rdMolAlign import AlignMol\n\n\nBelow, the molecule we want to add the methyl group to. We’ll attach it on the triazole ring.\n\n\nCode\n// Create drawing area\ndiv_mol = html`&lt;div style=\"width:400px;height:400px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\n\n\n\nCode\nNGL = require(\"ngl@next\");\n\n   molBlock = await FileAttachment(\"ligand.sdf\").blob();\n\nstage = new NGL.Stage(div_mol, { backgroundColor: \"black\",cameraType: \"orthographic\"});\nstructure = await stage.loadFile(molBlock, {ext: \"sdf\", asTrajectory: false})\nstructure.addRepresentation(\"licorice\",{ \"sele\": \"all\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nstructure.autoView();\n\n\n\n\n\n\n\n\n\nAs the aim is to integrate that into the 3D-editor, the user ultimately will be able to click on the proton where he wants to place the fragment. Thus, we know which exact atom we want to attach it to. Below I’m determining this showing plain atom indices in the rdkit molecule\n\nsuppl = Chem.SDMolSupplier('ligand.sdf',removeHs=False)\nfor mol in suppl:\n    mblock = Chem.MolToMolBlock(mol)\n\nfor atom in mol.GetAtoms():\n        atom.SetAtomMapNum(atom.GetIdx())\nmol2d=copy.deepcopy(mol)\nAllChem.Compute2DCoords(mol2d)    #do this on a copy here\n\nDraw.MolToImage(mol2d, includeAtomNumbers=True)\n\n\n\n\nNext I’m loading the fragment and extract the position of the R-group and the connected atom as atom indices (I’ll need that later). I know this is very limited and ugly for now, but it serves the purpose here & now ;)\n\ndef getAttachmentVector(mol):\n    \"\"\" for a fragment to add, search for the position of the attachment point and extract the atom id's of the attachment point and the connected atom (currently only single bond supported)\n    mol: fragment passed as rdkit molecule\n    return: tuple (atom indices)\n    \"\"\"\n\n    rindex=-1\n    rindexNeighbor=-1\n    for atom in mol.GetAtoms():\n        if(atom.GetAtomicNum()==0):\n            rindex=atom.GetIdx()\n            neighbours=atom.GetNeighbors()\n            if(len(neighbours)==1):\n                rindexNeighbor=neighbours[0].GetIdx()\n            else: \n                print(\"two attachment points not supported yet\")\n                return None\n    return((rindex,rindexNeighbor))\n\n\n\nfragment=Chem.MolFromMolFile('methyl.mol',removeHs=False)\nret=getAttachmentVector(fragment)\n\nfor atom in mol.GetAtoms():\n        atom.SetAtomMapNum(atom.GetIdx())\nif(ret):\n    fragIndex1,fragIndex2=ret\n\nprint(fragIndex1, fragIndex2)\nChem.MolToMolFile(fragment,\"molblock.mol\")\n\n4 1\n\n\n\n\nCode\n// Create drawing area\ndiv_mol_2 = html`&lt;div style=\"width:400px;height:400px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\n\n\n\nCode\nmolBlock2 = await FileAttachment(\"molblock.mol\").blob();\nstage2 = new NGL.Stage(div_mol_2, { backgroundColor: \"black\",cameraType: \"orthographic\"});\nstructure2 = await stage2.loadFile(molBlock2, {ext: \"sdf\", asTrajectory: false})\nstructure2.addRepresentation(\"licorice\",{ \"sele\": \"all\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nstructure2.autoView();\n\n\n\n\n\n\n\n\n\nNow let’s extract also the atom index of the proton, and also the carbon the proton is attached to on the molecule.\n\nqueryAtomIndex=20 #defined by clicking on an atom in the sketcher -&gt; needs to be a proton right now for grafting\n\natom=mol.GetAtomWithIdx(queryAtomIndex)\nneighbours=atom.GetNeighbors()\nif(len(neighbours)==1):\n    rindexNeighbor=neighbours[0].GetIdx()\nelse: \n    print(\"two attachment points not supported yet\")\n    \nmolIndex1=queryAtomIndex\nmolIndex2=rindexNeighbor\nprint(molIndex1,molIndex2)\n\n20 9\n\n\n\n\n\nNow I have the bond of the carbon to proton selected in the molecule and the carbon to R-group in my fragment. These bonds can be aligned onto each other to position the 3D-fragment correctly versus the molecule. This can be conveniently done using the AlignMol function available in rdkit.\n\nAlignMol(fragment,mol,atomMap=((fragIndex2,molIndex1),(fragIndex1,molIndex2))) #important to specify the atomMap here, this aligns only the bonds\n\n0.02749767976054038\n\n\n\n\nCode\n#the rest is just to display things here\nChem.MolToMolFile(mol,\"molblock3.mol\")\nChem.MolToMolFile(fragment,\"fragblock3.mol\")\n\n\n\n\nCode\n// Create drawing area\ndiv_mol_3 = html`&lt;div style=\"width:400px;height:400px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\n\n\n\nCode\nmolBlock3 = await FileAttachment(\"molblock3.mol\").blob();\nfragBlock3 = await FileAttachment(\"fragblock3.mol\").blob();\nstage3 = new NGL.Stage(div_mol_3, { backgroundColor: \"black\",cameraType: \"orthographic\"});\nsmol3=await stage3.loadFile(molBlock3, {ext: \"sdf\", asTrajectory: false});\nsmol3.addRepresentation(\"licorice\",{ \"sele\": \"all\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nsfrag3=await stage3.loadFile(fragBlock3, {ext: \"sdf\", asTrajectory: false});\nsfrag3.addRepresentation(\"licorice\",{ \"sele\": \"all\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nsfrag3.autoView();\n\n\n\n\n\n\n\n\n\nAs you can see, the fragment gets placed correctly on top of the proton. Now we have however a few overlapping atoms in place. We can use the rdkit edition functions to address this and combine both overlapping molecules now into a final single molecule.\n\ndef connectMols(mol1, mol2, atom1, atom2):\n        \"\"\"function copied from here https://github.com/molecularsets/moses/blob/master/moses/baselines/combinatorial.py\"\"\"\n        combined = Chem.CombineMols(mol1, mol2)\n        emol = Chem.EditableMol(combined)\n        neighbor1_idx = atom1.GetNeighbors()[0].GetIdx()\n        neighbor2_idx = atom2.GetNeighbors()[0].GetIdx()\n        atom1_idx = atom1.GetIdx()\n        atom2_idx = atom2.GetIdx()\n        bond_order = atom2.GetBonds()[0].GetBondType()\n        emol.AddBond(neighbor1_idx,\n                     neighbor2_idx + mol1.GetNumAtoms(),\n                     order=bond_order)\n        emol.RemoveAtom(atom2_idx + mol1.GetNumAtoms())\n        emol.RemoveAtom(atom1_idx)\n        mol = emol.GetMol()\n        return mol \n\nfinalMol=connectMols(mol,fragment,mol.GetAtomWithIdx(molIndex1),fragment.GetAtomWithIdx(fragIndex1))\nChem.SanitizeMol(finalMol)\n\nrdkit.Chem.rdmolops.SanitizeFlags.SANITIZE_NONE\n\n\n\n\nCode\n#the rest is just to display things here\nChem.MolToMolFile(finalMol,\"finalmol.mol\")\n\n\n\n\nCode\n// Create drawing area\ndiv_mol_4 = html`&lt;div style=\"width:400px;height:400px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\n\n\n\nCode\nmolBlock4 = await FileAttachment(\"finalmol.mol\").blob();\nstage4 = new NGL.Stage(div_mol_4, { backgroundColor: \"black\",cameraType: \"orthographic\"});\nfinalmol=await stage4.loadFile(molBlock4, {ext: \"sdf\", asTrajectory: false});\nfinalmol.addRepresentation(\"licorice\",{ \"sele\": \"all\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nfinalmol.autoView();\n\n\n\n\n\n\n\n\n\nAnd voilà. Our methyl is nicely placed and oriented. That’s one of the easiest cases and we’ll have to consider torsion angles & protein environment at a later stage as well, but this should provide first basic steps for simple additions like the one done here."
  },
  {
    "objectID": "posts/post-with-code/2021-01-23-grafting-fragments/2021-01-23-grafting-fragments.html#context",
    "href": "posts/post-with-code/2021-01-23-grafting-fragments/2021-01-23-grafting-fragments.html#context",
    "title": "Grafting fragments onto molecules in rdkit - babysteps",
    "section": "",
    "text": "In this quick walkthrough I describe the first steps to attach fragments from a fragment library onto a molecule of interest. The main idea here is to prepare code snippets for the integration of all of this into the web-based 3d-editor project I started with Daniel Alvarez some time ago. As I’m learning a lot of new things about rdkit I prefer to write it up here, as I found most of the relevant information in the mailing list & the rdkit documentation.\n\n\nI’ll go for the same molecule as the one used for now in our BRD4 structure of the 3d editor project - that just comes from one of the official openforcefield examples here.\n\n\n\nI wanted to go for something easy for now … so let’s start with a methyl group ;) I made a quick shoutout on twitter on current available 3D fragments that could be helpful to write such a sketcher. Geoff Hutchison (Mr Avogadro) gave me a great hint to this library here. It contains way more fragments than I’d initially considered for this project and the coordinates seem reasonable & compatible with the systems we’ll manage in the 3d-editor.\nSo I just took the methane from there (for now), ran it through Marvinsketch to replace one of the protons with an R group and then exported the whole thing as mol file (to the best of my knowledge rdkit doesn’t support the chemistry markup language yet).\n\n\n\n\n\nCode\n# https://sourceforge.net/p/rdkit/mailman/message/34922663/ procedure extracted from this support request\nimport rdkit\nfrom rdkit import Chem\nfrom rdkit.Chem.Draw import IPythonConsole\nfrom rdkit.Chem import Draw\nIPythonConsole.ipython_useSVG=True \nimport py3Dmol\nfrom rdkit.Chem import AllChem\nimport copy\nfrom rdkit.Chem.rdMolAlign import AlignMol\n\n\nBelow, the molecule we want to add the methyl group to. We’ll attach it on the triazole ring.\n\n\nCode\n// Create drawing area\ndiv_mol = html`&lt;div style=\"width:400px;height:400px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\n\n\n\nCode\nNGL = require(\"ngl@next\");\n\n   molBlock = await FileAttachment(\"ligand.sdf\").blob();\n\nstage = new NGL.Stage(div_mol, { backgroundColor: \"black\",cameraType: \"orthographic\"});\nstructure = await stage.loadFile(molBlock, {ext: \"sdf\", asTrajectory: false})\nstructure.addRepresentation(\"licorice\",{ \"sele\": \"all\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nstructure.autoView();\n\n\n\n\n\n\n\n\n\nAs the aim is to integrate that into the 3D-editor, the user ultimately will be able to click on the proton where he wants to place the fragment. Thus, we know which exact atom we want to attach it to. Below I’m determining this showing plain atom indices in the rdkit molecule\n\nsuppl = Chem.SDMolSupplier('ligand.sdf',removeHs=False)\nfor mol in suppl:\n    mblock = Chem.MolToMolBlock(mol)\n\nfor atom in mol.GetAtoms():\n        atom.SetAtomMapNum(atom.GetIdx())\nmol2d=copy.deepcopy(mol)\nAllChem.Compute2DCoords(mol2d)    #do this on a copy here\n\nDraw.MolToImage(mol2d, includeAtomNumbers=True)\n\n\n\n\nNext I’m loading the fragment and extract the position of the R-group and the connected atom as atom indices (I’ll need that later). I know this is very limited and ugly for now, but it serves the purpose here & now ;)\n\ndef getAttachmentVector(mol):\n    \"\"\" for a fragment to add, search for the position of the attachment point and extract the atom id's of the attachment point and the connected atom (currently only single bond supported)\n    mol: fragment passed as rdkit molecule\n    return: tuple (atom indices)\n    \"\"\"\n\n    rindex=-1\n    rindexNeighbor=-1\n    for atom in mol.GetAtoms():\n        if(atom.GetAtomicNum()==0):\n            rindex=atom.GetIdx()\n            neighbours=atom.GetNeighbors()\n            if(len(neighbours)==1):\n                rindexNeighbor=neighbours[0].GetIdx()\n            else: \n                print(\"two attachment points not supported yet\")\n                return None\n    return((rindex,rindexNeighbor))\n\n\n\nfragment=Chem.MolFromMolFile('methyl.mol',removeHs=False)\nret=getAttachmentVector(fragment)\n\nfor atom in mol.GetAtoms():\n        atom.SetAtomMapNum(atom.GetIdx())\nif(ret):\n    fragIndex1,fragIndex2=ret\n\nprint(fragIndex1, fragIndex2)\nChem.MolToMolFile(fragment,\"molblock.mol\")\n\n4 1\n\n\n\n\nCode\n// Create drawing area\ndiv_mol_2 = html`&lt;div style=\"width:400px;height:400px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\n\n\n\nCode\nmolBlock2 = await FileAttachment(\"molblock.mol\").blob();\nstage2 = new NGL.Stage(div_mol_2, { backgroundColor: \"black\",cameraType: \"orthographic\"});\nstructure2 = await stage2.loadFile(molBlock2, {ext: \"sdf\", asTrajectory: false})\nstructure2.addRepresentation(\"licorice\",{ \"sele\": \"all\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nstructure2.autoView();\n\n\n\n\n\n\n\n\n\nNow let’s extract also the atom index of the proton, and also the carbon the proton is attached to on the molecule.\n\nqueryAtomIndex=20 #defined by clicking on an atom in the sketcher -&gt; needs to be a proton right now for grafting\n\natom=mol.GetAtomWithIdx(queryAtomIndex)\nneighbours=atom.GetNeighbors()\nif(len(neighbours)==1):\n    rindexNeighbor=neighbours[0].GetIdx()\nelse: \n    print(\"two attachment points not supported yet\")\n    \nmolIndex1=queryAtomIndex\nmolIndex2=rindexNeighbor\nprint(molIndex1,molIndex2)\n\n20 9\n\n\n\n\n\nNow I have the bond of the carbon to proton selected in the molecule and the carbon to R-group in my fragment. These bonds can be aligned onto each other to position the 3D-fragment correctly versus the molecule. This can be conveniently done using the AlignMol function available in rdkit.\n\nAlignMol(fragment,mol,atomMap=((fragIndex2,molIndex1),(fragIndex1,molIndex2))) #important to specify the atomMap here, this aligns only the bonds\n\n0.02749767976054038\n\n\n\n\nCode\n#the rest is just to display things here\nChem.MolToMolFile(mol,\"molblock3.mol\")\nChem.MolToMolFile(fragment,\"fragblock3.mol\")\n\n\n\n\nCode\n// Create drawing area\ndiv_mol_3 = html`&lt;div style=\"width:400px;height:400px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\n\n\n\nCode\nmolBlock3 = await FileAttachment(\"molblock3.mol\").blob();\nfragBlock3 = await FileAttachment(\"fragblock3.mol\").blob();\nstage3 = new NGL.Stage(div_mol_3, { backgroundColor: \"black\",cameraType: \"orthographic\"});\nsmol3=await stage3.loadFile(molBlock3, {ext: \"sdf\", asTrajectory: false});\nsmol3.addRepresentation(\"licorice\",{ \"sele\": \"all\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nsfrag3=await stage3.loadFile(fragBlock3, {ext: \"sdf\", asTrajectory: false});\nsfrag3.addRepresentation(\"licorice\",{ \"sele\": \"all\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nsfrag3.autoView();\n\n\n\n\n\n\n\n\n\nAs you can see, the fragment gets placed correctly on top of the proton. Now we have however a few overlapping atoms in place. We can use the rdkit edition functions to address this and combine both overlapping molecules now into a final single molecule.\n\ndef connectMols(mol1, mol2, atom1, atom2):\n        \"\"\"function copied from here https://github.com/molecularsets/moses/blob/master/moses/baselines/combinatorial.py\"\"\"\n        combined = Chem.CombineMols(mol1, mol2)\n        emol = Chem.EditableMol(combined)\n        neighbor1_idx = atom1.GetNeighbors()[0].GetIdx()\n        neighbor2_idx = atom2.GetNeighbors()[0].GetIdx()\n        atom1_idx = atom1.GetIdx()\n        atom2_idx = atom2.GetIdx()\n        bond_order = atom2.GetBonds()[0].GetBondType()\n        emol.AddBond(neighbor1_idx,\n                     neighbor2_idx + mol1.GetNumAtoms(),\n                     order=bond_order)\n        emol.RemoveAtom(atom2_idx + mol1.GetNumAtoms())\n        emol.RemoveAtom(atom1_idx)\n        mol = emol.GetMol()\n        return mol \n\nfinalMol=connectMols(mol,fragment,mol.GetAtomWithIdx(molIndex1),fragment.GetAtomWithIdx(fragIndex1))\nChem.SanitizeMol(finalMol)\n\nrdkit.Chem.rdmolops.SanitizeFlags.SANITIZE_NONE\n\n\n\n\nCode\n#the rest is just to display things here\nChem.MolToMolFile(finalMol,\"finalmol.mol\")\n\n\n\n\nCode\n// Create drawing area\ndiv_mol_4 = html`&lt;div style=\"width:400px;height:400px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\n\n\n\nCode\nmolBlock4 = await FileAttachment(\"finalmol.mol\").blob();\nstage4 = new NGL.Stage(div_mol_4, { backgroundColor: \"black\",cameraType: \"orthographic\"});\nfinalmol=await stage4.loadFile(molBlock4, {ext: \"sdf\", asTrajectory: false});\nfinalmol.addRepresentation(\"licorice\",{ \"sele\": \"all\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nfinalmol.autoView();\n\n\n\n\n\n\n\n\n\nAnd voilà. Our methyl is nicely placed and oriented. That’s one of the easiest cases and we’ll have to consider torsion angles & protein environment at a later stage as well, but this should provide first basic steps for simple additions like the one done here."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Spinning coral",
    "section": "",
    "text": "Order By\n       Default\n         \n          Title\n        \n         \n          Date - Oldest\n        \n         \n          Date - Newest\n        \n         \n          Author\n        \n     \n  \n    \n      \n      \n    \n\n\n\n\n\n\n\n\nForced revamp ongoing\n\n\n\nnews\n\n\n\n\n\n\n\nPeter Schmidtke\n\n\nApr 8, 2023\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBinding site comparison - current benchmark issues\n\n\n\nbinding site\n\n\npocket\n\n\ncavity\n\n\npocket comparison\n\n\nstructure-based drug design\n\n\n\nA (long) comment on current pitfalls on binding site comparison papers & their benchmarking\n\n\n\n\n\n\nNov 7, 2022\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTorsion angle scan with rdkit & xtb\n\n\n\ntorsion\n\n\ndihedral\n\n\noss\n\n\nopensource\n\n\nrdkit\n\n\nxtb\n\n\nenergy\n\n\n\nLog of the hassle doing torsion angle scans with rdkit & xtb - ultimately comparing results to the crystallography open database\n\n\n\nPeter Schmidtke\n\n\nFeb 16, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nfpocket 4.0 - Towards biologics\n\n\n\nfpocket\n\n\npockets\n\n\ncavity\n\n\nPPI\n\n\nprotein\n\n\nepitope\n\n\nDNA\n\n\nRNA\n\n\nantibody\n\n\n\nA quick demo of all the new fpocket features with special focus on protein-peptide interfaces\n\n\n\nPeter Schmidtke\n\n\nFeb 2, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCrystallography Open Database and torsion angle statistics with rdkit\n\n\n\nrdkit\n\n\ncrystallography\n\n\nsmall molecule xray\n\n\nxray\n\n\ndatabase\n\n\n\nFirst steps to check how easy / feasible it is to extract torsion angle statistics from the COD\n\n\n\nPeter Schmidtke\n\n\nJan 25, 2021\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGrafting fragments onto molecules in rdkit - babysteps\n\n\n\nrdkit\n\n\n3d-editor\n\n\n\nThis is a quick set-up for attaching a fragment to a molecule on a particular location.\n\n\n\nPeter Schmidtke\n\n\nJan 23, 2021\n\n\n\n\n\n\n\n\nNo matching items"
  },
  {
    "objectID": "about.html",
    "href": "about.html",
    "title": "About",
    "section": "",
    "text": "About this blog\nDuring my everyday work I’m in contact with a lot of people supporting early stage drug discovery. During this work I use proprietary tools, but also several open source tools. Usually you face several issues a lot of other people faced before or will face in the future. One aim of this blog is to share these quirks and allow others to gain some time, trigger discussions, get feedback and improve the field as openly as possible.\nI’ll likely write about whatever crosses my mind here, but it’ll surely focus on topics around cheminformatics, bioinformatics, binding sites, maybe a few papers. Let’s see where this goes."
  },
  {
    "objectID": "about.html#about-myself",
    "href": "about.html#about-myself",
    "title": "About",
    "section": "About myself",
    "text": "About myself\nI’m a European citizen, dad of two beautiful girls and I am currently stranded in France. I did my PhD in Xavier Barril’s excellent group at the University of Barcelona, then a post-doc in molecular modelling within a French pharma company. However, I spent most of my “professional career” at Discngine based in Paris, France. A great place to work, even though we tend not to apply for these fancy marketing labels ;)\nTogether with Vincent Le Guilloux (also at Discngine now) we developed fpocket while we were still finishing our Bioinformatics Masters degree. After that I wrote a bunch of papers (during my PhD) mainly on binding site characterisation, druggability assessment, structure kinetic relationships and a couple of other things more.\nTogether with a great team at Discngine, I also started 3decision a subscription-based structure repo & analytics platform a few years back now."
  },
  {
    "objectID": "about.html#spinning-coral",
    "href": "about.html#spinning-coral",
    "title": "About",
    "section": "Spinning coral",
    "text": "Spinning coral\nThe name of the blog was inspired by my 7 years old daughter, Anna. She always wants to play with 3D molecular viewers on my screen. She started to do that when she was around 5, having no idea what a protein is and looks like she basically asks me: “Daddy, may I spin the coral again?”."
  },
  {
    "objectID": "about.html#inspirations",
    "href": "about.html#inspirations",
    "title": "About",
    "section": "Inspirations",
    "text": "Inspirations\nHaving a blog on cheminformatics etc is not the brightest and newest idea. I’ve had a lot of good reads thanks to all of these excellent & very well known blogs:\n\nhttps://iwatobipen.wordpress.com/\nhttp://practicalcheminformatics.blogspot.com/\nhttps://greglandrum.github.io/rdkit-blog/"
  },
  {
    "objectID": "wip/2023-04-03-binding-site-comparison-benchmark-I/2023-04-03-binding-site-comparison-benchmark-i.html",
    "href": "wip/2023-04-03-binding-site-comparison-benchmark-I/2023-04-03-binding-site-comparison-benchmark-i.html",
    "title": "Binding Site Comparison Benchmarks - I",
    "section": "",
    "text": "In this article I’ll go through the overall thought process of setting up a benchmark set. For the sake of simplicity I’ll do it for a single target to evaluate the performance of a binding site comparison algorithm. I’ll try to provide code whenever possible against public resources or snippets if a bit of scripting is needed. When the public domain information is insufficient, I might fall back to resources like 3decision, MOE families, which is not public domain knowledge, but can very much help fulfill the task at hand."
  },
  {
    "objectID": "wip/2023-04-03-binding-site-comparison-benchmark-I/2023-04-03-binding-site-comparison-benchmark-i.html#why-hsp90-as-a-first-example",
    "href": "wip/2023-04-03-binding-site-comparison-benchmark-I/2023-04-03-binding-site-comparison-benchmark-i.html#why-hsp90-as-a-first-example",
    "title": "Binding Site Comparison Benchmarks - I",
    "section": "Why HSP90 as a first example",
    "text": "Why HSP90 as a first example\n\nHSP90 has a lot of structures available in the public domain.\nIt’s not part of any gigantic protein family (kinases, GPCR’s etc), which keeps the initial comparison space to cover a bit smaller.\nThe fold of the protein is still conserved among several other proteins, so there’s matter for detecting expected similarities\nIt binds ATP, such as a lot of proteins in nature - which is interesting for the if I bind the same molecule I must be similar conundrum.\nThe binding site can undergo important conformational changes, which is good to evaluate sensity on conformation\nWater plays a very important role upon binding of small molecules into the ATP binding site"
  },
  {
    "objectID": "wip/2023-04-03-binding-site-comparison-benchmark-I/2023-04-03-binding-site-comparison-benchmark-i.html#domain-architecture",
    "href": "wip/2023-04-03-binding-site-comparison-benchmark-I/2023-04-03-binding-site-comparison-benchmark-i.html#domain-architecture",
    "title": "Binding Site Comparison Benchmarks - I",
    "section": "Domain architecture",
    "text": "Domain architecture\nHSP90 alpha human is composed of two domains: - the N-terminal Histidine kinase, DNA gyrase B and HSP90-like ATPase domain (ranging from amino acid 40 to 193) - the C-terminal HSP90 protein domain (196-714)\nThe ATP binding site of interest is on the N-terminal part and this is the part that you have the most crystal strucutres for in the RCSB today. A full length Alphafold model available in the public domain. NB: there appears to be another ATP binding site on the C-terminal part, that is only accessible when activated - so interesting to maybe look out for that one as well."
  },
  {
    "objectID": "wip/2023-04-03-binding-site-comparison-benchmark-I/2023-04-03-binding-site-comparison-benchmark-i.html#the-topology-of-the-atp-binding-site-n-ter",
    "href": "wip/2023-04-03-binding-site-comparison-benchmark-I/2023-04-03-binding-site-comparison-benchmark-i.html#the-topology-of-the-atp-binding-site-n-ter",
    "title": "Binding Site Comparison Benchmarks - I",
    "section": "The topology of the ATP binding site (N-ter)",
    "text": "The topology of the ATP binding site (N-ter)\n\n\nCode\n// Create drawing area\ndivNGL = html`&lt;div style=\"width:800px;height:600px;position:relative\"&gt;&lt;/div&gt;`;\n\n\n\n\n\n\n\n\n\nCode\nNGL = require(\"ngl@next\");\n// Create trajectory object\nstage = new NGL.Stage(divNGL, { backgroundColor: \"black\",cameraType: \"orthographic\"});\npdbString = await FileAttachment(\"3t0z.pdb\").blob();\nstructure = await stage.loadFile(pdbString, {ext: \"pdb\", asTrajectory: false})\nstructure.addRepresentation(\"cartoon\",{ \"sele\": \"protein\", \"color\": \"residueindex\"});\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCode\nstructure.addRepresentation(\"ball+stick\",{ \"sele\": \"hetero and _C\", \"color\": \"yellow\"});\n\n\n\n\n\n\n\n\n\nCode\nstructure.addRepresentation(\"ball+stick\",{ \"sele\": \"hetero\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\nCode\nstructure.addRepresentation(\"licorice\",{ \"sele\": \"47-55 or 91 or 93 or 96-97 or 98 or 102 or 106 or 107 or 112 or 132-139 or 150 or 162 or or 186\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\nCode\nstructure.addRepresentation(\"contact\",{ \"sele\": \"47-55 or 91 or 93 or 96-97 or 98 or 102 or 106 or 107 or 112 or 132-139 or 150 or 162 or or 186 or ligand or water\", \"color\": \"element\"});\n\n\n\n\n\n\n\n\n\nCode\nstructure.autoView();\n\n\n\n\n\n\n\n\n\nThe binding site is composed of a section containing the adenin moety which is characterized by a beta sheet at the bottom of the site, and two helices lining the site. The sidechains exposed to the binding site lumen are globally hydrophobic, a part from the very important aspartate 93, which is interacting directly with the adenine moeity. The adenin moeity is sourrounded by water molecules and several of these watersare important hallmarks of several HSP90 binders. The ribose moeity is not forming any H-bonds with the protein itself but has hydroxyls oriented towards the solvent. The ether of the ribose is orented towards the valine 107, adjacent to a rather hydrophobic part of the pocket coated by Y139, F138 and W162. The triphospate is solvent exposed and interacting with a small helix-loop-helix motive which, as we will probably see a bit later part of the more mobile regions of the binding site."
  },
  {
    "objectID": "wip/2023-04-03-binding-site-comparison-benchmark-I/2023-04-03-binding-site-comparison-benchmark-i.html#establishing-a-reference-set",
    "href": "wip/2023-04-03-binding-site-comparison-benchmark-I/2023-04-03-binding-site-comparison-benchmark-i.html#establishing-a-reference-set",
    "title": "Binding Site Comparison Benchmarks - I",
    "section": "Establishing a reference set",
    "text": "Establishing a reference set\nNow we have defined a binding site of interest, let’s try to establish first a few obvious scenarios one might want to cover with a pocket comparison method. In my previous post I stated that the principle use case for binding site comparison methods that I’m focusing on is large scale comparison or screening. The underlying use cases that I’m mainly interested in are NOT protein function prediction, but rather the prediction of potential counter targets, or extracting bound ligands from related binding sites to inform structurally during my compound design cycle.\nLet’s consider that we are working on a drug design project on the HSP90 N-terminal ATP binding site and we have our favourite structure of HSP90 as starting point, i.e. 4cwr.\nIf I want to find similar binding sites to my query binding site vs all known/putative binding sites, what hits I’d expect to get first in the hitlist ?:\n\nthe ATP binding site of other HSP90 alpha human structures with the same overall conformation (more or less) - same sequence & conformation\nthe ATP binding site of other HSP90 human isoforms with a similar conformation - likely locally identical sequences & conformation\nthe ATP binding site of HSP90 sequences from other species with a similar conformation - locally very similar sequences\nall of the above but with a bit different conformations - conformations\nthe ATP binding site of close homologs (sequence - families etc) to the query structure - similar sequences\nthe ATP binding sites of proteins sharing the same fold as HSP90 - same fold\nnucleotide binding sites with similar interaction patterns but dissimar fold - same interactions\nall binding sites binding ATP must be similar (provocative on purpose …) - same ligand\nunexpected & unrelated / unknown similarities - nightmare\n\nThese first five give a graduation up to which level another ATP binding site could be potentially close to the HSP90 binding site. These are the obvious clusters of sequences, structures & conformations one would expect to find. As a result, one can use this type of graduation also for validating binding site comparison methods. One major difference with the setting I’m laying out here, is that the background data encompasses the full RCSB PDB structures containing all ligand binding sites + putative binding sites (empty clefts). This sets the approach I’m suggesting into stark contrast with previous benchmark sets. Such previous sets were classically composed of a list of expected matches of binding site pairs and decoys (expected mismatches). As Vincent Le Guilloux, if you can avoid a threshold effect, avoid it! This is exactly such a case where a discrete split between a match & a mismatch is introduced. As a result my background data (what one usually calls a decoy) is the full pocketome and I’ll try to use metrics of success that measure, how many of the potentially expected hits are found before a bulk of less expected hits & why.\nIn the subsequent sections I’ll go through all the painful steps to create the dataset corresponding to each of the sections 1 to 5. The situation 6 & 7 are a bit more tricky to set up. As for 8 - that’s the big issue with binding site comparison benchmarking - you don’t know until you know, but I’ll try to do a bit of my homework on that as well!\n\n1. Same Sequence & conformation\nAlright, here we go … the same sequence is the easiest case of all of them & several previous studies included a selection of structures, but as you’ll see even here to do things properly it gets quickly tricky. The following script will cover the required steps: - gather all structures (PDB codes) containing a resolved HSP90 alpha human N terminal domain - filter out structures with mutations on binding site residues compared to the wild type - get an all by all comparison of the binding sites (structurally speaking) which would allow for some rough clustering of conformations\n\n\nSCOP classification\nIf one considers that the SCOP family of this domain will likely contain other HSP90 Nter ATP binding sites then this is a useful resource to look for already assigned similarities by protein fold classification. This has been used already in several other papers in the litterature, but let’s exemplify here for the sake of completeness.\nThe N-ter ATP binding domain of HSP90 and the hierarchy of SCOP classifications can be found here.\n\n\n\nscop_hsp90.png"
  }
]
{
  
    
        "post0": {
            "title": "Grafting fragments onto molecules in rdkit - babysteps",
            "content": "Context . In this quick walkthrough I describe the first steps to attach fragments from a fragment library onto a molecule of interest. The main idea here is to prepare code snippets for the integration of all of this into the web-based 3d-editor project I started with Daniel Alvarez some time ago. As I&#39;m learning a lot of new things about rdkit I prefer to write it up here, as I found most of the relevant information in the mailing list &amp; the rdkit documentation. . The molecule to modify . I&#39;ll go for the same molecule as the one used for now in our BRD4 structure of the 3d editor project - that just comes from one of the official openforcefield examples here. . The fragment to add . I wanted to go for something easy for now ... so let&#39;s start with a methyl group ;) I made a quick shoutout on twitter on current available 3D fragments that could be helpful to write such a sketcher. Geoff Hutchison (Mr Avogadro) gave me a great hint to this library here. It contains way more fragments that I&#39;d initially consider for this project and the coordinates seem reasonable &amp; compatible with the systems we&#39;ll manage in the 3d-editor. . So I just took the methane from there (for now), ran it through Marvinsketch to replace one of the protons with an R group and then exported the whole thing as mol file (to the best of my knowledge rdkit doesn&#39;t support the chemistry markup language yet). . Preliminary steps . # https://sourceforge.net/p/rdkit/mailman/message/34922663/ procedure extracted from this support request import rdkit from rdkit import Chem from rdkit.Chem.Draw import IPythonConsole from rdkit.Chem import Draw IPythonConsole.ipython_useSVG=True import py3Dmol from rdkit.Chem import AllChem import copy from rdkit.Chem.rdMolAlign import AlignMol . . Below, the molecule we want to add the methyl group to. We&#39;ll attach it on the triazole ring. . suppl = Chem.SDMolSupplier(&#39;../data/ligand.sdf&#39;,removeHs=False) for mol in suppl: mblock = Chem.MolToMolBlock(mol) viewer = py3Dmol.view(width=300, height=300) viewer.addModel(mblock, &#39;mol&#39;) viewer.setStyle({&quot;stick&quot;:{}}) viewer.zoomTo() . You appear to be running in JupyterLab (or JavaScript failed to load for some other reason). You need to install the 3dmol extension: jupyter labextension install jupyterlab_3dmol . &lt;py3Dmol.view at 0x7f9a708b8e50&gt; . As the aim is to integrate that into the 3D-editor, the user ultimately will be able to click on the proton where he wants to place the fragment. Thus, we know which exact atom we want to attach it to. Below I&#39;m determining this showing plain atom indices in the rdkit molecule . for atom in mol.GetAtoms(): atom.SetAtomMapNum(atom.GetIdx()) mol2d=copy.deepcopy(mol) AllChem.Compute2DCoords(mol2d) #do this on a copy here Draw.MolToImage(mol2d, includeAtomNumbers=True) . Next I&#39;m loading the fragment and extract the position of the R-group and the connected atom as atom indices (I&#39;ll need that later). I know this is very limited and ugly for now, but it serves the purpose here &amp; now ;) . def getAttachmentVector(mol): &quot;&quot;&quot; for a fragment to add, search for the position of the attachment point and extract the atom id&#39;s of the attachment point and the connected atom (currently only single bond supported) mol: fragment passed as rdkit molecule return: tuple (atom indices) &quot;&quot;&quot; rindex=-1 rindexNeighbor=-1 for atom in mol.GetAtoms(): if(atom.GetAtomicNum()==0): rindex=atom.GetIdx() neighbours=atom.GetNeighbors() if(len(neighbours)==1): rindexNeighbor=neighbours[0].GetIdx() else: print(&quot;two attachment points not supported yet&quot;) return None return((rindex,rindexNeighbor)) fragment=Chem.MolFromMolFile(&#39;../data/methyl.mol&#39;,removeHs=False) ret=getAttachmentVector(fragment) for atom in mol.GetAtoms(): atom.SetAtomMapNum(atom.GetIdx()) if(ret): fragIndex1,fragIndex2=ret print(fragIndex1, fragIndex2) mblock = Chem.MolToMolBlock(fragment) viewer = py3Dmol.view(width=300, height=300) viewer.addModel(mblock, &#39;mol&#39;) viewer.setStyle({&quot;stick&quot;:{}}) viewer.zoomTo() . 4 1 . You appear to be running in JupyterLab (or JavaScript failed to load for some other reason). You need to install the 3dmol extension: jupyter labextension install jupyterlab_3dmol . &lt;py3Dmol.view at 0x7f9a40d3b310&gt; . Now let&#39;s extract also the atom index of the proton, and also the carbon the proton is attached to on the molecule. . queryAtomIndex=20 #defined by clicking on an atom in the sketcher -&gt; needs to be a proton right now for grafting atom=mol.GetAtomWithIdx(queryAtomIndex) neighbours=atom.GetNeighbors() if(len(neighbours)==1): rindexNeighbor=neighbours[0].GetIdx() else: print(&quot;two attachment points not supported yet&quot;) molIndex1=queryAtomIndex molIndex2=rindexNeighbor print(molIndex1,molIndex2) . 20 9 . Aligning the fragment onto the molecule . Now I have basically have the bond of the carbon to proton selected in the molecule and the carbon to R-group in my fragment. These bonds can be aligned onto each other to position the 3D-fragment correctly versus the molecule. This can be conveniently done using the AlignMol function available in rdkit. . AlignMol(fragment,mol,atomMap=((fragIndex2,molIndex1),(fragIndex1,molIndex2))) #important to specify the atomMap here, this aligns only the bonds . 0.027497679760887607 . #the rest is just to display things here mblock = Chem.MolToMolBlock(mol) fragblock = Chem.MolToMolBlock(fragment) viewer = py3Dmol.view(width=500, height=500) viewer.addModel(mblock, &#39;mol&#39;) viewer.addModel(fragblock, &#39;mol&#39;) viewer.setStyle({&quot;stick&quot;:{}}) viewer.zoomTo() . . You appear to be running in JupyterLab (or JavaScript failed to load for some other reason). You need to install the 3dmol extension: jupyter labextension install jupyterlab_3dmol . &lt;py3Dmol.view at 0x7f9a80a95e10&gt; . As you can see, the fragment gets placed correctly on top of the proton. Now we have however a few overlapping atoms in place. We can use the rdkit edition functions to address this and combine both overlapping molecules now into a final single molecule. . def connectMols(mol1, mol2, atom1, atom2): &quot;&quot;&quot;function copied from here https://github.com/molecularsets/moses/blob/master/moses/baselines/combinatorial.py&quot;&quot;&quot; combined = Chem.CombineMols(mol1, mol2) emol = Chem.EditableMol(combined) neighbor1_idx = atom1.GetNeighbors()[0].GetIdx() neighbor2_idx = atom2.GetNeighbors()[0].GetIdx() atom1_idx = atom1.GetIdx() atom2_idx = atom2.GetIdx() bond_order = atom2.GetBonds()[0].GetBondType() emol.AddBond(neighbor1_idx, neighbor2_idx + mol1.GetNumAtoms(), order=bond_order) emol.RemoveAtom(atom2_idx + mol1.GetNumAtoms()) emol.RemoveAtom(atom1_idx) mol = emol.GetMol() return mol finalMol=connectMols(mol,fragment,mol.GetAtomWithIdx(molIndex1),fragment.GetAtomWithIdx(fragIndex1)) Chem.SanitizeMol(finalMol) finalMolBlock = Chem.MolToMolBlock(finalMol) viewer = py3Dmol.view(width=500, height=500) viewer.addModel(finalMolBlock, &#39;mol&#39;) viewer.setStyle({&quot;stick&quot;:{}}) viewer.zoomTo() . You appear to be running in JupyterLab (or JavaScript failed to load for some other reason). You need to install the 3dmol extension: jupyter labextension install jupyterlab_3dmol . &lt;py3Dmol.view at 0x7f9a80a8b790&gt; . And voilà. Our methyl is nicely placed and oriented. That&#39;s one of the easiest cases and we&#39;ll have to consider torsion angles &amp; protein environment at a later stage as well, but this should provide first basics steps for simple additions like the one done here. .",
            "url": "https://pschmidtke.github.io/blog/rdkit/3d-editor/2021/01/23/grafting-fragments.html",
            "relUrl": "/rdkit/3d-editor/2021/01/23/grafting-fragments.html",
            "date": " • Jan 23, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "An Example Markdown Post",
            "content": "Example Markdown Post . Basic setup . Jekyll requires blog post files to be named according to the following format: . YEAR-MONTH-DAY-filename.md . Where YEAR is a four-digit number, MONTH and DAY are both two-digit numbers, and filename is whatever file name you choose, to remind yourself what this post is about. .md is the file extension for markdown files. . The first line of the file should start with a single hash character, then a space, then your title. This is how you create a “level 1 heading” in markdown. Then you can create level 2, 3, etc headings as you wish but repeating the hash character, such as you see in the line ## File names above. . Basic formatting . You can use italics, bold, code font text, and create links. Here’s a footnote 1. Here’s a horizontal rule: . . Lists . Here’s a list: . item 1 | item 2 | . And a numbered list: . item 1 | item 2 | Boxes and stuff . This is a quotation . . You can include alert boxes …and… . . You can include info boxes Images . . Code . You can format text and code per usual . General preformatted text: . # Do a thing do_thing() . Python code and output: . # Prints &#39;2&#39; print(1+1) . 2 . Formatting text as shell commands: . echo &quot;hello world&quot; ./some_script.sh --option &quot;value&quot; wget https://example.com/cat_photo1.png . Formatting text as YAML: . key: value - another_key: &quot;another value&quot; . Tables . Column 1 Column 2 . A thing | Another thing | . Tweetcards . Altair 4.0 is released! https://t.co/PCyrIOTcvvTry it with: pip install -U altairThe full list of changes is at https://t.co/roXmzcsT58 ...read on for some highlights. pic.twitter.com/vWJ0ZveKbZ . &mdash; Jake VanderPlas (@jakevdp) December 11, 2019 Footnotes . This is the footnote. &#8617; . |",
            "url": "https://pschmidtke.github.io/blog/markdown/2020/01/14/test-markdown-post.html",
            "relUrl": "/markdown/2020/01/14/test-markdown-post.html",
            "date": " • Jan 14, 2020"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://pschmidtke.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  
      ,"page2": {
          "title": "",
          "content": "Posts .",
          "url": "https://pschmidtke.github.io/blog/",
          "relUrl": "/",
          "date": ""
      }
      
  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://pschmidtke.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}
{
  
    
        "post0": {
            "title": "Conclusion",
            "content": "&gt; &quot;First steps to check how easy / feasible it is to extract torsion angle statistics from the COD&quot; - toc: true - branch: master - badges: true - comments: true - author: Peter Schmidtke - categories: [rdkit, crystallography, small molecule xray, xray, database] - image: images/toc-cod.png . Context . When designing compounds in 3D, especially within the binding site, it is often very complicated to assess if what you&#39;ve just designed actually makes sense. Is the molecule strained? Does it make ok or favourable interactions? Does it bump into the binding site somewhere? Especially when talking to medicinal chemists, they usually want to know whether their design passes all potential physical hurdles ... and while we&#39;re at it a prediction of the binding affinity would be nice and this in 1 second. . Among all of these things to evaluate on a compound in 3D, the strain is something that can be either calculated (quantum mecanics, or force-field if you trust that) or compared to a set of reference compounds we know the structures of. . A very popular reference database for small molecule conformations is the CCDC CSD. It contains more than a million small molecule crystal structures. It is widely used in pharma industry to assess various things ... among them: ligand strain. I won&#39;t enter the debate here whether the conformations observed in small molecule crystal structures are relevant and all the other debates on the use of such a database. . The thing is, the CSD is not freely available. However, there&#39;s a free alternative available ... I guess the poor man&#39;s CSD and it&#39;s called COD for Crystallography Open Database. It contains less structures than the CSD (466 000 by the time I&#39;m writing this), that&#39;s for sure, but it&#39;s still maintained and people are depositing structures in there. The quality appears to be OK as well according to what I read so far, no tests done yet. . Here I&#39;ll outline a few steps on how to get the COD and use rdkit to extract all torsion angles of all molecules - a long and bumpy ride. Here we go. . Get the COD . That&#39;s rather easy. You can simply retrieve cif or hkl files from their server using this here: . mkdir -p cif; rsync -av --delete rsync://www.crystallography.net/cif/ cif/ . This should run for a bit. . Parsing CIF in rdkit . The first hurdle is as usual linked to molecular formats. To the best of my knowledge no cif parser was ported yet to rdkit. I tried a few parsers (gemmi - no mol or other useable output yet, pdbccdutils -&gt; only macromolecular cif files, I think) before ending up again with openbabel in the end. Let&#39;s stick with that for now. . Let&#39;s try to see what this looks like for a single cif file from the COD: . from rdkit import Chem from openbabel import pybel import py3Dmol import dask mol = next(pybel.readfile(&quot;cif&quot;, &quot;../../cod/cif/1/00/00/1000007.cif&quot;)) molblock=mol.write(&quot;mol&quot;) #write out as a molfile string and ship that now into rdkit m = Chem.MolFromMolBlock(molblock,removeHs=False) m . Well, that looks rather nasty. Let&#39;s check in 3D: . viewer = py3Dmol.view(width=300, height=300) viewer.addModel(molblock, &#39;mol&#39;) viewer.setStyle({&quot;stick&quot;:{}}) viewer.zoomTo() . . You appear to be running in JupyterLab (or JavaScript failed to load for some other reason). You need to install the 3dmol extension: jupyter labextension install jupyterlab_3dmol . &lt;py3Dmol.view at 0x7fc9906c7400&gt; . So good news, cif parsing seems to work (at least on this particular example). The bad news, how can I get to relevant molecules in the COD? . Extracting relevant molecules from the COD . Thanks to researchgate I came across this page where they provide a datawarrior file of the content of the cod (at least a curated subpart of that). You can see that the COD contains organic, inorganic and metalorganic structures. . . As you might already observe on the screenshot above, there&#39;s a lot of noise (for drug discovery) in there. . So how can we filter out only the organic ones? I checked the individual cif files, and no easy way to get to this classification ... would have been too easy. So two solutions - either take the prepared datawarrior file (which I would not prefer, because I&#39;m dependent on somebody else doing this nice work during his free-time, Thomas Sander), or trial and error and identify organic compounds with a set of rules. Good thing is, I can use Thomas Sanders work (the datawarrior file) to check if the filter works or not (+ visual inspection). . The COD dump you can download via rsync is structured a bit like the PDB: with two levels of subfolders, numbered and 100 files max per subfolder. Basically I&#39;ll have to loop over all of this -&gt; let&#39;s blow up the notebook ;) I&#39;ll loop over all molecules and try to run through sanitize. All failing molecules should not be added. Next I&#39;m checking as well if there&#39;s at least a carbon atom in the structure (for a lot of them there isn&#39;t). I filter out metalorganics as well. Last I keep only molecules with more than 6 atoms. . As this is a bit slow and can be easily put on several cpu&#39;s I&#39;m doing that right here as well. I wanted to test how dask behaves on such a task. It&#39;s total overkill for what I&#39;m doing here, but I want to see how the scheduling behaves on short living and often failing jobs (difficult to orchestrate, unless you handle it yourself in the code). . Below you have a standalone python script (was not optimal in the notebook) to run all of this quick and dirty preparation. There are tons of rdkit &amp; openbabel warnings popping out of that, as expected: . from rdkit import Chem from openbabel import pybel import glob import pandas as pd import os import multiprocessing as mp from wrapt_timeout_decorator import * from rdkit import rdBase rdBase.DisableLog(&#39;rdApp.error&#39;) rdBase.DisableLog(&#39;rdApp.warning&#39;) ob_log_handler = pybel.ob.OBMessageHandler() ob_log_handler.SetOutputLevel(0) carbon = Chem.MolFromSmarts(&quot;[#6]&quot;) def is_transition_metal(at): n = at.GetAtomicNum() return (n&gt;=22 and n&lt;=29) or (n&gt;=40 and n&lt;=47) or (n&gt;=72 and n&lt;=79) def write_output(filenames,outputname=&quot;out.sdf&quot;): w = Chem.SDWriter(outputname) for filename in filenames: try: if os.stat(filename).st_size / (1024 * 1024)&lt;2.0: mol = next(pybel.readfile(&quot;cif&quot;,str(filename))) molblock=mol.write(&quot;mol&quot;) #write out as a molfile string and ship that now into rdkit m = Chem.MolFromMolBlock(molblock,removeHs=False,sanitize=True) m.SetProp(&#39;COD&#39;,os.path.basename(filename).split(&quot;.&quot;)[0]) w.write(m) except Exception: pass w.close() def select_molecule(filename): blacklist=[&quot;../../cod/cif/2/31/17/2311717.cif&quot;,&quot;../../cod/cif/2/10/46/2104629.cif&quot;,&quot;../../cod/cif/2/10/59/2105953.cif&quot;] if(filename not in blacklist): try: mol = next(pybel.readfile(&quot;cif&quot;,str(filename))) molblock=mol.write(&quot;mol&quot;) #write out as a molfile string and ship that now into rdkit m = Chem.MolFromMolBlock(molblock,removeHs=False,sanitize=True) if m is not None and len(m.GetSubstructMatches(carbon))&gt;0 and m.GetNumAtoms()&gt; 6 : if(True not in [is_transition_metal(atom) for atom in m.GetAtoms()]): return filename except Exception: return None return None return None if __name__ == &#39;__main__&#39;: files=glob.glob(&#39;../../cod/cif/**/*.cif&#39;, recursive=True) n=0 pool = mp.Pool(mp.cpu_count()) results = pool.map(select_molecule, files) validresults=[el for el in results if el is not None] codids=[int(os.path.basename(filename).split(&quot;.&quot;)[0]) for filename in validresults] df = pd.read_table(&#39;/Users/peter/Downloads/COD_2020jun13.txt&#39;, header=0) dwr=df[&quot;COD Number&quot;] common=list(set(dwr) &amp; set(codids)) write_output(validresults) print(&quot;common molecules&quot;) print(len(common)) import numpy as np print(&quot;in mine, not in datawarrior&quot;) intersect1=np.setdiff1d(codids,dwr) np.savetxt(&quot;out_intersect1.csv&quot;,intersect1.astype(int),delimiter=&quot;,&quot;,fmt=&#39;%i&#39;) print(len(intersect1)) print(&quot;in datawarrior, not in mine&quot;) intersect2=np.setdiff1d(dwr,codids) np.savetxt(&quot;out_intersect2.csv&quot;,intersect2.astype(int),delimiter=&quot;,&quot;,fmt=&#39;%i&#39;) print(len(intersect2)) . I finally decided to strip out the dask code and run it through multiprocessing. Anyhow, easy to set up and a quick discussion on that below as well! . Dask &amp; multiprocessing interlude . Before analyzing the results, let&#39;s briefly assess how dask performs here. Dask enables us to run the code in a classical threaded, but also distributed mode, even on a local machine. As I have 12 cores&#39;s hanging in my MacPro I tested a distributed calculation. That is rather easy to set up. A bit like a multiprocessing Pool, but with the advantage that the functions are not 100% isolated (advantage or disadvantage, I let you decide ;)). The other nice thing (I didn&#39;t know about) is that dask (if installed through conda at least) comes with bokeh, a tool allowing you to do some monitoring of your jobs. It&#39;s not super advanced, but gives you an overview of the worker loads, the job queue and the overall advancement. So that&#39;s quite cool compared to being completely blind on what&#39;s happening in your queue. . . I tested quite a range of combinations and ways to run this in dask (bag, compute, map .... ) and combinations of number of worker nodes vs threads. In the end, parallelization still isn&#39;t optimally spread over all cpu&#39;s, but I guess that&#39;s likely due to the fact that every calculation can range from immediate failure to runnning for a very long time. I guess, that on longer living and more stable jobs this is far more efficient. . The most frustrating thing was that the script completely froze on a single job during the last 10% of the molecules. I narrowed down the issue to 3 molecules that openbabel naturally had issues with. When I say naturally, have a look at these: . . The nasty thing here is that I even tried to kill these freezing jobs with timeout decorators and such. Without success. Even a ctrl+c in a shell didn&#39;t kill the job ... only a kill -9 did. So in the end I kept the multiprocessing version here in the code and filtered out the three incriminating molecules ( by hand, but would be really interested to know how this can be handled in a more geeky way). . Final filtered COD . Let&#39;s come back to the actual aim of this post. Extract torsion angle statistics from small molecule crystal structures. First let&#39;s have a look what molecules I have in common now with Datawarrior and which ones are different and whether the filter should / could be refined a bit. . obabel &amp; rdkit Datawarrior . obabel &amp; rdkit | 78643 | 117674 | . Datawarrior | 117674 | 18344 | . The majority of retained molecules are in common with datawarrior, but I am, I guess still a bit permissive for now. I don&#39;t want to go too much into the analysis of differences here and now. Quickly checking the sd file (above 1Gb) with datawarrior gives a few ideas on what to filter out. I guess I can also use some of the published usual filters on top of that. . . Towards torsion angles . Now the next step is to identify whether there&#39;s enough data to gather some statistics on some typical torsion angles that you can encounter in druglike molecules. Fortunately Sereina Riniker &amp; Greg Landrum already did something a bit similar in the past with data from the CSD and the PDB to write the ETKDG (I hope I got that right) conformer generator for rdkit. . The SI of that paper lists a bunch of smarts patterns describing such torsion angles. I&#39;ll blindly use these here to sieve through all molecules from the COD to see what I can get out of that. The smarts patterns are available here - freely available ... unlike the paper behind it :( . import pandas as pd from rdkit.Chem import rdMolTransforms import matplotlib.pyplot as plt import matplotlib.image as mpimg import numpy as np import urllib.parse torsions=pd.read_table(&quot;../data/list_torsion_patterns.txt&quot;,header=None,usecols=[1]) suppl = Chem.SDMolSupplier(&#39;out.sdf&#39;,removeHs=False) patterns=torsions[1][:3] for torsionSmarts in patterns: print(torsionSmarts) angles=[] torsionQuery = Chem.MolFromSmarts(torsionSmarts) i=0 #suppl.reset() for mol in suppl: i+=1 if mol is None: continue conf=mol.GetConformer(0) matches = mol.GetSubstructMatches(torsionQuery) if(len(matches)&gt;0): for match in matches: angle=rdMolTransforms.GetDihedralDeg(conf, match[0],match[1],match[2],match[3]) angles.append(angle) if(len(angles)): smarts=urllib.parse.quote(torsionSmarts) img = mpimg.imread(&quot;https://smarts.plus/smartsview/download_rest?smarts=&quot;+smarts,format=&quot;png&quot;) fig = plt.figure(figsize=(30, 15)) fig.add_subplot(121) plt.title(&#39;smarts pattern&#39;) plt.axis(&#39;off&#39;) plt.imshow(img) fig.add_subplot(122) plt.title(&#39;torsion angle histogram&#39;) #df = pd.DataFrame(angles,columns = [torsionSmarts]) plt.hist(np.array(angles),bins=36,range=[-180, 180]) . flicting single bond directions around double bond at index 186. RDKit WARNING: [01:11:22] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:11:22] Conflicting single bond directions around double bond at index 275. RDKit WARNING: [01:11:22] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:11:22] Conflicting single bond directions around double bond at index 311. RDKit WARNING: [01:11:22] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:11:22] Conflicting single bond directions around double bond at index 374. RDKit WARNING: [01:11:22] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:11:22] Conflicting single bond directions around double bond at index 416. RDKit WARNING: [01:11:22] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:11:25] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:11:32] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:11:32] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:11:32] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:11:44] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:11:44] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:11:44] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:11:44] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:11:45] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:11:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:11:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:11:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:11:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:11:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:11:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:11:55] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:11:55] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:11:59] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:12:04] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:12:04] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:12:04] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:12:05] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:12:05] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:12:05] Warning: molecule is tagged as 3D, but all Z coords are zero RDKit WARNING: [01:12:13] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:12:19] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:12:19] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:12:26] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:12:39] Warning: molecule is tagged as 3D, but all Z coords are zero RDKit WARNING: [01:12:40] Warning: molecule is tagged as 3D, but all Z coords are zero RDKit ERROR: [00:42:17] ERROR: moving to the beginning of the next molecule RDKit ERROR: [01:12:44] RDKit ERROR: RDKit ERROR: **** RDKit ERROR: Post-condition Violation RDKit ERROR: Element &#39;0 H&#39; not found RDKit ERROR: Violation occurred on line 91 in file /Users/runner/miniforge3/conda-bld/rdkit_1611244985915/work/Code/GraphMol/PeriodicTable.h RDKit ERROR: Failed Expression: anum &gt; -1 RDKit ERROR: **** RDKit ERROR: RDKit ERROR: [01:12:44] ERROR: Element &#39;0 H&#39; not found RDKit WARNING: [01:12:45] Warning: molecule is tagged as 3D, but all Z coords are zero RDKit WARNING: [01:12:45] Warning: molecule is tagged as 3D, but all Z coords are zero RDKit WARNING: [01:12:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. [O:1]=[C:2]([N])!@;-[O:3]~[C:4] RDKit WARNING: [01:13:20] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:13:22] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:13:22] Conflicting single bond directions around double bond at index 65. RDKit WARNING: [01:13:22] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:13:22] Conflicting single bond directions around double bond at index 89. RDKit WARNING: [01:13:22] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:13:22] Conflicting single bond directions around double bond at index 183. RDKit WARNING: [01:13:22] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:13:44] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:13:47] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:14:15] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:14:15] Warning: molecule is tagged as 3D, but all Z coords are zero RDKit WARNING: [01:14:17] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:14:17] Conflicting single bond directions around double bond at index 97. RDKit WARNING: [01:14:17] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:14:17] Conflicting single bond directions around double bond at index 110. RDKit WARNING: [01:14:17] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:14:17] Conflicting single bond directions around double bond at index 186. RDKit WARNING: [01:14:17] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:14:17] Conflicting single bond directions around double bond at index 275. RDKit WARNING: [01:14:17] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:14:17] Conflicting single bond directions around double bond at index 311. RDKit WARNING: [01:14:17] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:14:17] Conflicting single bond directions around double bond at index 374. RDKit WARNING: [01:14:17] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:14:17] Conflicting single bond directions around double bond at index 416. RDKit WARNING: [01:14:17] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:14:20] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:14:27] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:14:27] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:14:28] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:14:39] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:14:40] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:14:40] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:14:40] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:14:41] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:14:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:14:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:14:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:14:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:14:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:14:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:14:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:14:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:14:54] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:15:00] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:15:00] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:15:00] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:15:00] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:15:00] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:15:00] Warning: molecule is tagged as 3D, but all Z coords are zero RDKit WARNING: [01:15:09] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:15:14] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:15:14] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:15:22] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:15:34] Warning: molecule is tagged as 3D, but all Z coords are zero RDKit WARNING: [01:15:36] Warning: molecule is tagged as 3D, but all Z coords are zero RDKit ERROR: [01:12:44] ERROR: moving to the beginning of the next molecule RDKit ERROR: [01:15:39] RDKit ERROR: RDKit ERROR: **** RDKit ERROR: Post-condition Violation RDKit ERROR: Element &#39;0 H&#39; not found RDKit ERROR: Violation occurred on line 91 in file /Users/runner/miniforge3/conda-bld/rdkit_1611244985915/work/Code/GraphMol/PeriodicTable.h RDKit ERROR: Failed Expression: anum &gt; -1 RDKit ERROR: **** RDKit ERROR: RDKit ERROR: [01:15:39] ERROR: Element &#39;0 H&#39; not found RDKit WARNING: [01:15:40] Warning: molecule is tagged as 3D, but all Z coords are zero RDKit WARNING: [01:15:41] Warning: molecule is tagged as 3D, but all Z coords are zero RDKit WARNING: [01:15:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. [O:1]=[C:2]!@;-[O:3]~[C:4] RDKit WARNING: [01:16:15] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:16:18] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:16:18] Conflicting single bond directions around double bond at index 65. RDKit WARNING: [01:16:18] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:16:18] Conflicting single bond directions around double bond at index 89. RDKit WARNING: [01:16:18] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:16:18] Conflicting single bond directions around double bond at index 183. RDKit WARNING: [01:16:18] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:16:39] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:16:43] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:10] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:10] Warning: molecule is tagged as 3D, but all Z coords are zero RDKit WARNING: [01:17:13] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:13] Conflicting single bond directions around double bond at index 97. RDKit WARNING: [01:17:13] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:17:13] Conflicting single bond directions around double bond at index 110. RDKit WARNING: [01:17:13] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:17:13] Conflicting single bond directions around double bond at index 186. RDKit WARNING: [01:17:13] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:17:13] Conflicting single bond directions around double bond at index 275. RDKit WARNING: [01:17:13] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:17:13] Conflicting single bond directions around double bond at index 311. RDKit WARNING: [01:17:13] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:17:13] Conflicting single bond directions around double bond at index 374. RDKit WARNING: [01:17:13] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:17:13] Conflicting single bond directions around double bond at index 416. RDKit WARNING: [01:17:13] BondStereo set to STEREONONE and single bond directions set to NONE. RDKit WARNING: [01:17:16] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:22] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:22] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:23] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:35] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:35] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:35] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:35] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:36] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:45] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:45] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:45] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:45] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:45] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:45] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:45] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:45] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:50] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:55] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:55] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:55] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:56] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:56] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:17:56] Warning: molecule is tagged as 3D, but all Z coords are zero RDKit WARNING: [01:18:04] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:18:10] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:18:10] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:18:17] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. RDKit WARNING: [01:18:30] Warning: molecule is tagged as 3D, but all Z coords are zero RDKit WARNING: [01:18:31] Warning: molecule is tagged as 3D, but all Z coords are zero RDKit ERROR: [01:15:39] ERROR: moving to the beginning of the next molecule RDKit ERROR: [01:18:35] RDKit ERROR: RDKit ERROR: **** RDKit ERROR: Post-condition Violation RDKit ERROR: Element &#39;0 H&#39; not found RDKit ERROR: Violation occurred on line 91 in file /Users/runner/miniforge3/conda-bld/rdkit_1611244985915/work/Code/GraphMol/PeriodicTable.h RDKit ERROR: Failed Expression: anum &gt; -1 RDKit ERROR: **** RDKit ERROR: RDKit ERROR: [01:18:35] ERROR: Element &#39;0 H&#39; not found RDKit WARNING: [01:18:36] Warning: molecule is tagged as 3D, but all Z coords are zero RDKit WARNING: [01:18:36] Warning: molecule is tagged as 3D, but all Z coords are zero RDKit WARNING: [01:18:45] WARNING: could not find number of expected rings. Switching to an approximate ring finding algorithm. . &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2021-01-28T01:18:53.696548 image/svg+xml Matplotlib v3.3.2, https://matplotlib.org/ &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2021-01-28T01:18:55.650124 image/svg+xml Matplotlib v3.3.2, https://matplotlib.org/ &lt;!DOCTYPE svg PUBLIC &quot;-//W3C//DTD SVG 1.1//EN&quot; &quot;http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd&quot;&gt; 2021-01-28T01:18:57.570115 image/svg+xml Matplotlib v3.3.2, https://matplotlib.org/ I&#39;m only showing 3 smarts patterns here, but the code is written to run on all of the smarts patterns from the Riniker &amp; Landrum paper. So feel free to adjust it to get the full results on your machine (to big for the notebook here ;). . As you can see, there is still a lot of errors when re-reading the molecules from the SD file ... so still a lot of curation to be done. Also, on fullerenes or graphene or other larger structures (that are still in there), we&#39;ll likely get a repeated overrepresentation of several torsion angles. So something to think about when normalizing all of this data in the end. . In theory, the order of the smarts patterns in the file I used here should be comparable to torsion angles provided in the S1.zip by both authors (fingers crossed). These histograms were generated on a filtered / curated CCDC CSD dataset (unlike my hairy monster dataset here). . . The first thing to notice is that they calculated a dihedral between 0 and 360, I just took the angles popping out of rdkit (between -180 and 180). So a bit of a mindgame to compare both. On smarts patterns 1 and 3 we have peaks around 0, which coincides with the CSD results. It is interesting to see that there&#39;s a bit of data for smarts pattern 1 suggesting angles around 180° might be possible, though not favourable (again, more filtering and quality checks needed to confirm/discard that). . Smarts pattern 2 doesn&#39;t coincide at all with results from the CSD however, which makes me worried ... a bit ;) . Debugging smarts pattern 2 . pattern=&quot;[O:1]=[C:2]([N])!@;-[O:3]~[C:4]&quot; i=0 torsionQuery = Chem.MolFromSmarts(pattern) for mol in suppl: i+=1 if mol is None: continue conf=mol.GetConformer(0) matches = mol.GetSubstructMatches(torsionQuery) if(len(matches)): for match in matches: angle=rdMolTransforms.GetDihedralDeg(conf, match[0],match[1],match[2],match[3]) #break print(angle) print(mol.GetProp(&quot;COD&quot;)) if(i&gt;5000): break . 178.94640626006364 7031170 -177.12326809469428 7039689 -179.7556421050122 7039689 -179.06730293018322 7039689 . Here are 4 compounds where we calculate in theory wrong angles. Let&#39;s visualize the last one and check what dihedral angle we are actually calculating here . for mol in suppl: if str(mol.GetProp(&quot;COD&quot;))==str(7039689): mol.GetSubstructMatches(torsionQuery) break matches=mol.GetSubstructMatches(torsionQuery) print(matches) flat_list = [item for sublist in matches for item in sublist] molblock=Chem.MolToMolBlock(mol) viewer = py3Dmol.view(width=300, height=300) viewer.addModel(molblock, &#39;mol&#39;) viewer.setStyle({&quot;stick&quot;:{}}) #viewer.setStyle({&#39;serial&#39;:flat_list},{&#39;stick&#39;:{&#39;color&#39;: &#39;pink&#39;}}) viewer.setStyle({&#39;serial&#39;:flat_list},{&#39;stick&#39;:{&#39;color&#39;: &#39;pink&#39;}}) viewer.zoomTo() . ((1, 18, 4, 0, 19), (53, 70, 56, 52, 71), (105, 122, 108, 104, 123)) . You appear to be running in JupyterLab (or JavaScript failed to load for some other reason). You need to install the 3dmol extension: jupyter labextension install jupyterlab_3dmol . &lt;py3Dmol.view at 0x7fc980882130&gt; . The matching atoms are coloured in pink here. . From the substructure matches above, we can see that the smarts pattern matches 5 atoms, instead of 4. Including the nitrogen (the third atom matching here). In the end, this doesn&#39;t describe the bond or the torsion angle we want at all, thus the discrepancies in the results. .",
            "url": "https://pschmidtke.github.io/blog/2021/01/25/cod-and-torsion-angles.html",
            "relUrl": "/2021/01/25/cod-and-torsion-angles.html",
            "date": " • Jan 25, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "Grafting fragments onto molecules in rdkit - babysteps",
            "content": "Context . In this quick walkthrough I describe the first steps to attach fragments from a fragment library onto a molecule of interest. The main idea here is to prepare code snippets for the integration of all of this into the web-based 3d-editor project I started with Daniel Alvarez some time ago. As I&#39;m learning a lot of new things about rdkit I prefer to write it up here, as I found most of the relevant information in the mailing list &amp; the rdkit documentation. . The molecule to modify . I&#39;ll go for the same molecule as the one used for now in our BRD4 structure of the 3d editor project - that just comes from one of the official openforcefield examples here. . The fragment to add . I wanted to go for something easy for now ... so let&#39;s start with a methyl group ;) I made a quick shoutout on twitter on current available 3D fragments that could be helpful to write such a sketcher. Geoff Hutchison (Mr Avogadro) gave me a great hint to this library here. It contains way more fragments than I&#39;d initially considered for this project and the coordinates seem reasonable &amp; compatible with the systems we&#39;ll manage in the 3d-editor. . So I just took the methane from there (for now), ran it through Marvinsketch to replace one of the protons with an R group and then exported the whole thing as mol file (to the best of my knowledge rdkit doesn&#39;t support the chemistry markup language yet). . Preliminary steps . # https://sourceforge.net/p/rdkit/mailman/message/34922663/ procedure extracted from this support request import rdkit from rdkit import Chem from rdkit.Chem.Draw import IPythonConsole from rdkit.Chem import Draw IPythonConsole.ipython_useSVG=True import py3Dmol from rdkit.Chem import AllChem import copy from rdkit.Chem.rdMolAlign import AlignMol . . Below, the molecule we want to add the methyl group to. We&#39;ll attach it on the triazole ring. . suppl = Chem.SDMolSupplier(&#39;../data/ligand.sdf&#39;,removeHs=False) for mol in suppl: mblock = Chem.MolToMolBlock(mol) viewer = py3Dmol.view(width=300, height=300) viewer.addModel(mblock, &#39;mol&#39;) viewer.setStyle({&quot;stick&quot;:{}}) viewer.zoomTo() . You appear to be running in JupyterLab (or JavaScript failed to load for some other reason). You need to install the 3dmol extension: jupyter labextension install jupyterlab_3dmol . &lt;py3Dmol.view at 0x7f9a708b8e50&gt; . As the aim is to integrate that into the 3D-editor, the user ultimately will be able to click on the proton where he wants to place the fragment. Thus, we know which exact atom we want to attach it to. Below I&#39;m determining this showing plain atom indices in the rdkit molecule . for atom in mol.GetAtoms(): atom.SetAtomMapNum(atom.GetIdx()) mol2d=copy.deepcopy(mol) AllChem.Compute2DCoords(mol2d) #do this on a copy here Draw.MolToImage(mol2d, includeAtomNumbers=True) . Next I&#39;m loading the fragment and extract the position of the R-group and the connected atom as atom indices (I&#39;ll need that later). I know this is very limited and ugly for now, but it serves the purpose here &amp; now ;) . def getAttachmentVector(mol): &quot;&quot;&quot; for a fragment to add, search for the position of the attachment point and extract the atom id&#39;s of the attachment point and the connected atom (currently only single bond supported) mol: fragment passed as rdkit molecule return: tuple (atom indices) &quot;&quot;&quot; rindex=-1 rindexNeighbor=-1 for atom in mol.GetAtoms(): if(atom.GetAtomicNum()==0): rindex=atom.GetIdx() neighbours=atom.GetNeighbors() if(len(neighbours)==1): rindexNeighbor=neighbours[0].GetIdx() else: print(&quot;two attachment points not supported yet&quot;) return None return((rindex,rindexNeighbor)) fragment=Chem.MolFromMolFile(&#39;../data/methyl.mol&#39;,removeHs=False) ret=getAttachmentVector(fragment) for atom in mol.GetAtoms(): atom.SetAtomMapNum(atom.GetIdx()) if(ret): fragIndex1,fragIndex2=ret print(fragIndex1, fragIndex2) mblock = Chem.MolToMolBlock(fragment) viewer = py3Dmol.view(width=300, height=300) viewer.addModel(mblock, &#39;mol&#39;) viewer.setStyle({&quot;stick&quot;:{}}) viewer.zoomTo() . 4 1 . You appear to be running in JupyterLab (or JavaScript failed to load for some other reason). You need to install the 3dmol extension: jupyter labextension install jupyterlab_3dmol . &lt;py3Dmol.view at 0x7f9a40d3b310&gt; . Now let&#39;s extract also the atom index of the proton, and also the carbon the proton is attached to on the molecule. . queryAtomIndex=20 #defined by clicking on an atom in the sketcher -&gt; needs to be a proton right now for grafting atom=mol.GetAtomWithIdx(queryAtomIndex) neighbours=atom.GetNeighbors() if(len(neighbours)==1): rindexNeighbor=neighbours[0].GetIdx() else: print(&quot;two attachment points not supported yet&quot;) molIndex1=queryAtomIndex molIndex2=rindexNeighbor print(molIndex1,molIndex2) . 20 9 . Aligning the fragment onto the molecule . Now I have the bond of the carbon to proton selected in the molecule and the carbon to R-group in my fragment. These bonds can be aligned onto each other to position the 3D-fragment correctly versus the molecule. This can be conveniently done using the AlignMol function available in rdkit. . AlignMol(fragment,mol,atomMap=((fragIndex2,molIndex1),(fragIndex1,molIndex2))) #important to specify the atomMap here, this aligns only the bonds . 0.027497679760887607 . #the rest is just to display things here mblock = Chem.MolToMolBlock(mol) fragblock = Chem.MolToMolBlock(fragment) viewer = py3Dmol.view(width=500, height=500) viewer.addModel(mblock, &#39;mol&#39;) viewer.addModel(fragblock, &#39;mol&#39;) viewer.setStyle({&quot;stick&quot;:{}}) viewer.zoomTo() . . You appear to be running in JupyterLab (or JavaScript failed to load for some other reason). You need to install the 3dmol extension: jupyter labextension install jupyterlab_3dmol . &lt;py3Dmol.view at 0x7f9a80a95e10&gt; . As you can see, the fragment gets placed correctly on top of the proton. Now we have however a few overlapping atoms in place. We can use the rdkit edition functions to address this and combine both overlapping molecules now into a final single molecule. . def connectMols(mol1, mol2, atom1, atom2): &quot;&quot;&quot;function copied from here https://github.com/molecularsets/moses/blob/master/moses/baselines/combinatorial.py&quot;&quot;&quot; combined = Chem.CombineMols(mol1, mol2) emol = Chem.EditableMol(combined) neighbor1_idx = atom1.GetNeighbors()[0].GetIdx() neighbor2_idx = atom2.GetNeighbors()[0].GetIdx() atom1_idx = atom1.GetIdx() atom2_idx = atom2.GetIdx() bond_order = atom2.GetBonds()[0].GetBondType() emol.AddBond(neighbor1_idx, neighbor2_idx + mol1.GetNumAtoms(), order=bond_order) emol.RemoveAtom(atom2_idx + mol1.GetNumAtoms()) emol.RemoveAtom(atom1_idx) mol = emol.GetMol() return mol finalMol=connectMols(mol,fragment,mol.GetAtomWithIdx(molIndex1),fragment.GetAtomWithIdx(fragIndex1)) Chem.SanitizeMol(finalMol) finalMolBlock = Chem.MolToMolBlock(finalMol) viewer = py3Dmol.view(width=500, height=500) viewer.addModel(finalMolBlock, &#39;mol&#39;) viewer.setStyle({&quot;stick&quot;:{}}) viewer.zoomTo() . You appear to be running in JupyterLab (or JavaScript failed to load for some other reason). You need to install the 3dmol extension: jupyter labextension install jupyterlab_3dmol . &lt;py3Dmol.view at 0x7f9a80a8b790&gt; . And voilà. Our methyl is nicely placed and oriented. That&#39;s one of the easiest cases and we&#39;ll have to consider torsion angles &amp; protein environment at a later stage as well, but this should provide first basic steps for simple additions like the one done here. .",
            "url": "https://pschmidtke.github.io/blog/rdkit/3d-editor/2021/01/23/grafting-fragments.html",
            "relUrl": "/rdkit/3d-editor/2021/01/23/grafting-fragments.html",
            "date": " • Jan 23, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "I’m a European citizen, currently stranded in France. I did my PhD in Xavier Barril’s excellent group at the University of Barcelona, then a post-doc in molecular modelling within a French pharma company. However, I spent most of my “professional career” at Discngine based in Paris, France. . I’ll likely write about whatever crosses my mind here, but it’ll surely focus on topics around cheminformatics, bioinformatics, binding sites, maybe a few papers. Let’s see where this goes. . This website is powered by fastpages and github. .",
          "url": "https://pschmidtke.github.io/blog/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  
      ,"page2": {
          "title": "",
          "content": "Posts .",
          "url": "https://pschmidtke.github.io/blog/",
          "relUrl": "/",
          "date": ""
      }
      
  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://pschmidtke.github.io/blog/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}